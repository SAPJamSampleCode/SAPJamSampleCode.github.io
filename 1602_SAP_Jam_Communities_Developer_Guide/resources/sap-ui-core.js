// This file has been generated by the SAPUI5 CreateModule Ant-Task
/*!
 * jQuery JavaScript Library v1.7.1
 * http://jquery.com/
 *
 * Copyright 2011, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2011, The Dojo Foundation
 * Released under the MIT, BSD, and GPL Licenses.
 *
 * Date: Mon Nov 21 21:11:03 2011 -0500
 */
(function( window, undefined ) {

// Use the correct document accordingly with window argument (sandbox)
var document = window.document,
	navigator = window.navigator,
	location = window.location;
var jQuery = (function() {

// Define a local copy of jQuery
var jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		return new jQuery.fn.init( selector, context, rootjQuery );
	},

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$,

	// A central reference to the root jQuery(document)
	rootjQuery,

	// A simple way to check for HTML strings or ID strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	quickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,

	// Check if a string has a non-whitespace character in it
	rnotwhite = /\S/,

	// Used for trimming whitespace
	trimLeft = /^\s+/,
	trimRight = /\s+$/,

	// Match a standalone tag
	rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,

	// JSON RegExp
	rvalidchars = /^[\],:{}\s]*$/,
	rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
	rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,

	// Useragent RegExp
	rwebkit = /(webkit)[ \/]([\w.]+)/,
	ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/,
	rmsie = /(msie) ([\w.]+)/,
	rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/,

	// Matches dashed string for camelizing
	rdashAlpha = /-([a-z]|[0-9])/ig,
	rmsPrefix = /^-ms-/,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return ( letter + "" ).toUpperCase();
	},

	// Keep a UserAgent string for use with jQuery.browser
	userAgent = navigator.userAgent,

	// For matching the engine and version of the browser
	browserMatch,

	// The deferred used on DOM ready
	readyList,

	// The ready event handler
	DOMContentLoaded,

	// Save a reference to some core methods
	toString = Object.prototype.toString,
	hasOwn = Object.prototype.hasOwnProperty,
	push = Array.prototype.push,
	slice = Array.prototype.slice,
	trim = String.prototype.trim,
	indexOf = Array.prototype.indexOf,

	// [[Class]] -> type pairs
	class2type = {};

jQuery.fn = jQuery.prototype = {
	constructor: jQuery,
	init: function( selector, context, rootjQuery ) {
		var match, elem, ret, doc;

		// Handle $(""), $(null), or $(undefined)
		if ( !selector ) {
			return this;
		}

		// Handle $(DOMElement)
		if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;
		}

		// The body element only exists once, optimize finding it
		if ( selector === "body" && !context && document.body ) {
			this.context = document;
			this[0] = document.body;
			this.selector = selector;
			this.length = 1;
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			// Are we dealing with HTML string or an ID?
			if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = quickExpr.exec( selector );
			}

			// Verify a match, and that no context was specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;
					doc = ( context ? context.ownerDocument || context : document );

					// If a single string is passed in and it's a single tag
					// just do a createElement and skip the rest
					ret = rsingleTag.exec( selector );

					if ( ret ) {
						if ( jQuery.isPlainObject( context ) ) {
							selector = [ document.createElement( ret[1] ) ];
							jQuery.fn.attr.call( selector, context, true );

						} else {
							selector = [ doc.createElement( ret[1] ) ];
						}

					} else {
						ret = jQuery.buildFragment( [ match[1] ], [ doc ] );
						selector = ( ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment ).childNodes;
					}

					return jQuery.merge( this, selector );

				// HANDLE: $("#id")
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE and Opera return items
						// by name instead of ID
						if ( elem.id !== match[2] ) {
							return rootjQuery.find( selector );
						}

						// Otherwise, we inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return rootjQuery.ready( selector );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	},

	// Start with an empty selector
	selector: "",

	// The current version of jQuery being used
	jquery: "1.7.1",

	// The default length of a jQuery object is 0
	length: 0,

	// The number of elements contained in the matched element set
	size: function() {
		return this.length;
	},

	toArray: function() {
		return slice.call( this, 0 );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num == null ?

			// Return a 'clean' array
			this.toArray() :

			// Return just the object
			( num < 0 ? this[ this.length + num ] : this[ num ] );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems, name, selector ) {
		// Build a new jQuery matched element set
		var ret = this.constructor();

		if ( jQuery.isArray( elems ) ) {
			push.apply( ret, elems );

		} else {
			jQuery.merge( ret, elems );
		}

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		ret.context = this.context;

		if ( name === "find" ) {
			ret.selector = this.selector + ( this.selector ? " " : "" ) + selector;
		} else if ( name ) {
			ret.selector = this.selector + "." + name + "(" + selector + ")";
		}

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	ready: function( fn ) {
		// Attach the listeners
		jQuery.bindReady();

		// Add the callback
		readyList.add( fn );

		return this;
	},

	eq: function( i ) {
		i = +i;
		return i === -1 ?
			this.slice( i ) :
			this.slice( i, i + 1 );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ),
			"slice", slice.call(arguments).join(",") );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: [].sort,
	splice: [].splice
};

// Give the init function the jQuery prototype for later instantiation
jQuery.fn.init.prototype = jQuery.fn;

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( length === i ) {
		target = this;
		--i;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	noConflict: function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	},

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {
		// Either a released hold or an DOMready/load event and not yet ready
		if ( (wait === true && !--jQuery.readyWait) || (wait !== true && !jQuery.isReady) ) {
			// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
			if ( !document.body ) {
				return setTimeout( jQuery.ready, 1 );
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.fireWith( document, [ jQuery ] );

			// Trigger any bound ready events
			if ( jQuery.fn.trigger ) {
				jQuery( document ).trigger( "ready" ).off( "ready" );
			}
		}
	},

	bindReady: function() {
		if ( readyList ) {
			return;
		}

		readyList = jQuery.Callbacks( "once memory" );

		// Catch cases where $(document).ready() is called after the
		// browser event has already occurred.
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			return setTimeout( jQuery.ready, 1 );
		}

		// Mozilla, Opera and webkit nightlies currently support this event
		if ( document.addEventListener ) {
			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", jQuery.ready, false );

		// If IE event model is used
		} else if ( document.attachEvent ) {
			// ensure firing before onload,
			// maybe late but safe also for iframes
			document.attachEvent( "onreadystatechange", DOMContentLoaded );

			// A fallback to window.onload, that will always work
			window.attachEvent( "onload", jQuery.ready );

			// If IE and not a frame
			// continually check to see if the document is ready
			var toplevel = false;

			try {
				toplevel = window.frameElement == null;
			} catch(e) {}

			if ( document.documentElement.doScroll && toplevel ) {
				doScrollCheck();
			}
		}
	},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray || function( obj ) {
		return jQuery.type(obj) === "array";
	},

	// A crude way of determining if an object is a window
	isWindow: function( obj ) {
		return obj && typeof obj === "object" && "setInterval" in obj;
	},

	isNumeric: function( obj ) {
		return !isNaN( parseFloat(obj) ) && isFinite( obj );
	},

	type: function( obj ) {
		return obj == null ?
			String( obj ) :
			class2type[ toString.call(obj) ] || "object";
	},

	isPlainObject: function( obj ) {
		// Must be an Object.
		// Because of IE, we also have to check the presence of the constructor property.
		// Make sure that DOM nodes and window objects don't pass through, as well
		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		try {
			// Not own constructor property must be Object
			if ( obj.constructor &&
				!hasOwn.call(obj, "constructor") &&
				!hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
				return false;
			}
		} catch ( e ) {
			// IE8,9 Will throw exceptions on certain host objects #9897
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.

		var key;
		for ( key in obj ) {}

		return key === undefined || hasOwn.call( obj, key );
	},

	isEmptyObject: function( obj ) {
		for ( var name in obj ) {
			return false;
		}
		return true;
	},

	error: function( msg ) {
		throw new Error( msg );
	},

	parseJSON: function( data ) {
		if ( typeof data !== "string" || !data ) {
			return null;
		}

		// Make sure leading/trailing whitespace is removed (IE can't handle it)
		data = jQuery.trim( data );

		// Attempt to parse using the native JSON parser first
		if ( window.JSON && window.JSON.parse ) {
			return window.JSON.parse( data );
		}

		// Make sure the incoming data is actual JSON
		// Logic borrowed from http://json.org/json2.js
		if ( rvalidchars.test( data.replace( rvalidescape, "@" )
			.replace( rvalidtokens, "]" )
			.replace( rvalidbraces, "")) ) {

			return ( new Function( "return " + data ) )();

		}
		jQuery.error( "Invalid JSON: " + data );
	},

	// Cross-browser xml parsing
	parseXML: function( data ) {
		var xml, tmp;
		try {
			if ( window.DOMParser ) { // Standard
				tmp = new DOMParser();
				xml = tmp.parseFromString( data , "text/xml" );
			} else { // IE
				xml = new ActiveXObject( "Microsoft.XMLDOM" );
				xml.async = "false";
				xml.loadXML( data );
			}
		} catch( e ) {
			xml = undefined;
		}
		if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	},

	noop: function() {},

	// Evaluates a script in a global context
	// Workarounds based on findings by Jim Driscoll
	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
	globalEval: function( data ) {
		if ( data && rnotwhite.test( data ) ) {
			// We use execScript on Internet Explorer
			// We use an anonymous function so that context is window
			// rather than jQuery in Firefox
			( window.execScript || function( data ) {
				window[ "eval" ].call( window, data );
			} )( data );
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();
	},

	// args is for internal usage only
	each: function( object, callback, args ) {
		var name, i = 0,
			length = object.length,
			isObj = length === undefined || jQuery.isFunction( object );

		if ( args ) {
			if ( isObj ) {
				for ( name in object ) {
					if ( callback.apply( object[ name ], args ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.apply( object[ i++ ], args ) === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isObj ) {
				for ( name in object ) {
					if ( callback.call( object[ name ], name, object[ name ] ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.call( object[ i ], i, object[ i++ ] ) === false ) {
						break;
					}
				}
			}
		}

		return object;
	},

	// Use native String.trim function wherever possible
	trim: trim ?
		function( text ) {
			return text == null ?
				"" :
				trim.call( text );
		} :

		// Otherwise use our own trimming functionality
		function( text ) {
			return text == null ?
				"" :
				text.toString().replace( trimLeft, "" ).replace( trimRight, "" );
		},

	// results is for internal usage only
	makeArray: function( array, results ) {
		var ret = results || [];

		if ( array != null ) {
			// The window, strings (and functions) also have 'length'
			// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
			var type = jQuery.type( array );

			if ( array.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow( array ) ) {
				push.call( ret, array );
			} else {
				jQuery.merge( ret, array );
			}
		}

		return ret;
	},

	inArray: function( elem, array, i ) {
		var len;

		if ( array ) {
			if ( indexOf ) {
				return indexOf.call( array, elem, i );
			}

			len = array.length;
			i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

			for ( ; i < len; i++ ) {
				// Skip accessing in sparse arrays
				if ( i in array && array[ i ] === elem ) {
					return i;
				}
			}
		}

		return -1;
	},

	merge: function( first, second ) {
		var i = first.length,
			j = 0;

		if ( typeof second.length === "number" ) {
			for ( var l = second.length; j < l; j++ ) {
				first[ i++ ] = second[ j ];
			}

		} else {
			while ( second[j] !== undefined ) {
				first[ i++ ] = second[ j++ ];
			}
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, inv ) {
		var ret = [], retVal;
		inv = !!inv;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( var i = 0, length = elems.length; i < length; i++ ) {
			retVal = !!callback( elems[ i ], i );
			if ( inv !== retVal ) {
				ret.push( elems[ i ] );
			}
		}

		return ret;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value, key, ret = [],
			i = 0,
			length = elems.length,
			// jquery objects are treated as arrays
			isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;

		// Go through the array, translating each of the items to their
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}

		// Go through every key on the object,
		} else {
			for ( key in elems ) {
				value = callback( elems[ key ], key, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}
		}

		// Flatten any nested arrays
		return ret.concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		if ( typeof context === "string" ) {
			var tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		var args = slice.call( arguments, 2 ),
			proxy = function() {
				return fn.apply( context, args.concat( slice.call( arguments ) ) );
			};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;

		return proxy;
	},

	// Mutifunctional method to get and set values to a collection
	// The value/s can optionally be executed if it's a function
	access: function( elems, key, value, exec, fn, pass ) {
		var length = elems.length;

		// Setting many attributes
		if ( typeof key === "object" ) {
			for ( var k in key ) {
				jQuery.access( elems, k, key[k], exec, fn, value );
			}
			return elems;
		}

		// Setting one attribute
		if ( value !== undefined ) {
			// Optionally, function values get executed if exec is true
			exec = !pass && exec && jQuery.isFunction(value);

			for ( var i = 0; i < length; i++ ) {
				fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
			}

			return elems;
		}

		// Getting an attribute
		return length ? fn( elems[0], key ) : undefined;
	},

	now: function() {
		return ( new Date() ).getTime();
	},

	// Use of jQuery.browser is frowned upon.
	// More details: http://docs.jquery.com/Utilities/jQuery.browser
	uaMatch: function( ua ) {
		ua = ua.toLowerCase();

		var match = rwebkit.exec( ua ) ||
			ropera.exec( ua ) ||
			rmsie.exec( ua ) ||
			ua.indexOf("compatible") < 0 && rmozilla.exec( ua ) ||
			[];

		return { browser: match[1] || "", version: match[2] || "0" };
	},

	sub: function() {
		function jQuerySub( selector, context ) {
			return new jQuerySub.fn.init( selector, context );
		}
		jQuery.extend( true, jQuerySub, this );
		jQuerySub.superclass = this;
		jQuerySub.fn = jQuerySub.prototype = this();
		jQuerySub.fn.constructor = jQuerySub;
		jQuerySub.sub = this.sub;
		jQuerySub.fn.init = function init( selector, context ) {
			if ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {
				context = jQuerySub( context );
			}

			return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
		};
		jQuerySub.fn.init.prototype = jQuerySub.fn;
		var rootjQuerySub = jQuerySub(document);
		return jQuerySub;
	},

	browser: {}
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

browserMatch = jQuery.uaMatch( userAgent );
if ( browserMatch.browser ) {
	jQuery.browser[ browserMatch.browser ] = true;
	jQuery.browser.version = browserMatch.version;
}

// Deprecated, use jQuery.browser.webkit instead
if ( jQuery.browser.webkit ) {
	jQuery.browser.safari = true;
}

// IE doesn't match non-breaking spaces with \s
if ( rnotwhite.test( "\xA0" ) ) {
	trimLeft = /^[\s\xA0]+/;
	trimRight = /[\s\xA0]+$/;
}

// All jQuery objects should point back to these
rootjQuery = jQuery(document);

// Cleanup functions for the document ready method
if ( document.addEventListener ) {
	DOMContentLoaded = function() {
		document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
		jQuery.ready();
	};

} else if ( document.attachEvent ) {
	DOMContentLoaded = function() {
		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
		if ( document.readyState === "complete" ) {
			document.detachEvent( "onreadystatechange", DOMContentLoaded );
			jQuery.ready();
		}
	};
}

// The DOM ready check for Internet Explorer
function doScrollCheck() {
	if ( jQuery.isReady ) {
		return;
	}

	try {
		// If IE is used, use the trick by Diego Perini
		// http://javascript.nwbox.com/IEContentLoaded/
		document.documentElement.doScroll("left");
	} catch(e) {
		setTimeout( doScrollCheck, 1 );
		return;
	}

	// and execute any waiting functions
	jQuery.ready();
}

return jQuery;

})();


// String to Object flags format cache
var flagsCache = {};

// Convert String-formatted flags into Object-formatted ones and store in cache
function createFlags( flags ) {
	var object = flagsCache[ flags ] = {},
		i, length;
	flags = flags.split( /\s+/ );
	for ( i = 0, length = flags.length; i < length; i++ ) {
		object[ flags[i] ] = true;
	}
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	flags:	an optional list of space-separated flags that will change how
 *			the callback list behaves
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible flags:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( flags ) {

	// Convert flags from String-formatted to Object-formatted
	// (we check in cache first)
	flags = flags ? ( flagsCache[ flags ] || createFlags( flags ) ) : {};

	var // Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = [],
		// Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Add one or several callbacks to the list
		add = function( args ) {
			var i,
				length,
				elem,
				type,
				actual;
			for ( i = 0, length = args.length; i < length; i++ ) {
				elem = args[ i ];
				type = jQuery.type( elem );
				if ( type === "array" ) {
					// Inspect recursively
					add( elem );
				} else if ( type === "function" ) {
					// Add if not in unique mode and callback is not in
					if ( !flags.unique || !self.has( elem ) ) {
						list.push( elem );
					}
				}
			}
		},
		// Fire callbacks
		fire = function( context, args ) {
			args = args || [];
			memory = !flags.memory || [ context, args ];
			firing = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( context, args ) === false && flags.stopOnFalse ) {
					memory = true; // Mark as halted
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( !flags.once ) {
					if ( stack && stack.length ) {
						memory = stack.shift();
						self.fireWith( memory[ 0 ], memory[ 1 ] );
					}
				} else if ( memory === true ) {
					self.disable();
				} else {
					list = [];
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					var length = list.length;
					add( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away, unless previous
					// firing was halted (stopOnFalse)
					} else if ( memory && memory !== true ) {
						firingStart = length;
						fire( memory[ 0 ], memory[ 1 ] );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					var args = arguments,
						argIndex = 0,
						argLength = args.length;
					for ( ; argIndex < argLength ; argIndex++ ) {
						for ( var i = 0; i < list.length; i++ ) {
							if ( args[ argIndex ] === list[ i ] ) {
								// Handle firingIndex and firingLength
								if ( firing ) {
									if ( i <= firingLength ) {
										firingLength--;
										if ( i <= firingIndex ) {
											firingIndex--;
										}
									}
								}
								// Remove the element
								list.splice( i--, 1 );
								// If we have some unicity property then
								// we only need to do this once
								if ( flags.unique ) {
									break;
								}
							}
						}
					}
				}
				return this;
			},
			// Control if a given callback is in the list
			has: function( fn ) {
				if ( list ) {
					var i = 0,
						length = list.length;
					for ( ; i < length; i++ ) {
						if ( fn === list[ i ] ) {
							return true;
						}
					}
				}
				return false;
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory || memory === true ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( stack ) {
					if ( firing ) {
						if ( !flags.once ) {
							stack.push( [ context, args ] );
						}
					} else if ( !( flags.once && memory ) ) {
						fire( context, args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!memory;
			}
		};

	return self;
};




var // Static reference to slice
	sliceDeferred = [].slice;

jQuery.extend({

	Deferred: function( func ) {
		var doneList = jQuery.Callbacks( "once memory" ),
			failList = jQuery.Callbacks( "once memory" ),
			progressList = jQuery.Callbacks( "memory" ),
			state = "pending",
			lists = {
				resolve: doneList,
				reject: failList,
				notify: progressList
			},
			promise = {
				done: doneList.add,
				fail: failList.add,
				progress: progressList.add,

				state: function() {
					return state;
				},

				// Deprecated
				isResolved: doneList.fired,
				isRejected: failList.fired,

				then: function( doneCallbacks, failCallbacks, progressCallbacks ) {
					deferred.done( doneCallbacks ).fail( failCallbacks ).progress( progressCallbacks );
					return this;
				},
				always: function() {
					deferred.done.apply( deferred, arguments ).fail.apply( deferred, arguments );
					return this;
				},
				pipe: function( fnDone, fnFail, fnProgress ) {
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( {
							done: [ fnDone, "resolve" ],
							fail: [ fnFail, "reject" ],
							progress: [ fnProgress, "notify" ]
						}, function( handler, data ) {
							var fn = data[ 0 ],
								action = data[ 1 ],
								returned;
							if ( jQuery.isFunction( fn ) ) {
								deferred[ handler ](function() {
									returned = fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise().then( newDefer.resolve, newDefer.reject, newDefer.notify );
									} else {
										newDefer[ action + "With" ]( this === deferred ? newDefer : this, [ returned ] );
									}
								});
							} else {
								deferred[ handler ]( newDefer[ action ] );
							}
						});
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					if ( obj == null ) {
						obj = promise;
					} else {
						for ( var key in promise ) {
							obj[ key ] = promise[ key ];
						}
					}
					return obj;
				}
			},
			deferred = promise.promise({}),
			key;

		for ( key in lists ) {
			deferred[ key ] = lists[ key ].fire;
			deferred[ key + "With" ] = lists[ key ].fireWith;
		}

		// Handle state
		deferred.done( function() {
			state = "resolved";
		}, failList.disable, progressList.lock ).fail( function() {
			state = "rejected";
		}, doneList.disable, progressList.lock );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( firstParam ) {
		var args = sliceDeferred.call( arguments, 0 ),
			i = 0,
			length = args.length,
			pValues = new Array( length ),
			count = length,
			pCount = length,
			deferred = length <= 1 && firstParam && jQuery.isFunction( firstParam.promise ) ?
				firstParam :
				jQuery.Deferred(),
			promise = deferred.promise();
		function resolveFunc( i ) {
			return function( value ) {
				args[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
				if ( !( --count ) ) {
					deferred.resolveWith( deferred, args );
				}
			};
		}
		function progressFunc( i ) {
			return function( value ) {
				pValues[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
				deferred.notifyWith( promise, pValues );
			};
		}
		if ( length > 1 ) {
			for ( ; i < length; i++ ) {
				if ( args[ i ] && args[ i ].promise && jQuery.isFunction( args[ i ].promise ) ) {
					args[ i ].promise().then( resolveFunc(i), deferred.reject, progressFunc(i) );
				} else {
					--count;
				}
			}
			if ( !count ) {
				deferred.resolveWith( deferred, args );
			}
		} else if ( deferred !== firstParam ) {
			deferred.resolveWith( deferred, length ? [ firstParam ] : [] );
		}
		return promise;
	}
});




jQuery.support = (function() {

	var support,
		all,
		a,
		select,
		opt,
		input,
		marginDiv,
		fragment,
		tds,
		events,
		eventName,
		i,
		isSupported,
		div = document.createElement( "div" ),
		documentElement = document.documentElement;

	// Preliminary tests
	div.setAttribute("className", "t");
	div.innerHTML = "   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>";

	all = div.getElementsByTagName( "*" );
	a = div.getElementsByTagName( "a" )[ 0 ];

	// Can't get basic test support
	if ( !all || !all.length || !a ) {
		return {};
	}

	// First batch of supports tests
	select = document.createElement( "select" );
	opt = select.appendChild( document.createElement("option") );
	input = div.getElementsByTagName( "input" )[ 0 ];

	support = {
		// IE strips leading whitespace when .innerHTML is used
		leadingWhitespace: ( div.firstChild.nodeType === 3 ),

		// Make sure that tbody elements aren't automatically inserted
		// IE will insert them into empty tables
		tbody: !div.getElementsByTagName("tbody").length,

		// Make sure that link elements get serialized correctly by innerHTML
		// This requires a wrapper element in IE
		htmlSerialize: !!div.getElementsByTagName("link").length,

		// Get the style information from getAttribute
		// (IE uses .cssText instead)
		style: /top/.test( a.getAttribute("style") ),

		// Make sure that URLs aren't manipulated
		// (IE normalizes it by default)
		hrefNormalized: ( a.getAttribute("href") === "/a" ),

		// Make sure that element opacity exists
		// (IE uses filter instead)
		// Use a regex to work around a WebKit issue. See #5145
		opacity: /^0.55/.test( a.style.opacity ),

		// Verify style float existence
		// (IE uses styleFloat instead of cssFloat)
		cssFloat: !!a.style.cssFloat,

		// Make sure that if no value is specified for a checkbox
		// that it defaults to "on".
		// (WebKit defaults to "" instead)
		checkOn: ( input.value === "on" ),

		// Make sure that a selected-by-default option has a working selected property.
		// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
		optSelected: opt.selected,

		// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
		getSetAttribute: div.className !== "t",

		// Tests for enctype support on a form(#6743)
		enctype: !!document.createElement("form").enctype,

		// Makes sure cloning an html5 element does not cause problems
		// Where outerHTML is undefined, this still works
		html5Clone: document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>",

		// Will be defined later
		submitBubbles: true,
		changeBubbles: true,
		focusinBubbles: false,
		deleteExpando: true,
		noCloneEvent: true,
		inlineBlockNeedsLayout: false,
		shrinkWrapBlocks: false,
		reliableMarginRight: true
	};

	// Make sure checked status is properly cloned
	input.checked = true;
	support.noCloneChecked = input.cloneNode( true ).checked;

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as disabled)
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Test to see if it's possible to delete an expando from an element
	// Fails in Internet Explorer
	try {
		delete div.test;
	} catch( e ) {
		support.deleteExpando = false;
	}

	if ( !div.addEventListener && div.attachEvent && div.fireEvent ) {
		div.attachEvent( "onclick", function() {
			// Cloning a node shouldn't copy over any
			// bound event handlers (IE does this)
			support.noCloneEvent = false;
		});
		div.cloneNode( true ).fireEvent( "onclick" );
	}

	// Check if a radio maintains its value
	// after being appended to the DOM
	input = document.createElement("input");
	input.value = "t";
	input.setAttribute("type", "radio");
	support.radioValue = input.value === "t";

	input.setAttribute("checked", "checked");
	div.appendChild( input );
	fragment = document.createDocumentFragment();
	fragment.appendChild( div.lastChild );

	// WebKit doesn't clone checked state correctly in fragments
	support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Check if a disconnected checkbox will retain its checked
	// value of true after appended to the DOM (IE6/7)
	support.appendChecked = input.checked;

	fragment.removeChild( input );
	fragment.appendChild( div );

	div.innerHTML = "";

	// Check if div with explicit width and no margin-right incorrectly
	// gets computed margin-right based on width of container. For more
	// info see bug #3333
	// Fails in WebKit before Feb 2011 nightlies
	// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
	if ( window.getComputedStyle ) {
		marginDiv = document.createElement( "div" );
		marginDiv.style.width = "0";
		marginDiv.style.marginRight = "0";
		div.style.width = "2px";
		div.appendChild( marginDiv );
		support.reliableMarginRight =
			( parseInt( ( window.getComputedStyle( marginDiv, null ) || { marginRight: 0 } ).marginRight, 10 ) || 0 ) === 0;
	}

	// Technique from Juriy Zaytsev
	// http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
	// We only care about the case where non-standard event systems
	// are used, namely in IE. Short-circuiting here helps us to
	// avoid an eval call (in setAttribute) which can cause CSP
	// to go haywire. See: https://developer.mozilla.org/en/Security/CSP
	if ( div.attachEvent ) {
		for( i in {
			submit: 1,
			change: 1,
			focusin: 1
		}) {
			eventName = "on" + i;
			isSupported = ( eventName in div );
			if ( !isSupported ) {
				div.setAttribute( eventName, "return;" );
				isSupported = ( typeof div[ eventName ] === "function" );
			}
			support[ i + "Bubbles" ] = isSupported;
		}
	}

	fragment.removeChild( div );

	// Null elements to avoid leaks in IE
	fragment = select = opt = marginDiv = div = input = null;

	// Run tests that need a body at doc ready
	jQuery(function() {
		var container, outer, inner, table, td, offsetSupport,
			conMarginTop, ptlm, vb, style, html,
			body = document.getElementsByTagName("body")[0];

		if ( !body ) {
			// Return for frameset docs that don't have a body
			return;
		}

		conMarginTop = 1;
		ptlm = "position:absolute;top:0;left:0;width:1px;height:1px;margin:0;";
		vb = "visibility:hidden;border:0;";
		style = "style='" + ptlm + "border:5px solid #000;padding:0;'";
		html = "<div " + style + "><div></div></div>" +
			"<table " + style + " cellpadding='0' cellspacing='0'>" +
			"<tr><td></td></tr></table>";

		container = document.createElement("div");
		container.style.cssText = vb + "width:0;height:0;position:static;top:0;margin-top:" + conMarginTop + "px";
		body.insertBefore( container, body.firstChild );

		// Construct the test element
		div = document.createElement("div");
		container.appendChild( div );

		// Check if table cells still have offsetWidth/Height when they are set
		// to display:none and there are still other visible table cells in a
		// table row; if so, offsetWidth/Height are not reliable for use when
		// determining if an element has been hidden directly using
		// display:none (it is still safe to use offsets if a parent element is
		// hidden; don safety goggles and see bug #4512 for more information).
		// (only IE 8 fails this test)
		div.innerHTML = "<table><tr><td style='padding:0;border:0;display:none'></td><td>t</td></tr></table>";
		tds = div.getElementsByTagName( "td" );
		isSupported = ( tds[ 0 ].offsetHeight === 0 );

		tds[ 0 ].style.display = "";
		tds[ 1 ].style.display = "none";

		// Check if empty table cells still have offsetWidth/Height
		// (IE <= 8 fail this test)
		support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );

		// Figure out if the W3C box model works as expected
		div.innerHTML = "";
		div.style.width = div.style.paddingLeft = "1px";
		jQuery.boxModel = support.boxModel = div.offsetWidth === 2;

		if ( typeof div.style.zoom !== "undefined" ) {
			// Check if natively block-level elements act like inline-block
			// elements when setting their display to 'inline' and giving
			// them layout
			// (IE < 8 does this)
			div.style.display = "inline";
			div.style.zoom = 1;
			support.inlineBlockNeedsLayout = ( div.offsetWidth === 2 );

			// Check if elements with layout shrink-wrap their children
			// (IE 6 does this)
			div.style.display = "";
			div.innerHTML = "<div style='width:4px;'></div>";
			support.shrinkWrapBlocks = ( div.offsetWidth !== 2 );
		}

		div.style.cssText = ptlm + vb;
		div.innerHTML = html;

		outer = div.firstChild;
		inner = outer.firstChild;
		td = outer.nextSibling.firstChild.firstChild;

		offsetSupport = {
			doesNotAddBorder: ( inner.offsetTop !== 5 ),
			doesAddBorderForTableAndCells: ( td.offsetTop === 5 )
		};

		inner.style.position = "fixed";
		inner.style.top = "20px";

		// safari subtracts parent border width here which is 5px
		offsetSupport.fixedPosition = ( inner.offsetTop === 20 || inner.offsetTop === 15 );
		inner.style.position = inner.style.top = "";

		outer.style.overflow = "hidden";
		outer.style.position = "relative";

		offsetSupport.subtractsBorderForOverflowNotVisible = ( inner.offsetTop === -5 );
		offsetSupport.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== conMarginTop );

		body.removeChild( container );
		div  = container = null;

		jQuery.extend( support, offsetSupport );
	});

	return support;
})();




var rbrace = /^(?:\{.*\}|\[.*\])$/,
	rmultiDash = /([A-Z])/g;

jQuery.extend({
	cache: {},

	// Please use with caution
	uuid: 0,

	// Unique for each copy of jQuery on the page
	// Non-digits removed to match rinlinejQuery
	expando: "jQuery" + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, "" ),

	// The following elements throw uncatchable exceptions if you
	// attempt to add expando properties to them.
	noData: {
		"embed": true,
		// Ban all objects except for Flash (which handle expandos)
		"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
		"applet": true
	},

	hasData: function( elem ) {
		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
		return !!elem && !isEmptyDataObject( elem );
	},

	data: function( elem, name, data, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var privateCache, thisCache, ret,
			internalKey = jQuery.expando,
			getByName = typeof name === "string",

			// We have to handle DOM nodes and JS objects differently because IE6-7
			// can't GC object references properly across the DOM-JS boundary
			isNode = elem.nodeType,

			// Only DOM nodes need the global jQuery cache; JS object data is
			// attached directly to the object so GC can occur automatically
			cache = isNode ? jQuery.cache : elem,

			// Only defining an ID for JS objects if its cache already exists allows
			// the code to shortcut on the same path as a DOM node with no cache
			id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey,
			isEvents = name === "events";

		// Avoid doing any more work than we need to when trying to get data on an
		// object that has no data at all
		if ( (!id || !cache[id] || (!isEvents && !pvt && !cache[id].data)) && getByName && data === undefined ) {
			return;
		}

		if ( !id ) {
			// Only DOM nodes need a new unique ID for each element since their data
			// ends up in the global cache
			if ( isNode ) {
				elem[ internalKey ] = id = ++jQuery.uuid;
			} else {
				id = internalKey;
			}
		}

		if ( !cache[ id ] ) {
			cache[ id ] = {};

			// Avoids exposing jQuery metadata on plain JS objects when the object
			// is serialized using JSON.stringify
			if ( !isNode ) {
				cache[ id ].toJSON = jQuery.noop;
			}
		}

		// An object can be passed to jQuery.data instead of a key/value pair; this gets
		// shallow copied over onto the existing cache
		if ( typeof name === "object" || typeof name === "function" ) {
			if ( pvt ) {
				cache[ id ] = jQuery.extend( cache[ id ], name );
			} else {
				cache[ id ].data = jQuery.extend( cache[ id ].data, name );
			}
		}

		privateCache = thisCache = cache[ id ];

		// jQuery data() is stored in a separate object inside the object's internal data
		// cache in order to avoid key collisions between internal data and user-defined
		// data.
		if ( !pvt ) {
			if ( !thisCache.data ) {
				thisCache.data = {};
			}

			thisCache = thisCache.data;
		}

		if ( data !== undefined ) {
			thisCache[ jQuery.camelCase( name ) ] = data;
		}

		// Users should not attempt to inspect the internal events object using jQuery.data,
		// it is undocumented and subject to change. But does anyone listen? No.
		if ( isEvents && !thisCache[ name ] ) {
			return privateCache.events;
		}

		// Check for both converted-to-camel and non-converted data property names
		// If a data property was specified
		if ( getByName ) {

			// First Try to find as-is property data
			ret = thisCache[ name ];

			// Test for null|undefined property data
			if ( ret == null ) {

				// Try to find the camelCased property
				ret = thisCache[ jQuery.camelCase( name ) ];
			}
		} else {
			ret = thisCache;
		}

		return ret;
	},

	removeData: function( elem, name, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var thisCache, i, l,

			// Reference to internal data cache key
			internalKey = jQuery.expando,

			isNode = elem.nodeType,

			// See jQuery.data for more information
			cache = isNode ? jQuery.cache : elem,

			// See jQuery.data for more information
			id = isNode ? elem[ internalKey ] : internalKey;

		// If there is already no cache entry for this object, there is no
		// purpose in continuing
		if ( !cache[ id ] ) {
			return;
		}

		if ( name ) {

			thisCache = pvt ? cache[ id ] : cache[ id ].data;

			if ( thisCache ) {

				// Support array or space separated string names for data keys
				if ( !jQuery.isArray( name ) ) {

					// try the string as a key before any manipulation
					if ( name in thisCache ) {
						name = [ name ];
					} else {

						// split the camel cased version by spaces unless a key with the spaces exists
						name = jQuery.camelCase( name );
						if ( name in thisCache ) {
							name = [ name ];
						} else {
							name = name.split( " " );
						}
					}
				}

				for ( i = 0, l = name.length; i < l; i++ ) {
					delete thisCache[ name[i] ];
				}

				// If there is no data left in the cache, we want to continue
				// and let the cache object itself get destroyed
				if ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {
					return;
				}
			}
		}

		// See jQuery.data for more information
		if ( !pvt ) {
			delete cache[ id ].data;

			// Don't destroy the parent cache unless the internal data object
			// had been the only thing left in it
			if ( !isEmptyDataObject(cache[ id ]) ) {
				return;
			}
		}

		// Browsers that fail expando deletion also refuse to delete expandos on
		// the window, but it will allow it on all other JS objects; other browsers
		// don't care
		// Ensure that `cache` is not a window object #10080
		if ( jQuery.support.deleteExpando || !cache.setInterval ) {
			delete cache[ id ];
		} else {
			cache[ id ] = null;
		}

		// We destroyed the cache and need to eliminate the expando on the node to avoid
		// false lookups in the cache for entries that no longer exist
		if ( isNode ) {
			// IE does not allow us to delete expando properties from nodes,
			// nor does it have a removeAttribute function on Document nodes;
			// we must handle all of these cases
			if ( jQuery.support.deleteExpando ) {
				delete elem[ internalKey ];
			} else if ( elem.removeAttribute ) {
				elem.removeAttribute( internalKey );
			} else {
				elem[ internalKey ] = null;
			}
		}
	},

	// For internal use only.
	_data: function( elem, name, data ) {
		return jQuery.data( elem, name, data, true );
	},

	// A method for determining if a DOM node can handle the data expando
	acceptData: function( elem ) {
		if ( elem.nodeName ) {
			var match = jQuery.noData[ elem.nodeName.toLowerCase() ];

			if ( match ) {
				return !(match === true || elem.getAttribute("classid") !== match);
			}
		}

		return true;
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var parts, attr, name,
			data = null;

		if ( typeof key === "undefined" ) {
			if ( this.length ) {
				data = jQuery.data( this[0] );

				if ( this[0].nodeType === 1 && !jQuery._data( this[0], "parsedAttrs" ) ) {
					attr = this[0].attributes;
					for ( var i = 0, l = attr.length; i < l; i++ ) {
						name = attr[i].name;

						if ( name.indexOf( "data-" ) === 0 ) {
							name = jQuery.camelCase( name.substring(5) );

							dataAttr( this[0], name, data[ name ] );
						}
					}
					jQuery._data( this[0], "parsedAttrs", true );
				}
			}

			return data;

		} else if ( typeof key === "object" ) {
			return this.each(function() {
				jQuery.data( this, key );
			});
		}

		parts = key.split(".");
		parts[1] = parts[1] ? "." + parts[1] : "";

		if ( value === undefined ) {
			data = this.triggerHandler("getData" + parts[1] + "!", [parts[0]]);

			// Try to fetch any internally stored data first
			if ( data === undefined && this.length ) {
				data = jQuery.data( this[0], key );
				data = dataAttr( this[0], key, data );
			}

			return data === undefined && parts[1] ?
				this.data( parts[0] ) :
				data;

		} else {
			return this.each(function() {
				var self = jQuery( this ),
					args = [ parts[0], value ];

				self.triggerHandler( "setData" + parts[1] + "!", args );
				jQuery.data( this, key, value );
				self.triggerHandler( "changeData" + parts[1] + "!", args );
			});
		}
	},

	removeData: function( key ) {
		return this.each(function() {
			jQuery.removeData( this, key );
		});
	}
});

function dataAttr( elem, key, data ) {
	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {

		var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
				data === "false" ? false :
				data === "null" ? null :
				jQuery.isNumeric( data ) ? parseFloat( data ) :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			jQuery.data( elem, key, data );

		} else {
			data = undefined;
		}
	}

	return data;
}

// checks a cache object for emptiness
function isEmptyDataObject( obj ) {
	for ( var name in obj ) {

		// if the public data object is empty, the private is still empty
		if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
			continue;
		}
		if ( name !== "toJSON" ) {
			return false;
		}
	}

	return true;
}




function handleQueueMarkDefer( elem, type, src ) {
	var deferDataKey = type + "defer",
		queueDataKey = type + "queue",
		markDataKey = type + "mark",
		defer = jQuery._data( elem, deferDataKey );
	if ( defer &&
		( src === "queue" || !jQuery._data(elem, queueDataKey) ) &&
		( src === "mark" || !jQuery._data(elem, markDataKey) ) ) {
		// Give room for hard-coded callbacks to fire first
		// and eventually mark/queue something else on the element
		setTimeout( function() {
			if ( !jQuery._data( elem, queueDataKey ) &&
				!jQuery._data( elem, markDataKey ) ) {
				jQuery.removeData( elem, deferDataKey, true );
				defer.fire();
			}
		}, 0 );
	}
}

jQuery.extend({

	_mark: function( elem, type ) {
		if ( elem ) {
			type = ( type || "fx" ) + "mark";
			jQuery._data( elem, type, (jQuery._data( elem, type ) || 0) + 1 );
		}
	},

	_unmark: function( force, elem, type ) {
		if ( force !== true ) {
			type = elem;
			elem = force;
			force = false;
		}
		if ( elem ) {
			type = type || "fx";
			var key = type + "mark",
				count = force ? 0 : ( (jQuery._data( elem, key ) || 1) - 1 );
			if ( count ) {
				jQuery._data( elem, key, count );
			} else {
				jQuery.removeData( elem, key, true );
				handleQueueMarkDefer( elem, type, "mark" );
			}
		}
	},

	queue: function( elem, type, data ) {
		var q;
		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			q = jQuery._data( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !q || jQuery.isArray(data) ) {
					q = jQuery._data( elem, type, jQuery.makeArray(data) );
				} else {
					q.push( data );
				}
			}
			return q || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			fn = queue.shift(),
			hooks = {};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
		}

		if ( fn ) {
			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			jQuery._data( elem, type + ".run", hooks );
			fn.call( elem, function() {
				jQuery.dequeue( elem, type );
			}, hooks );
		}

		if ( !queue.length ) {
			jQuery.removeData( elem, type + "queue " + type + ".run", true );
			handleQueueMarkDefer( elem, type, "queue" );
		}
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
		}

		if ( data === undefined ) {
			return jQuery.queue( this[0], type );
		}
		return this.each(function() {
			var queue = jQuery.queue( this, type, data );

			if ( type === "fx" && queue[0] !== "inprogress" ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	// Based off of the plugin by Clint Helfers, with permission.
	// http://blindsignals.com/index.php/2009/07/jquery-delay/
	delay: function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = setTimeout( next, time );
			hooks.stop = function() {
				clearTimeout( timeout );
			};
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, object ) {
		if ( typeof type !== "string" ) {
			object = type;
			type = undefined;
		}
		type = type || "fx";
		var defer = jQuery.Deferred(),
			elements = this,
			i = elements.length,
			count = 1,
			deferDataKey = type + "defer",
			queueDataKey = type + "queue",
			markDataKey = type + "mark",
			tmp;
		function resolve() {
			if ( !( --count ) ) {
				defer.resolveWith( elements, [ elements ] );
			}
		}
		while( i-- ) {
			if (( tmp = jQuery.data( elements[ i ], deferDataKey, undefined, true ) ||
					( jQuery.data( elements[ i ], queueDataKey, undefined, true ) ||
						jQuery.data( elements[ i ], markDataKey, undefined, true ) ) &&
					jQuery.data( elements[ i ], deferDataKey, jQuery.Callbacks( "once memory" ), true ) )) {
				count++;
				tmp.add( resolve );
			}
		}
		resolve();
		return defer.promise();
	}
});




var rclass = /[\n\t\r]/g,
	rspace = /\s+/,
	rreturn = /\r/g,
	rtype = /^(?:button|input)$/i,
	rfocusable = /^(?:button|input|object|select|textarea)$/i,
	rclickable = /^a(?:rea)?$/i,
	rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
	getSetAttribute = jQuery.support.getSetAttribute,
	nodeHook, boolHook, fixSpecified;

jQuery.fn.extend({
	attr: function( name, value ) {
		return jQuery.access( this, name, value, true, jQuery.attr );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	},

	prop: function( name, value ) {
		return jQuery.access( this, name, value, true, jQuery.prop );
	},

	removeProp: function( name ) {
		name = jQuery.propFix[ name ] || name;
		return this.each(function() {
			// try/catch handles cases where IE balks (such as removing a property on window)
			try {
				this[ name ] = undefined;
				delete this[ name ];
			} catch( e ) {}
		});
	},

	addClass: function( value ) {
		var classNames, i, l, elem,
			setClass, c, cl;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call(this, j, this.className) );
			});
		}

		if ( value && typeof value === "string" ) {
			classNames = value.split( rspace );

			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];

				if ( elem.nodeType === 1 ) {
					if ( !elem.className && classNames.length === 1 ) {
						elem.className = value;

					} else {
						setClass = " " + elem.className + " ";

						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
							if ( !~setClass.indexOf( " " + classNames[ c ] + " " ) ) {
								setClass += classNames[ c ] + " ";
							}
						}
						elem.className = jQuery.trim( setClass );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classNames, i, l, elem, className, c, cl;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call(this, j, this.className) );
			});
		}

		if ( (value && typeof value === "string") || value === undefined ) {
			classNames = ( value || "" ).split( rspace );

			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];

				if ( elem.nodeType === 1 && elem.className ) {
					if ( value ) {
						className = (" " + elem.className + " ").replace( rclass, " " );
						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
							className = className.replace(" " + classNames[ c ] + " ", " ");
						}
						elem.className = jQuery.trim( className );

					} else {
						elem.className = "";
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isBool = typeof stateVal === "boolean";

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					state = stateVal,
					classNames = value.split( rspace );

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space seperated list
					state = isBool ? state : !self.hasClass( className );
					self[ state ? "addClass" : "removeClass" ]( className );
				}

			} else if ( type === "undefined" || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					jQuery._data( this, "__className__", this.className );
				}

				// toggle whole className
				this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	},

	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.nodeName.toLowerCase() ] || jQuery.valHooks[ elem.type ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// handle most common string cases
					ret.replace(rreturn, "") :
					// handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var self = jQuery(this), val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, self.val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";
			} else if ( typeof val === "number" ) {
				val += "";
			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map(val, function ( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.nodeName.toLowerCase() ] || jQuery.valHooks[ this.type ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				// attributes.value is undefined in Blackberry 4.7 but
				// uses .value. See #6932
				var val = elem.attributes.value;
				return !val || val.specified ? elem.value : elem.text;
			}
		},
		select: {
			get: function( elem ) {
				var value, i, max, option,
					index = elem.selectedIndex,
					values = [],
					options = elem.options,
					one = elem.type === "select-one";

				// Nothing was selected
				if ( index < 0 ) {
					return null;
				}

				// Loop through all the selected options
				i = one ? index : 0;
				max = one ? index + 1 : options.length;
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Don't return options that are disabled or in a disabled optgroup
					if ( option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
							(!option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" )) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				// Fixes Bug #2551 -- select.val() broken in IE after form.reset()
				if ( one && !values.length && options.length ) {
					return jQuery( options[ index ] ).val();
				}

				return values;
			},

			set: function( elem, value ) {
				var values = jQuery.makeArray( value );

				jQuery(elem).find("option").each(function() {
					this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
				});

				if ( !values.length ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	},

	attrFn: {
		val: true,
		css: true,
		html: true,
		text: true,
		data: true,
		width: true,
		height: true,
		offset: true
	},

	attr: function( elem, name, value, pass ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( pass && name in jQuery.attrFn ) {
			return jQuery( elem )[ name ]( value );
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( notxml ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;

			} else if ( hooks && "set" in hooks && notxml && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, "" + value );
				return value;
			}

		} else if ( hooks && "get" in hooks && notxml && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {

			ret = elem.getAttribute( name );

			// Non-existent attributes return null, we normalize to undefined
			return ret === null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var propName, attrNames, name, l,
			i = 0;

		if ( value && elem.nodeType === 1 ) {
			attrNames = value.toLowerCase().split( rspace );
			l = attrNames.length;

			for ( ; i < l; i++ ) {
				name = attrNames[ i ];

				if ( name ) {
					propName = jQuery.propFix[ name ] || name;

					// See #9699 for explanation of this approach (setting first, then removal)
					jQuery.attr( elem, name, "" );
					elem.removeAttribute( getSetAttribute ? name : propName );

					// Set corresponding property to false for boolean attributes
					if ( rboolean.test( name ) && propName in elem ) {
						elem[ propName ] = false;
					}
				}
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				// We can't allow the type property to be changed (since it causes problems in IE)
				if ( rtype.test( elem.nodeName ) && elem.parentNode ) {
					jQuery.error( "type property can't be changed" );
				} else if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
					// Setting the type on a radio button after the value resets the value in IE6-9
					// Reset value to it's default in case type is set after value
					// This is for element creation
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		},
		// Use the value property for back compat
		// Use the nodeHook for button elements in IE6/7 (#1954)
		value: {
			get: function( elem, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.get( elem, name );
				}
				return name in elem ?
					elem.value :
					null;
			},
			set: function( elem, value, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.set( elem, value, name );
				}
				// Does not return so that setAttribute is also used
				elem.value = value;
			}
		}
	},

	propFix: {
		tabindex: "tabIndex",
		readonly: "readOnly",
		"for": "htmlFor",
		"class": "className",
		maxlength: "maxLength",
		cellspacing: "cellSpacing",
		cellpadding: "cellPadding",
		rowspan: "rowSpan",
		colspan: "colSpan",
		usemap: "useMap",
		frameborder: "frameBorder",
		contenteditable: "contentEditable"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				return ( elem[ name ] = value );
			}

		} else {
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
				return ret;

			} else {
				return elem[ name ];
			}
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				var attributeNode = elem.getAttributeNode("tabindex");

				return attributeNode && attributeNode.specified ?
					parseInt( attributeNode.value, 10 ) :
					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
						0 :
						undefined;
			}
		}
	}
});

// Add the tabIndex propHook to attrHooks for back-compat (different case is intentional)
jQuery.attrHooks.tabindex = jQuery.propHooks.tabIndex;

// Hook for boolean attributes
boolHook = {
	get: function( elem, name ) {
		// Align boolean attributes with corresponding properties
		// Fall back to attribute presence where some booleans are not supported
		var attrNode,
			property = jQuery.prop( elem, name );
		return property === true || typeof property !== "boolean" && ( attrNode = elem.getAttributeNode(name) ) && attrNode.nodeValue !== false ?
			name.toLowerCase() :
			undefined;
	},
	set: function( elem, value, name ) {
		var propName;
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			// value is true since we know at this point it's type boolean and not false
			// Set boolean attributes to the same name and set the DOM property
			propName = jQuery.propFix[ name ] || name;
			if ( propName in elem ) {
				// Only set the IDL specifically if it already exists on the element
				elem[ propName ] = true;
			}

			elem.setAttribute( name, name.toLowerCase() );
		}
		return name;
	}
};

// IE6/7 do not support getting/setting some attributes with get/setAttribute
if ( !getSetAttribute ) {

	fixSpecified = {
		name: true,
		id: true
	};

	// Use this for any attribute in IE6/7
	// This fixes almost every IE6/7 issue
	nodeHook = jQuery.valHooks.button = {
		get: function( elem, name ) {
			var ret;
			ret = elem.getAttributeNode( name );
			return ret && ( fixSpecified[ name ] ? ret.nodeValue !== "" : ret.specified ) ?
				ret.nodeValue :
				undefined;
		},
		set: function( elem, value, name ) {
			// Set the existing or create a new attribute node
			var ret = elem.getAttributeNode( name );
			if ( !ret ) {
				ret = document.createAttribute( name );
				elem.setAttributeNode( ret );
			}
			return ( ret.nodeValue = value + "" );
		}
	};

	// Apply the nodeHook to tabindex
	jQuery.attrHooks.tabindex.set = nodeHook.set;

	// Set width and height to auto instead of 0 on empty string( Bug #8150 )
	// This is for removals
	jQuery.each([ "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			set: function( elem, value ) {
				if ( value === "" ) {
					elem.setAttribute( name, "auto" );
					return value;
				}
			}
		});
	});

	// Set contenteditable to false on removals(#10429)
	// Setting to empty string throws an error as an invalid value
	jQuery.attrHooks.contenteditable = {
		get: nodeHook.get,
		set: function( elem, value, name ) {
			if ( value === "" ) {
				value = "false";
			}
			nodeHook.set( elem, value, name );
		}
	};
}


// Some attributes require a special call on IE
if ( !jQuery.support.hrefNormalized ) {
	jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			get: function( elem ) {
				var ret = elem.getAttribute( name, 2 );
				return ret === null ? undefined : ret;
			}
		});
	});
}

if ( !jQuery.support.style ) {
	jQuery.attrHooks.style = {
		get: function( elem ) {
			// Return undefined in the case of empty string
			// Normalize to lowercase since IE uppercases css property names
			return elem.style.cssText.toLowerCase() || undefined;
		},
		set: function( elem, value ) {
			return ( elem.style.cssText = "" + value );
		}
	};
}

// Safari mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
if ( !jQuery.support.optSelected ) {
	jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
		get: function( elem ) {
			var parent = elem.parentNode;

			if ( parent ) {
				parent.selectedIndex;

				// Make sure that it also works with optgroups, see #5701
				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
			return null;
		}
	});
}

// IE6/7 call enctype encoding
if ( !jQuery.support.enctype ) {
	jQuery.propFix.enctype = "encoding";
}

// Radios and checkboxes getter/setter
if ( !jQuery.support.checkOn ) {
	jQuery.each([ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			get: function( elem ) {
				// Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
				return elem.getAttribute("value") === null ? "on" : elem.value;
			}
		};
	});
}
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	});
});




var rformElems = /^(?:textarea|input|select)$/i,
	rtypenamespace = /^([^\.]*)?(?:\.(.+))?$/,
	rhoverHack = /\bhover(\.\S+)?\b/,
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rquickIs = /^(\w*)(?:#([\w\-]+))?(?:\.([\w\-]+))?$/,
	quickParse = function( selector ) {
		var quick = rquickIs.exec( selector );
		if ( quick ) {
			//   0  1    2   3
			// [ _, tag, id, class ]
			quick[1] = ( quick[1] || "" ).toLowerCase();
			quick[3] = quick[3] && new RegExp( "(?:^|\\s)" + quick[3] + "(?:\\s|$)" );
		}
		return quick;
	},
	quickIs = function( elem, m ) {
		var attrs = elem.attributes || {};
		return (
			(!m[1] || elem.nodeName.toLowerCase() === m[1]) &&
			(!m[2] || (attrs.id || {}).value === m[2]) &&
			(!m[3] || m[3].test( (attrs[ "class" ] || {}).value ))
		);
	},
	hoverHack = function( events ) {
		return jQuery.event.special.hover ? events : events.replace( rhoverHack, "mouseenter$1 mouseleave$1" );
	};

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	add: function( elem, types, handler, data, selector ) {

		var elemData, eventHandle, events,
			t, tns, type, namespaces, handleObj,
			handleObjIn, quick, handlers, special;

		// Don't attach events to noData or text/comment nodes (allow plain objects tho)
		if ( elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data( elem )) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		events = elemData.events;
		if ( !events ) {
			elemData.events = events = {};
		}
		eventHandle = elemData.handle;
		if ( !eventHandle ) {
			elemData.handle = eventHandle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
					undefined;
			};
			// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
			eventHandle.elem = elem;
		}

		// Handle multiple events separated by a space
		// jQuery(...).bind("mouseover mouseout", fn);
		types = jQuery.trim( hoverHack(types) ).split( " " );
		for ( t = 0; t < types.length; t++ ) {

			tns = rtypenamespace.exec( types[t] ) || [];
			type = tns[1];
			namespaces = ( tns[2] || "" ).split( "." ).sort();

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: tns[1],
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				quick: quickParse( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			handlers = events[ type ];
			if ( !handlers ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener/attachEvent if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					// Bind the global event handler to the element
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );

					} else if ( elem.attachEvent ) {
						elem.attachEvent( "on" + type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

		// Nullify elem to prevent memory leaks in IE
		elem = null;
	},

	global: {},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var elemData = jQuery.hasData( elem ) && jQuery._data( elem ),
			t, tns, type, origType, namespaces, origCount,
			j, events, special, handle, eventType, handleObj;

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = jQuery.trim( hoverHack( types || "" ) ).split(" ");
		for ( t = 0; t < types.length; t++ ) {
			tns = rtypenamespace.exec( types[t] ) || [];
			type = origType = tns[1];
			namespaces = tns[2];

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector? special.delegateType : special.bindType ) || type;
			eventType = events[ type ] || [];
			origCount = eventType.length;
			namespaces = namespaces ? new RegExp("(^|\\.)" + namespaces.split(".").sort().join("\\.(?:.*\\.)?") + "(\\.|$)") : null;

			// Remove matching events
			for ( j = 0; j < eventType.length; j++ ) {
				handleObj = eventType[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					 ( !handler || handler.guid === handleObj.guid ) &&
					 ( !namespaces || namespaces.test( handleObj.namespace ) ) &&
					 ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					eventType.splice( j--, 1 );

					if ( handleObj.selector ) {
						eventType.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( eventType.length === 0 && origCount !== eventType.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			handle = elemData.handle;
			if ( handle ) {
				handle.elem = null;
			}

			// removeData also checks for emptiness and clears the expando if empty
			// so use it instead of delete
			jQuery.removeData( elem, [ "events", "handle" ], true );
		}
	},

	// Events that are safe to short-circuit if no handlers are attached.
	// Native DOM events should not be added, they may have inline handlers.
	customEvent: {
		"getData": true,
		"setData": true,
		"changeData": true
	},

	trigger: function( event, data, elem, onlyHandlers ) {
		// Don't do events on text and comment nodes
		if ( elem && (elem.nodeType === 3 || elem.nodeType === 8) ) {
			return;
		}

		// Event object or event type
		var type = event.type || event,
			namespaces = [],
			cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType;

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "!" ) >= 0 ) {
			// Exclusive events trigger only for the exact event (no namespaces)
			type = type.slice(0, -1);
			exclusive = true;
		}

		if ( type.indexOf( "." ) >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}

		if ( (!elem || jQuery.event.customEvent[ type ]) && !jQuery.event.global[ type ] ) {
			// No jQuery handlers for this event type, and it can't have inline handlers
			return;
		}

		// Caller can pass in an Event, Object, or just an event type string
		event = typeof event === "object" ?
			// jQuery.Event object
			event[ jQuery.expando ] ? event :
			// Object literal
			new jQuery.Event( type, event ) :
			// Just the event type (string)
			new jQuery.Event( type );

		event.type = type;
		event.isTrigger = true;
		event.exclusive = exclusive;
		event.namespace = namespaces.join( "." );
		event.namespace_re = event.namespace? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.)?") + "(\\.|$)") : null;
		ontype = type.indexOf( ":" ) < 0 ? "on" + type : "";

		// Handle a global trigger
		if ( !elem ) {

			// TODO: Stop taunting the data cache; remove global events and always attach to document
			cache = jQuery.cache;
			for ( i in cache ) {
				if ( cache[ i ].events && cache[ i ].events[ type ] ) {
					jQuery.event.trigger( event, data, cache[ i ].handle.elem, true );
				}
			}
			return;
		}

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data != null ? jQuery.makeArray( data ) : [];
		data.unshift( event );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		eventPath = [[ elem, special.bindType || type ]];
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			cur = rfocusMorph.test( bubbleType + type ) ? elem : elem.parentNode;
			old = null;
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push([ cur, bubbleType ]);
				old = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( old && old === elem.ownerDocument ) {
				eventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);
			}
		}

		// Fire handlers on the event path
		for ( i = 0; i < eventPath.length && !event.isPropagationStopped(); i++ ) {

			cur = eventPath[i][0];
			event.type = eventPath[i][1];

			handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}
			// Note that this is a bare JS function and not a jQuery handler
			handle = ontype && cur[ ontype ];
			if ( handle && jQuery.acceptData( cur ) && handle.apply( cur, data ) === false ) {
				event.preventDefault();
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&
				!(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Can't use an .isFunction() check here because IE6/7 fails that test.
				// Don't do default actions on window, that's where global variables be (#6170)
				// IE<9 dies on focus/blur to hidden element (#1486)
				if ( ontype && elem[ type ] && ((type !== "focus" && type !== "blur") || event.target.offsetWidth !== 0) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					old = elem[ ontype ];

					if ( old ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( old ) {
						elem[ ontype ] = old;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event || window.event );

		var handlers = ( (jQuery._data( this, "events" ) || {} )[ event.type ] || []),
			delegateCount = handlers.delegateCount,
			args = [].slice.call( arguments, 0 ),
			run_all = !event.exclusive && !event.namespace,
			handlerQueue = [],
			i, j, cur, jqcur, ret, selMatch, matched, matches, handleObj, sel, related;

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Determine handlers that should run if there are delegated events
		// Avoid disabled elements in IE (#6911) and non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && !event.target.disabled && !(event.button && event.type === "click") ) {

			// Pregenerate a single jQuery object for reuse with .is()
			jqcur = jQuery(this);
			jqcur.context = this.ownerDocument || this;

			for ( cur = event.target; cur != this; cur = cur.parentNode || this ) {
				selMatch = {};
				matches = [];
				jqcur[0] = cur;
				for ( i = 0; i < delegateCount; i++ ) {
					handleObj = handlers[ i ];
					sel = handleObj.selector;

					if ( selMatch[ sel ] === undefined ) {
						selMatch[ sel ] = (
							handleObj.quick ? quickIs( cur, handleObj.quick ) : jqcur.is( sel )
						);
					}
					if ( selMatch[ sel ] ) {
						matches.push( handleObj );
					}
				}
				if ( matches.length ) {
					handlerQueue.push({ elem: cur, matches: matches });
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( handlers.length > delegateCount ) {
			handlerQueue.push({ elem: this, matches: handlers.slice( delegateCount ) });
		}

		// Run delegates first; they may want to stop propagation beneath us
		for ( i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++ ) {
			matched = handlerQueue[ i ];
			event.currentTarget = matched.elem;

			for ( j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++ ) {
				handleObj = matched.matches[ j ];

				// Triggered event must either 1) be non-exclusive and have no namespace, or
				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
				if ( run_all || (!event.namespace && !handleObj.namespace) || event.namespace_re && event.namespace_re.test( handleObj.namespace ) ) {

					event.data = handleObj.data;
					event.handleObj = handleObj;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						event.result = ret;
						if ( ret === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		return event.result;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	// *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***
	props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button,
				fromElement = original.fromElement;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add relatedTarget, if necessary
			if ( !event.relatedTarget && fromElement ) {
				event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop,
			originalEvent = event,
			fixHook = jQuery.event.fixHooks[ event.type ] || {},
			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = jQuery.Event( originalEvent );

		for ( i = copy.length; i; ) {
			prop = copy[ --i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Fix target property, if necessary (#1925, IE 6/7/8 & Safari2)
		if ( !event.target ) {
			event.target = originalEvent.srcElement || document;
		}

		// Target should not be a text node (#504, Safari)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		// For mouse/key events; add metaKey if it's not there (#3368, IE6/7/8)
		if ( event.metaKey === undefined ) {
			event.metaKey = event.ctrlKey;
		}

		return fixHook.filter? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		ready: {
			// Make sure the ready event is setup
			setup: jQuery.bindReady
		},

		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},

		focus: {
			delegateType: "focusin"
		},
		blur: {
			delegateType: "focusout"
		},

		beforeunload: {
			setup: function( data, namespaces, eventHandle ) {
				// We only want to do this special case on windows
				if ( jQuery.isWindow( this ) ) {
					this.onbeforeunload = eventHandle;
				}
			},

			teardown: function( namespaces, eventHandle ) {
				if ( this.onbeforeunload === eventHandle ) {
					this.onbeforeunload = null;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{ type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

// Some plugins are using, but it's undocumented/deprecated and will be removed.
// The 1.7 special event interface should provide all the hooks needed now.
jQuery.event.handle = jQuery.event.dispatch;

jQuery.removeEvent = document.removeEventListener ?
	function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	} :
	function( elem, type, handle ) {
		if ( elem.detachEvent ) {
			elem.detachEvent( "on" + type, handle );
		}
	};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
			src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

function returnFalse() {
	return false;
}
function returnTrue() {
	return true;
}

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	preventDefault: function() {
		this.isDefaultPrevented = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}

		// if preventDefault exists run it on the original event
		if ( e.preventDefault ) {
			e.preventDefault();

		// otherwise set the returnValue property of the original event to false (IE)
		} else {
			e.returnValue = false;
		}
	},
	stopPropagation: function() {
		this.isPropagationStopped = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}
		// if stopPropagation exists run it on the original event
		if ( e.stopPropagation ) {
			e.stopPropagation();
		}
		// otherwise set the cancelBubble property of the original event to true (IE)
		e.cancelBubble = true;
	},
	stopImmediatePropagation: function() {
		this.isImmediatePropagationStopped = returnTrue;
		this.stopPropagation();
	},
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse
};

// Create mouseenter/leave events using mouseover/out and event-time checks
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj,
				selector = handleObj.selector,
				ret;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// IE submit delegation
if ( !jQuery.support.submitBubbles ) {

	jQuery.event.special.submit = {
		setup: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Lazy-add a submit handler when a descendant form may potentially be submitted
			jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
				// Node name check avoids a VML-related crash in IE (#9807)
				var elem = e.target,
					form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
				if ( form && !form._submit_attached ) {
					jQuery.event.add( form, "submit._submit", function( event ) {
						// If form was submitted by the user, bubble the event up the tree
						if ( this.parentNode && !event.isTrigger ) {
							jQuery.event.simulate( "submit", this.parentNode, event, true );
						}
					});
					form._submit_attached = true;
				}
			});
			// return undefined since we don't need an event listener
		},

		teardown: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
			jQuery.event.remove( this, "._submit" );
		}
	};
}

// IE change delegation and checkbox/radio fix
if ( !jQuery.support.changeBubbles ) {

	jQuery.event.special.change = {

		setup: function() {

			if ( rformElems.test( this.nodeName ) ) {
				// IE doesn't fire change on a check/radio until blur; trigger it on click
				// after a propertychange. Eat the blur-change in special.change.handle.
				// This still fires onchange a second time for check/radio after blur.
				if ( this.type === "checkbox" || this.type === "radio" ) {
					jQuery.event.add( this, "propertychange._change", function( event ) {
						if ( event.originalEvent.propertyName === "checked" ) {
							this._just_changed = true;
						}
					});
					jQuery.event.add( this, "click._change", function( event ) {
						if ( this._just_changed && !event.isTrigger ) {
							this._just_changed = false;
							jQuery.event.simulate( "change", this, event, true );
						}
					});
				}
				return false;
			}
			// Delegated event; lazy-add a change handler on descendant inputs
			jQuery.event.add( this, "beforeactivate._change", function( e ) {
				var elem = e.target;

				if ( rformElems.test( elem.nodeName ) && !elem._change_attached ) {
					jQuery.event.add( elem, "change._change", function( event ) {
						if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
							jQuery.event.simulate( "change", this.parentNode, event, true );
						}
					});
					elem._change_attached = true;
				}
			});
		},

		handle: function( event ) {
			var elem = event.target;

			// Swallow native change events from checkbox/radio, we already triggered them above
			if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
				return event.handleObj.handler.apply( this, arguments );
			}
		},

		teardown: function() {
			jQuery.event.remove( this, "._change" );

			return rformElems.test( this.nodeName );
		}
	};
}

// Create "bubbling" focus and blur events
if ( !jQuery.support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler while someone wants focusin/focusout
		var attaches = 0,
			handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				if ( attaches++ === 0 ) {
					document.addEventListener( orig, handler, true );
				}
			},
			teardown: function() {
				if ( --attaches === 0 ) {
					document.removeEventListener( orig, handler, true );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on.call( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			var handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace? handleObj.type + "." + handleObj.namespace : handleObj.type,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( var type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	live: function( types, data, fn ) {
		jQuery( this.context ).on( types, this.selector, data, fn );
		return this;
	},
	die: function( types, fn ) {
		jQuery( this.context ).off( types, this.selector || "**", fn );
		return this;
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length == 1? this.off( selector, "**" ) : this.off( types, selector, fn );
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		if ( this[0] ) {
			return jQuery.event.trigger( type, data, this[0], true );
		}
	},

	toggle: function( fn ) {
		// Save reference to arguments for access in closure
		var args = arguments,
			guid = fn.guid || jQuery.guid++,
			i = 0,
			toggler = function( event ) {
				// Figure out which function to execute
				var lastToggle = ( jQuery._data( this, "lastToggle" + fn.guid ) || 0 ) % i;
				jQuery._data( this, "lastToggle" + fn.guid, lastToggle + 1 );

				// Make sure that clicks stop
				event.preventDefault();

				// and execute the function
				return args[ lastToggle ].apply( this, arguments ) || false;
			};

		// link all the functions, so any of them can unbind this click handler
		toggler.guid = guid;
		while ( i < args.length ) {
			args[ i++ ].guid = guid;
		}

		return this.click( toggler );
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
});

jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		if ( fn == null ) {
			fn = data;
			data = null;
		}

		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};

	if ( jQuery.attrFn ) {
		jQuery.attrFn[ name ] = true;
	}

	if ( rkeyEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.keyHooks;
	}

	if ( rmouseEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.mouseHooks;
	}
});



/*!
 * Sizzle CSS Selector Engine
 *  Copyright 2011, The Dojo Foundation
 *  Released under the MIT, BSD, and GPL Licenses.
 *  More information: http://sizzlejs.com/
 */
(function(){

var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
	expando = "sizcache" + (Math.random() + '').replace('.', ''),
	done = 0,
	toString = Object.prototype.toString,
	hasDuplicate = false,
	baseHasDuplicate = true,
	rBackslash = /\\/g,
	rReturn = /\r\n/g,
	rNonWord = /\W/;

// Here we check if the JavaScript engine is using some sort of
// optimization where it does not always call our comparision
// function. If that is the case, discard the hasDuplicate value.
//   Thus far that includes Google Chrome.
[0, 0].sort(function() {
	baseHasDuplicate = false;
	return 0;
});

var Sizzle = function( selector, context, results, seed ) {
	results = results || [];
	context = context || document;

	var origContext = context;

	if ( context.nodeType !== 1 && context.nodeType !== 9 ) {
		return [];
	}
	
	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	var m, set, checkSet, extra, ret, cur, pop, i,
		prune = true,
		contextXML = Sizzle.isXML( context ),
		parts = [],
		soFar = selector;
	
	// Reset the position of the chunker regexp (start from head)
	do {
		chunker.exec( "" );
		m = chunker.exec( soFar );

		if ( m ) {
			soFar = m[3];
		
			parts.push( m[1] );
		
			if ( m[2] ) {
				extra = m[3];
				break;
			}
		}
	} while ( m );

	if ( parts.length > 1 && origPOS.exec( selector ) ) {

		if ( parts.length === 2 && Expr.relative[ parts[0] ] ) {
			set = posProcess( parts[0] + parts[1], context, seed );

		} else {
			set = Expr.relative[ parts[0] ] ?
				[ context ] :
				Sizzle( parts.shift(), context );

			while ( parts.length ) {
				selector = parts.shift();

				if ( Expr.relative[ selector ] ) {
					selector += parts.shift();
				}
				
				set = posProcess( selector, set, seed );
			}
		}

	} else {
		// Take a shortcut and set the context if the root selector is an ID
		// (but not if it'll be faster if the inner selector is an ID)
		if ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
				Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {

			ret = Sizzle.find( parts.shift(), context, contextXML );
			context = ret.expr ?
				Sizzle.filter( ret.expr, ret.set )[0] :
				ret.set[0];
		}

		if ( context ) {
			ret = seed ?
				{ expr: parts.pop(), set: makeArray(seed) } :
				Sizzle.find( parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML );

			set = ret.expr ?
				Sizzle.filter( ret.expr, ret.set ) :
				ret.set;

			if ( parts.length > 0 ) {
				checkSet = makeArray( set );

			} else {
				prune = false;
			}

			while ( parts.length ) {
				cur = parts.pop();
				pop = cur;

				if ( !Expr.relative[ cur ] ) {
					cur = "";
				} else {
					pop = parts.pop();
				}

				if ( pop == null ) {
					pop = context;
				}

				Expr.relative[ cur ]( checkSet, pop, contextXML );
			}

		} else {
			checkSet = parts = [];
		}
	}

	if ( !checkSet ) {
		checkSet = set;
	}

	if ( !checkSet ) {
		Sizzle.error( cur || selector );
	}

	if ( toString.call(checkSet) === "[object Array]" ) {
		if ( !prune ) {
			results.push.apply( results, checkSet );

		} else if ( context && context.nodeType === 1 ) {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i])) ) {
					results.push( set[i] );
				}
			}

		} else {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && checkSet[i].nodeType === 1 ) {
					results.push( set[i] );
				}
			}
		}

	} else {
		makeArray( checkSet, results );
	}

	if ( extra ) {
		Sizzle( extra, origContext, results, seed );
		Sizzle.uniqueSort( results );
	}

	return results;
};

Sizzle.uniqueSort = function( results ) {
	if ( sortOrder ) {
		hasDuplicate = baseHasDuplicate;
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			for ( var i = 1; i < results.length; i++ ) {
				if ( results[i] === results[ i - 1 ] ) {
					results.splice( i--, 1 );
				}
			}
		}
	}

	return results;
};

Sizzle.matches = function( expr, set ) {
	return Sizzle( expr, null, null, set );
};

Sizzle.matchesSelector = function( node, expr ) {
	return Sizzle( expr, null, null, [node] ).length > 0;
};

Sizzle.find = function( expr, context, isXML ) {
	var set, i, len, match, type, left;

	if ( !expr ) {
		return [];
	}

	for ( i = 0, len = Expr.order.length; i < len; i++ ) {
		type = Expr.order[i];
		
		if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {
			left = match[1];
			match.splice( 1, 1 );

			if ( left.substr( left.length - 1 ) !== "\\" ) {
				match[1] = (match[1] || "").replace( rBackslash, "" );
				set = Expr.find[ type ]( match, context, isXML );

				if ( set != null ) {
					expr = expr.replace( Expr.match[ type ], "" );
					break;
				}
			}
		}
	}

	if ( !set ) {
		set = typeof context.getElementsByTagName !== "undefined" ?
			context.getElementsByTagName( "*" ) :
			[];
	}

	return { set: set, expr: expr };
};

Sizzle.filter = function( expr, set, inplace, not ) {
	var match, anyFound,
		type, found, item, filter, left,
		i, pass,
		old = expr,
		result = [],
		curLoop = set,
		isXMLFilter = set && set[0] && Sizzle.isXML( set[0] );

	while ( expr && set.length ) {
		for ( type in Expr.filter ) {
			if ( (match = Expr.leftMatch[ type ].exec( expr )) != null && match[2] ) {
				filter = Expr.filter[ type ];
				left = match[1];

				anyFound = false;

				match.splice(1,1);

				if ( left.substr( left.length - 1 ) === "\\" ) {
					continue;
				}

				if ( curLoop === result ) {
					result = [];
				}

				if ( Expr.preFilter[ type ] ) {
					match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );

					if ( !match ) {
						anyFound = found = true;

					} else if ( match === true ) {
						continue;
					}
				}

				if ( match ) {
					for ( i = 0; (item = curLoop[i]) != null; i++ ) {
						if ( item ) {
							found = filter( item, match, i, curLoop );
							pass = not ^ found;

							if ( inplace && found != null ) {
								if ( pass ) {
									anyFound = true;

								} else {
									curLoop[i] = false;
								}

							} else if ( pass ) {
								result.push( item );
								anyFound = true;
							}
						}
					}
				}

				if ( found !== undefined ) {
					if ( !inplace ) {
						curLoop = result;
					}

					expr = expr.replace( Expr.match[ type ], "" );

					if ( !anyFound ) {
						return [];
					}

					break;
				}
			}
		}

		// Improper expression
		if ( expr === old ) {
			if ( anyFound == null ) {
				Sizzle.error( expr );

			} else {
				break;
			}
		}

		old = expr;
	}

	return curLoop;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Utility function for retreiving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
var getText = Sizzle.getText = function( elem ) {
    var i, node,
		nodeType = elem.nodeType,
		ret = "";

	if ( nodeType ) {
		if ( nodeType === 1 || nodeType === 9 ) {
			// Use textContent || innerText for elements
			if ( typeof elem.textContent === 'string' ) {
				return elem.textContent;
			} else if ( typeof elem.innerText === 'string' ) {
				// Replace IE's carriage returns
				return elem.innerText.replace( rReturn, '' );
			} else {
				// Traverse it's children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
	} else {

		// If no nodeType, this is expected to be an array
		for ( i = 0; (node = elem[i]); i++ ) {
			// Do not traverse comment nodes
			if ( node.nodeType !== 8 ) {
				ret += getText( node );
			}
		}
	}
	return ret;
};

var Expr = Sizzle.selectors = {
	order: [ "ID", "NAME", "TAG" ],

	match: {
		ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
		ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
		TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
		CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
		POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
		PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
	},

	leftMatch: {},

	attrMap: {
		"class": "className",
		"for": "htmlFor"
	},

	attrHandle: {
		href: function( elem ) {
			return elem.getAttribute( "href" );
		},
		type: function( elem ) {
			return elem.getAttribute( "type" );
		}
	},

	relative: {
		"+": function(checkSet, part){
			var isPartStr = typeof part === "string",
				isTag = isPartStr && !rNonWord.test( part ),
				isPartStrNotTag = isPartStr && !isTag;

			if ( isTag ) {
				part = part.toLowerCase();
			}

			for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {
				if ( (elem = checkSet[i]) ) {
					while ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}

					checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
						elem || false :
						elem === part;
				}
			}

			if ( isPartStrNotTag ) {
				Sizzle.filter( part, checkSet, true );
			}
		},

		">": function( checkSet, part ) {
			var elem,
				isPartStr = typeof part === "string",
				i = 0,
				l = checkSet.length;

			if ( isPartStr && !rNonWord.test( part ) ) {
				part = part.toLowerCase();

				for ( ; i < l; i++ ) {
					elem = checkSet[i];

					if ( elem ) {
						var parent = elem.parentNode;
						checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
					}
				}

			} else {
				for ( ; i < l; i++ ) {
					elem = checkSet[i];

					if ( elem ) {
						checkSet[i] = isPartStr ?
							elem.parentNode :
							elem.parentNode === part;
					}
				}

				if ( isPartStr ) {
					Sizzle.filter( part, checkSet, true );
				}
			}
		},

		"": function(checkSet, part, isXML){
			var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

			if ( typeof part === "string" && !rNonWord.test( part ) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn( "parentNode", part, doneName, checkSet, nodeCheck, isXML );
		},

		"~": function( checkSet, part, isXML ) {
			var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

			if ( typeof part === "string" && !rNonWord.test( part ) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn( "previousSibling", part, doneName, checkSet, nodeCheck, isXML );
		}
	},

	find: {
		ID: function( match, context, isXML ) {
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [m] : [];
			}
		},

		NAME: function( match, context ) {
			if ( typeof context.getElementsByName !== "undefined" ) {
				var ret = [],
					results = context.getElementsByName( match[1] );

				for ( var i = 0, l = results.length; i < l; i++ ) {
					if ( results[i].getAttribute("name") === match[1] ) {
						ret.push( results[i] );
					}
				}

				return ret.length === 0 ? null : ret;
			}
		},

		TAG: function( match, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( match[1] );
			}
		}
	},
	preFilter: {
		CLASS: function( match, curLoop, inplace, result, not, isXML ) {
			match = " " + match[1].replace( rBackslash, "" ) + " ";

			if ( isXML ) {
				return match;
			}

			for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {
				if ( elem ) {
					if ( not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n\r]/g, " ").indexOf(match) >= 0) ) {
						if ( !inplace ) {
							result.push( elem );
						}

					} else if ( inplace ) {
						curLoop[i] = false;
					}
				}
			}

			return false;
		},

		ID: function( match ) {
			return match[1].replace( rBackslash, "" );
		},

		TAG: function( match, curLoop ) {
			return match[1].replace( rBackslash, "" ).toLowerCase();
		},

		CHILD: function( match ) {
			if ( match[1] === "nth" ) {
				if ( !match[2] ) {
					Sizzle.error( match[0] );
				}

				match[2] = match[2].replace(/^\+|\s*/g, '');

				// parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
				var test = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(
					match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
					!/\D/.test( match[2] ) && "0n+" + match[2] || match[2]);

				// calculate the numbers (first)n+(last) including if they are negative
				match[2] = (test[1] + (test[2] || 1)) - 0;
				match[3] = test[3] - 0;
			}
			else if ( match[2] ) {
				Sizzle.error( match[0] );
			}

			// TODO: Move to normal caching system
			match[0] = done++;

			return match;
		},

		ATTR: function( match, curLoop, inplace, result, not, isXML ) {
			var name = match[1] = match[1].replace( rBackslash, "" );
			
			if ( !isXML && Expr.attrMap[name] ) {
				match[1] = Expr.attrMap[name];
			}

			// Handle if an un-quoted value was used
			match[4] = ( match[4] || match[5] || "" ).replace( rBackslash, "" );

			if ( match[2] === "~=" ) {
				match[4] = " " + match[4] + " ";
			}

			return match;
		},

		PSEUDO: function( match, curLoop, inplace, result, not ) {
			if ( match[1] === "not" ) {
				// If we're dealing with a complex expression, or a simple one
				if ( ( chunker.exec(match[3]) || "" ).length > 1 || /^\w/.test(match[3]) ) {
					match[3] = Sizzle(match[3], null, null, curLoop);

				} else {
					var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);

					if ( !inplace ) {
						result.push.apply( result, ret );
					}

					return false;
				}

			} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {
				return true;
			}
			
			return match;
		},

		POS: function( match ) {
			match.unshift( true );

			return match;
		}
	},
	
	filters: {
		enabled: function( elem ) {
			return elem.disabled === false && elem.type !== "hidden";
		},

		disabled: function( elem ) {
			return elem.disabled === true;
		},

		checked: function( elem ) {
			return elem.checked === true;
		},
		
		selected: function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}
			
			return elem.selected === true;
		},

		parent: function( elem ) {
			return !!elem.firstChild;
		},

		empty: function( elem ) {
			return !elem.firstChild;
		},

		has: function( elem, i, match ) {
			return !!Sizzle( match[3], elem ).length;
		},

		header: function( elem ) {
			return (/h\d/i).test( elem.nodeName );
		},

		text: function( elem ) {
			var attr = elem.getAttribute( "type" ), type = elem.type;
			// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc) 
			// use getAttribute instead to test this case
			return elem.nodeName.toLowerCase() === "input" && "text" === type && ( attr === type || attr === null );
		},

		radio: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "radio" === elem.type;
		},

		checkbox: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "checkbox" === elem.type;
		},

		file: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "file" === elem.type;
		},

		password: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "password" === elem.type;
		},

		submit: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && "submit" === elem.type;
		},

		image: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "image" === elem.type;
		},

		reset: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && "reset" === elem.type;
		},

		button: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && "button" === elem.type || name === "button";
		},

		input: function( elem ) {
			return (/input|select|textarea|button/i).test( elem.nodeName );
		},

		focus: function( elem ) {
			return elem === elem.ownerDocument.activeElement;
		}
	},
	setFilters: {
		first: function( elem, i ) {
			return i === 0;
		},

		last: function( elem, i, match, array ) {
			return i === array.length - 1;
		},

		even: function( elem, i ) {
			return i % 2 === 0;
		},

		odd: function( elem, i ) {
			return i % 2 === 1;
		},

		lt: function( elem, i, match ) {
			return i < match[3] - 0;
		},

		gt: function( elem, i, match ) {
			return i > match[3] - 0;
		},

		nth: function( elem, i, match ) {
			return match[3] - 0 === i;
		},

		eq: function( elem, i, match ) {
			return match[3] - 0 === i;
		}
	},
	filter: {
		PSEUDO: function( elem, match, i, array ) {
			var name = match[1],
				filter = Expr.filters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );

			} else if ( name === "contains" ) {
				return (elem.textContent || elem.innerText || getText([ elem ]) || "").indexOf(match[3]) >= 0;

			} else if ( name === "not" ) {
				var not = match[3];

				for ( var j = 0, l = not.length; j < l; j++ ) {
					if ( not[j] === elem ) {
						return false;
					}
				}

				return true;

			} else {
				Sizzle.error( name );
			}
		},

		CHILD: function( elem, match ) {
			var first, last,
				doneName, parent, cache,
				count, diff,
				type = match[1],
				node = elem;

			switch ( type ) {
				case "only":
				case "first":
					while ( (node = node.previousSibling) )	 {
						if ( node.nodeType === 1 ) { 
							return false; 
						}
					}

					if ( type === "first" ) { 
						return true; 
					}

					node = elem;

				case "last":
					while ( (node = node.nextSibling) )	 {
						if ( node.nodeType === 1 ) { 
							return false; 
						}
					}

					return true;

				case "nth":
					first = match[2];
					last = match[3];

					if ( first === 1 && last === 0 ) {
						return true;
					}
					
					doneName = match[0];
					parent = elem.parentNode;
	
					if ( parent && (parent[ expando ] !== doneName || !elem.nodeIndex) ) {
						count = 0;
						
						for ( node = parent.firstChild; node; node = node.nextSibling ) {
							if ( node.nodeType === 1 ) {
								node.nodeIndex = ++count;
							}
						} 

						parent[ expando ] = doneName;
					}
					
					diff = elem.nodeIndex - last;

					if ( first === 0 ) {
						return diff === 0;

					} else {
						return ( diff % first === 0 && diff / first >= 0 );
					}
			}
		},

		ID: function( elem, match ) {
			return elem.nodeType === 1 && elem.getAttribute("id") === match;
		},

		TAG: function( elem, match ) {
			return (match === "*" && elem.nodeType === 1) || !!elem.nodeName && elem.nodeName.toLowerCase() === match;
		},
		
		CLASS: function( elem, match ) {
			return (" " + (elem.className || elem.getAttribute("class")) + " ")
				.indexOf( match ) > -1;
		},

		ATTR: function( elem, match ) {
			var name = match[1],
				result = Sizzle.attr ?
					Sizzle.attr( elem, name ) :
					Expr.attrHandle[ name ] ?
					Expr.attrHandle[ name ]( elem ) :
					elem[ name ] != null ?
						elem[ name ] :
						elem.getAttribute( name ),
				value = result + "",
				type = match[2],
				check = match[4];

			return result == null ?
				type === "!=" :
				!type && Sizzle.attr ?
				result != null :
				type === "=" ?
				value === check :
				type === "*=" ?
				value.indexOf(check) >= 0 :
				type === "~=" ?
				(" " + value + " ").indexOf(check) >= 0 :
				!check ?
				value && result !== false :
				type === "!=" ?
				value !== check :
				type === "^=" ?
				value.indexOf(check) === 0 :
				type === "$=" ?
				value.substr(value.length - check.length) === check :
				type === "|=" ?
				value === check || value.substr(0, check.length + 1) === check + "-" :
				false;
		},

		POS: function( elem, match, i, array ) {
			var name = match[2],
				filter = Expr.setFilters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );
			}
		}
	}
};

var origPOS = Expr.match.POS,
	fescape = function(all, num){
		return "\\" + (num - 0 + 1);
	};

for ( var type in Expr.match ) {
	Expr.match[ type ] = new RegExp( Expr.match[ type ].source + (/(?![^\[]*\])(?![^\(]*\))/.source) );
	Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\r|\n)*?)/.source + Expr.match[ type ].source.replace(/\\(\d+)/g, fescape) );
}

var makeArray = function( array, results ) {
	array = Array.prototype.slice.call( array, 0 );

	if ( results ) {
		results.push.apply( results, array );
		return results;
	}
	
	return array;
};

// Perform a simple check to determine if the browser is capable of
// converting a NodeList to an array using builtin methods.
// Also verifies that the returned array holds DOM nodes
// (which is not the case in the Blackberry browser)
try {
	Array.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;

// Provide a fallback method if it does not work
} catch( e ) {
	makeArray = function( array, results ) {
		var i = 0,
			ret = results || [];

		if ( toString.call(array) === "[object Array]" ) {
			Array.prototype.push.apply( ret, array );

		} else {
			if ( typeof array.length === "number" ) {
				for ( var l = array.length; i < l; i++ ) {
					ret.push( array[i] );
				}

			} else {
				for ( ; array[i]; i++ ) {
					ret.push( array[i] );
				}
			}
		}

		return ret;
	};
}

var sortOrder, siblingCheck;

if ( document.documentElement.compareDocumentPosition ) {
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {
			return a.compareDocumentPosition ? -1 : 1;
		}

		return a.compareDocumentPosition(b) & 4 ? -1 : 1;
	};

} else {
	sortOrder = function( a, b ) {
		// The nodes are identical, we can exit early
		if ( a === b ) {
			hasDuplicate = true;
			return 0;

		// Fallback to using sourceIndex (in IE) if it's available on both nodes
		} else if ( a.sourceIndex && b.sourceIndex ) {
			return a.sourceIndex - b.sourceIndex;
		}

		var al, bl,
			ap = [],
			bp = [],
			aup = a.parentNode,
			bup = b.parentNode,
			cur = aup;

		// If the nodes are siblings (or identical) we can do a quick check
		if ( aup === bup ) {
			return siblingCheck( a, b );

		// If no parents were found then the nodes are disconnected
		} else if ( !aup ) {
			return -1;

		} else if ( !bup ) {
			return 1;
		}

		// Otherwise they're somewhere else in the tree so we need
		// to build up a full list of the parentNodes for comparison
		while ( cur ) {
			ap.unshift( cur );
			cur = cur.parentNode;
		}

		cur = bup;

		while ( cur ) {
			bp.unshift( cur );
			cur = cur.parentNode;
		}

		al = ap.length;
		bl = bp.length;

		// Start walking down the tree looking for a discrepancy
		for ( var i = 0; i < al && i < bl; i++ ) {
			if ( ap[i] !== bp[i] ) {
				return siblingCheck( ap[i], bp[i] );
			}
		}

		// We ended someplace up the tree so do a sibling check
		return i === al ?
			siblingCheck( a, bp[i], -1 ) :
			siblingCheck( ap[i], b, 1 );
	};

	siblingCheck = function( a, b, ret ) {
		if ( a === b ) {
			return ret;
		}

		var cur = a.nextSibling;

		while ( cur ) {
			if ( cur === b ) {
				return -1;
			}

			cur = cur.nextSibling;
		}

		return 1;
	};
}

// Check to see if the browser returns elements by name when
// querying by getElementById (and provide a workaround)
(function(){
	// We're going to inject a fake input element with a specified name
	var form = document.createElement("div"),
		id = "script" + (new Date()).getTime(),
		root = document.documentElement;

	form.innerHTML = "<a name='" + id + "'/>";

	// Inject it into the root element, check its status, and remove it quickly
	root.insertBefore( form, root.firstChild );

	// The workaround has to do additional checks after a getElementById
	// Which slows things down for other browsers (hence the branching)
	if ( document.getElementById( id ) ) {
		Expr.find.ID = function( match, context, isXML ) {
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);

				return m ?
					m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ?
						[m] :
						undefined :
					[];
			}
		};

		Expr.filter.ID = function( elem, match ) {
			var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");

			return elem.nodeType === 1 && node && node.nodeValue === match;
		};
	}

	root.removeChild( form );

	// release memory in IE
	root = form = null;
})();

(function(){
	// Check to see if the browser returns only elements
	// when doing getElementsByTagName("*")

	// Create a fake element
	var div = document.createElement("div");
	div.appendChild( document.createComment("") );

	// Make sure no comments are found
	if ( div.getElementsByTagName("*").length > 0 ) {
		Expr.find.TAG = function( match, context ) {
			var results = context.getElementsByTagName( match[1] );

			// Filter out possible comments
			if ( match[1] === "*" ) {
				var tmp = [];

				for ( var i = 0; results[i]; i++ ) {
					if ( results[i].nodeType === 1 ) {
						tmp.push( results[i] );
					}
				}

				results = tmp;
			}

			return results;
		};
	}

	// Check to see if an attribute returns normalized href attributes
	div.innerHTML = "<a href='#'></a>";

	if ( div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
			div.firstChild.getAttribute("href") !== "#" ) {

		Expr.attrHandle.href = function( elem ) {
			return elem.getAttribute( "href", 2 );
		};
	}

	// release memory in IE
	div = null;
})();

if ( document.querySelectorAll ) {
	(function(){
		var oldSizzle = Sizzle,
			div = document.createElement("div"),
			id = "__sizzle__";

		div.innerHTML = "<p class='TEST'></p>";

		// Safari can't handle uppercase or unicode characters when
		// in quirks mode.
		if ( div.querySelectorAll && div.querySelectorAll(".TEST").length === 0 ) {
			return;
		}
	
		Sizzle = function( query, context, extra, seed ) {
			context = context || document;

			// Only use querySelectorAll on non-XML documents
			// (ID selectors don't work in non-HTML documents)
			if ( !seed && !Sizzle.isXML(context) ) {
				// See if we find a selector to speed up
				var match = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec( query );
				
				if ( match && (context.nodeType === 1 || context.nodeType === 9) ) {
					// Speed-up: Sizzle("TAG")
					if ( match[1] ) {
						return makeArray( context.getElementsByTagName( query ), extra );
					
					// Speed-up: Sizzle(".CLASS")
					} else if ( match[2] && Expr.find.CLASS && context.getElementsByClassName ) {
						return makeArray( context.getElementsByClassName( match[2] ), extra );
					}
				}
				
				if ( context.nodeType === 9 ) {
					// Speed-up: Sizzle("body")
					// The body element only exists once, optimize finding it
					if ( query === "body" && context.body ) {
						return makeArray( [ context.body ], extra );
						
					// Speed-up: Sizzle("#ID")
					} else if ( match && match[3] ) {
						var elem = context.getElementById( match[3] );

						// Check parentNode to catch when Blackberry 4.6 returns
						// nodes that are no longer in the document #6963
						if ( elem && elem.parentNode ) {
							// Handle the case where IE and Opera return items
							// by name instead of ID
							if ( elem.id === match[3] ) {
								return makeArray( [ elem ], extra );
							}
							
						} else {
							return makeArray( [], extra );
						}
					}
					
					try {
						return makeArray( context.querySelectorAll(query), extra );
					} catch(qsaError) {}

				// qSA works strangely on Element-rooted queries
				// We can work around this by specifying an extra ID on the root
				// and working up from there (Thanks to Andrew Dupont for the technique)
				// IE 8 doesn't work on object elements
				} else if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
					var oldContext = context,
						old = context.getAttribute( "id" ),
						nid = old || id,
						hasParent = context.parentNode,
						relativeHierarchySelector = /^\s*[+~]/.test( query );

					if ( !old ) {
						context.setAttribute( "id", nid );
					} else {
						nid = nid.replace( /'/g, "\\$&" );
					}
					if ( relativeHierarchySelector && hasParent ) {
						context = context.parentNode;
					}

					try {
						if ( !relativeHierarchySelector || hasParent ) {
							return makeArray( context.querySelectorAll( "[id='" + nid + "'] " + query ), extra );
						}

					} catch(pseudoError) {
					} finally {
						if ( !old ) {
							oldContext.removeAttribute( "id" );
						}
					}
				}
			}
		
			return oldSizzle(query, context, extra, seed);
		};

		for ( var prop in oldSizzle ) {
			Sizzle[ prop ] = oldSizzle[ prop ];
		}

		// release memory in IE
		div = null;
	})();
}

(function(){
	var html = document.documentElement,
		matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;

	if ( matches ) {
		// Check to see if it's possible to do matchesSelector
		// on a disconnected node (IE 9 fails this)
		var disconnectedMatch = !matches.call( document.createElement( "div" ), "div" ),
			pseudoWorks = false;

		try {
			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( document.documentElement, "[test!='']:sizzle" );
	
		} catch( pseudoError ) {
			pseudoWorks = true;
		}

		Sizzle.matchesSelector = function( node, expr ) {
			// Make sure that attribute selectors are quoted
			expr = expr.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");

			if ( !Sizzle.isXML( node ) ) {
				try { 
					if ( pseudoWorks || !Expr.match.PSEUDO.test( expr ) && !/!=/.test( expr ) ) {
						var ret = matches.call( node, expr );

						// IE 9's matchesSelector returns false on disconnected nodes
						if ( ret || !disconnectedMatch ||
								// As well, disconnected nodes are said to be in a document
								// fragment in IE 9, so check for that
								node.document && node.document.nodeType !== 11 ) {
							return ret;
						}
					}
				} catch(e) {}
			}

			return Sizzle(expr, null, null, [node]).length > 0;
		};
	}
})();

(function(){
	var div = document.createElement("div");

	div.innerHTML = "<div class='test e'></div><div class='test'></div>";

	// Opera can't find a second classname (in 9.6)
	// Also, make sure that getElementsByClassName actually exists
	if ( !div.getElementsByClassName || div.getElementsByClassName("e").length === 0 ) {
		return;
	}

	// Safari caches class attributes, doesn't catch changes (in 3.2)
	div.lastChild.className = "e";

	if ( div.getElementsByClassName("e").length === 1 ) {
		return;
	}
	
	Expr.order.splice(1, 0, "CLASS");
	Expr.find.CLASS = function( match, context, isXML ) {
		if ( typeof context.getElementsByClassName !== "undefined" && !isXML ) {
			return context.getElementsByClassName(match[1]);
		}
	};

	// release memory in IE
	div = null;
})();

function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];

		if ( elem ) {
			var match = false;

			elem = elem[dir];

			while ( elem ) {
				if ( elem[ expando ] === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 && !isXML ){
					elem[ expando ] = doneName;
					elem.sizset = i;
				}

				if ( elem.nodeName.toLowerCase() === cur ) {
					match = elem;
					break;
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];

		if ( elem ) {
			var match = false;
			
			elem = elem[dir];

			while ( elem ) {
				if ( elem[ expando ] === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 ) {
					if ( !isXML ) {
						elem[ expando ] = doneName;
						elem.sizset = i;
					}

					if ( typeof cur !== "string" ) {
						if ( elem === cur ) {
							match = true;
							break;
						}

					} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {
						match = elem;
						break;
					}
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

if ( document.documentElement.contains ) {
	Sizzle.contains = function( a, b ) {
		return a !== b && (a.contains ? a.contains(b) : true);
	};

} else if ( document.documentElement.compareDocumentPosition ) {
	Sizzle.contains = function( a, b ) {
		return !!(a.compareDocumentPosition(b) & 16);
	};

} else {
	Sizzle.contains = function() {
		return false;
	};
}

Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833) 
	var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;

	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

var posProcess = function( selector, context, seed ) {
	var match,
		tmpSet = [],
		later = "",
		root = context.nodeType ? [context] : context;

	// Position selectors must be done after the filter
	// And so must :not(positional) so we move all PSEUDOs to the end
	while ( (match = Expr.match.PSEUDO.exec( selector )) ) {
		later += match[0];
		selector = selector.replace( Expr.match.PSEUDO, "" );
	}

	selector = Expr.relative[selector] ? selector + "*" : selector;

	for ( var i = 0, l = root.length; i < l; i++ ) {
		Sizzle( selector, root[i], tmpSet, seed );
	}

	return Sizzle.filter( later, tmpSet );
};

// EXPOSE
// Override sizzle attribute retrieval
Sizzle.attr = jQuery.attr;
Sizzle.selectors.attrMap = {};
jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.filters;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;


})();


var runtil = /Until$/,
	rparentsprev = /^(?:parents|prevUntil|prevAll)/,
	// Note: This RegExp should be improved, or likely pulled from Sizzle
	rmultiselector = /,/,
	isSimple = /^.[^:#\[\.,]*$/,
	slice = Array.prototype.slice,
	POS = jQuery.expr.match.POS,
	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend({
	find: function( selector ) {
		var self = this,
			i, l;

		if ( typeof selector !== "string" ) {
			return jQuery( selector ).filter(function() {
				for ( i = 0, l = self.length; i < l; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			});
		}

		var ret = this.pushStack( "", "find", selector ),
			length, n, r;

		for ( i = 0, l = this.length; i < l; i++ ) {
			length = ret.length;
			jQuery.find( selector, this[i], ret );

			if ( i > 0 ) {
				// Make sure that the results are unique
				for ( n = length; n < ret.length; n++ ) {
					for ( r = 0; r < length; r++ ) {
						if ( ret[r] === ret[n] ) {
							ret.splice(n--, 1);
							break;
						}
					}
				}
			}
		}

		return ret;
	},

	has: function( target ) {
		var targets = jQuery( target );
		return this.filter(function() {
			for ( var i = 0, l = targets.length; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	not: function( selector ) {
		return this.pushStack( winnow(this, selector, false), "not", selector);
	},

	filter: function( selector ) {
		return this.pushStack( winnow(this, selector, true), "filter", selector );
	},

	is: function( selector ) {
		return !!selector && ( 
			typeof selector === "string" ?
				// If this is a positional selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				POS.test( selector ) ? 
					jQuery( selector, this.context ).index( this[0] ) >= 0 :
					jQuery.filter( selector, this ).length > 0 :
				this.filter( selector ).length > 0 );
	},

	closest: function( selectors, context ) {
		var ret = [], i, l, cur = this[0];
		
		// Array (deprecated as of jQuery 1.7)
		if ( jQuery.isArray( selectors ) ) {
			var level = 1;

			while ( cur && cur.ownerDocument && cur !== context ) {
				for ( i = 0; i < selectors.length; i++ ) {

					if ( jQuery( cur ).is( selectors[ i ] ) ) {
						ret.push({ selector: selectors[ i ], elem: cur, level: level });
					}
				}

				cur = cur.parentNode;
				level++;
			}

			return ret;
		}

		// String
		var pos = POS.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( i = 0, l = this.length; i < l; i++ ) {
			cur = this[i];

			while ( cur ) {
				if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
					ret.push( cur );
					break;

				} else {
					cur = cur.parentNode;
					if ( !cur || !cur.ownerDocument || cur === context || cur.nodeType === 11 ) {
						break;
					}
				}
			}
		}

		ret = ret.length > 1 ? jQuery.unique( ret ) : ret;

		return this.pushStack( ret, "closest", selectors );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[0] && this[0].parentNode ) ? this.prevAll().length : -1;
		}

		// index in selector
		if ( typeof elem === "string" ) {
			return jQuery.inArray( this[0], jQuery( elem ) );
		}

		// Locate the position of the desired element
		return jQuery.inArray(
			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem, this );
	},

	add: function( selector, context ) {
		var set = typeof selector === "string" ?
				jQuery( selector, context ) :
				jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
			all = jQuery.merge( this.get(), set );

		return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
			all :
			jQuery.unique( all ) );
	},

	andSelf: function() {
		return this.add( this.prevObject );
	}
});

// A painfully simple check to see if an element is disconnected
// from a document (should be improved, where feasible).
function isDisconnected( node ) {
	return !node || !node.parentNode || node.parentNode.nodeType === 11;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return jQuery.nth( elem, 2, "nextSibling" );
	},
	prev: function( elem ) {
		return jQuery.nth( elem, 2, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( elem.parentNode.firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return jQuery.nodeName( elem, "iframe" ) ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.makeArray( elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var ret = jQuery.map( this, fn, until );

		if ( !runtil.test( name ) ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			ret = jQuery.filter( selector, ret );
		}

		ret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;

		if ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {
			ret = ret.reverse();
		}

		return this.pushStack( ret, name, slice.call( arguments ).join(",") );
	};
});

jQuery.extend({
	filter: function( expr, elems, not ) {
		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 ?
			jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
			jQuery.find.matches(expr, elems);
	},

	dir: function( elem, dir, until ) {
		var matched = [],
			cur = elem[ dir ];

		while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
			if ( cur.nodeType === 1 ) {
				matched.push( cur );
			}
			cur = cur[dir];
		}
		return matched;
	},

	nth: function( cur, result, dir, elem ) {
		result = result || 1;
		var num = 0;

		for ( ; cur; cur = cur[dir] ) {
			if ( cur.nodeType === 1 && ++num === result ) {
				break;
			}
		}

		return cur;
	},

	sibling: function( n, elem ) {
		var r = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				r.push( n );
			}
		}

		return r;
	}
});

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, keep ) {

	// Can't pass null or undefined to indexOf in Firefox 4
	// Set to 0 to skip string check
	qualifier = qualifier || 0;

	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep(elements, function( elem, i ) {
			var retVal = !!qualifier.call( elem, i, elem );
			return retVal === keep;
		});

	} else if ( qualifier.nodeType ) {
		return jQuery.grep(elements, function( elem, i ) {
			return ( elem === qualifier ) === keep;
		});

	} else if ( typeof qualifier === "string" ) {
		var filtered = jQuery.grep(elements, function( elem ) {
			return elem.nodeType === 1;
		});

		if ( isSimple.test( qualifier ) ) {
			return jQuery.filter(qualifier, filtered, !keep);
		} else {
			qualifier = jQuery.filter( qualifier, filtered );
		}
	}

	return jQuery.grep(elements, function( elem, i ) {
		return ( jQuery.inArray( elem, qualifier ) >= 0 ) === keep;
	});
}




function createSafeFragment( document ) {
	var list = nodeNames.split( "|" ),
	safeFrag = document.createDocumentFragment();

	if ( safeFrag.createElement ) {
		while ( list.length ) {
			safeFrag.createElement(
				list.pop()
			);
		}
	}
	return safeFrag;
}

var nodeNames = "abbr|article|aside|audio|canvas|datalist|details|figcaption|figure|footer|" +
		"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
	rinlinejQuery = / jQuery\d+="(?:\d+|null)"/g,
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style)/i,
	rnocache = /<(?:script|object|embed|option|style)/i,
	rnoshimcache = new RegExp("<(?:" + nodeNames + ")", "i"),
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /\/(java|ecma)script/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)/,
	wrapMap = {
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
		legend: [ 1, "<fieldset>", "</fieldset>" ],
		thead: [ 1, "<table>", "</table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
		area: [ 1, "<map>", "</map>" ],
		_default: [ 0, "", "" ]
	},
	safeFragment = createSafeFragment( document );

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// IE can't serialize <link> and <script> tags normally
if ( !jQuery.support.htmlSerialize ) {
	wrapMap._default = [ 1, "div<div>", "</div>" ];
}

jQuery.fn.extend({
	text: function( text ) {
		if ( jQuery.isFunction(text) ) {
			return this.each(function(i) {
				var self = jQuery( this );

				self.text( text.call(this, i, self.text()) );
			});
		}

		if ( typeof text !== "object" && text !== undefined ) {
			return this.empty().append( (this[0] && this[0].ownerDocument || document).createTextNode( text ) );
		}

		return jQuery.text( this );
	},

	wrapAll: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapAll( html.call(this, i) );
			});
		}

		if ( this[0] ) {
			// The elements to wrap the target around
			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

			if ( this[0].parentNode ) {
				wrap.insertBefore( this[0] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
					elem = elem.firstChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function(i) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	},

	append: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 ) {
				this.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 ) {
				this.insertBefore( elem, this.firstChild );
			}
		});
	},

	before: function() {
		if ( this[0] && this[0].parentNode ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this );
			});
		} else if ( arguments.length ) {
			var set = jQuery.clean( arguments );
			set.push.apply( set, this.toArray() );
			return this.pushStack( set, "before", arguments );
		}
	},

	after: function() {
		if ( this[0] && this[0].parentNode ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			});
		} else if ( arguments.length ) {
			var set = this.pushStack( this, "after", arguments );
			set.push.apply( set, jQuery.clean(arguments) );
			return set;
		}
	},

	// keepData is for internal use only--do not document
	remove: function( selector, keepData ) {
		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
			if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {
				if ( !keepData && elem.nodeType === 1 ) {
					jQuery.cleanData( elem.getElementsByTagName("*") );
					jQuery.cleanData( [ elem ] );
				}

				if ( elem.parentNode ) {
					elem.parentNode.removeChild( elem );
				}
			}
		}

		return this;
	},

	empty: function() {
		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
			// Remove element nodes and prevent memory leaks
			if ( elem.nodeType === 1 ) {
				jQuery.cleanData( elem.getElementsByTagName("*") );
			}

			// Remove any remaining nodes
			while ( elem.firstChild ) {
				elem.removeChild( elem.firstChild );
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function () {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		if ( value === undefined ) {
			return this[0] && this[0].nodeType === 1 ?
				this[0].innerHTML.replace(rinlinejQuery, "") :
				null;

		// See if we can take a shortcut and just use innerHTML
		} else if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
			(jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value )) &&
			!wrapMap[ (rtagName.exec( value ) || ["", ""])[1].toLowerCase() ] ) {

			value = value.replace(rxhtmlTag, "<$1></$2>");

			try {
				for ( var i = 0, l = this.length; i < l; i++ ) {
					// Remove element nodes and prevent memory leaks
					if ( this[i].nodeType === 1 ) {
						jQuery.cleanData( this[i].getElementsByTagName("*") );
						this[i].innerHTML = value;
					}
				}

			// If using innerHTML throws an exception, use the fallback method
			} catch(e) {
				this.empty().append( value );
			}

		} else if ( jQuery.isFunction( value ) ) {
			this.each(function(i){
				var self = jQuery( this );

				self.html( value.call(this, i, self.html()) );
			});

		} else {
			this.empty().append( value );
		}

		return this;
	},

	replaceWith: function( value ) {
		if ( this[0] && this[0].parentNode ) {
			// Make sure that the elements are removed from the DOM before they are inserted
			// this can help fix replacing a parent with child elements
			if ( jQuery.isFunction( value ) ) {
				return this.each(function(i) {
					var self = jQuery(this), old = self.html();
					self.replaceWith( value.call( this, i, old ) );
				});
			}

			if ( typeof value !== "string" ) {
				value = jQuery( value ).detach();
			}

			return this.each(function() {
				var next = this.nextSibling,
					parent = this.parentNode;

				jQuery( this ).remove();

				if ( next ) {
					jQuery(next).before( value );
				} else {
					jQuery(parent).append( value );
				}
			});
		} else {
			return this.length ?
				this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value ) :
				this;
		}
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, table, callback ) {
		var results, first, fragment, parent,
			value = args[0],
			scripts = [];

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( !jQuery.support.checkClone && arguments.length === 3 && typeof value === "string" && rchecked.test( value ) ) {
			return this.each(function() {
				jQuery(this).domManip( args, table, callback, true );
			});
		}

		if ( jQuery.isFunction(value) ) {
			return this.each(function(i) {
				var self = jQuery(this);
				args[0] = value.call(this, i, table ? self.html() : undefined);
				self.domManip( args, table, callback );
			});
		}

		if ( this[0] ) {
			parent = value && value.parentNode;

			// If we're in a fragment, just use that instead of building a new one
			if ( jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length ) {
				results = { fragment: parent };

			} else {
				results = jQuery.buildFragment( args, this, scripts );
			}

			fragment = results.fragment;

			if ( fragment.childNodes.length === 1 ) {
				first = fragment = fragment.firstChild;
			} else {
				first = fragment.firstChild;
			}

			if ( first ) {
				table = table && jQuery.nodeName( first, "tr" );

				for ( var i = 0, l = this.length, lastIndex = l - 1; i < l; i++ ) {
					callback.call(
						table ?
							root(this[i], first) :
							this[i],
						// Make sure that we do not leak memory by inadvertently discarding
						// the original fragment (which might have attached data) instead of
						// using it; in addition, use the original fragment object for the last
						// item instead of first because it can end up being emptied incorrectly
						// in certain situations (Bug #8070).
						// Fragments from the fragment cache must always be cloned and never used
						// in place.
						results.cacheable || ( l > 1 && i < lastIndex ) ?
							jQuery.clone( fragment, true, true ) :
							fragment
					);
				}
			}

			if ( scripts.length ) {
				jQuery.each( scripts, evalScript );
			}
		}

		return this;
	}
});

function root( elem, cur ) {
	return jQuery.nodeName(elem, "table") ?
		(elem.getElementsByTagName("tbody")[0] ||
		elem.appendChild(elem.ownerDocument.createElement("tbody"))) :
		elem;
}

function cloneCopyEvent( src, dest ) {

	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
		return;
	}

	var type, i, l,
		oldData = jQuery._data( src ),
		curData = jQuery._data( dest, oldData ),
		events = oldData.events;

	if ( events ) {
		delete curData.handle;
		curData.events = {};

		for ( type in events ) {
			for ( i = 0, l = events[ type ].length; i < l; i++ ) {
				jQuery.event.add( dest, type + ( events[ type ][ i ].namespace ? "." : "" ) + events[ type ][ i ].namespace, events[ type ][ i ], events[ type ][ i ].data );
			}
		}
	}

	// make the cloned public data object a copy from the original
	if ( curData.data ) {
		curData.data = jQuery.extend( {}, curData.data );
	}
}

function cloneFixAttributes( src, dest ) {
	var nodeName;

	// We do not need to do anything for non-Elements
	if ( dest.nodeType !== 1 ) {
		return;
	}

	// clearAttributes removes the attributes, which we don't want,
	// but also removes the attachEvent events, which we *do* want
	if ( dest.clearAttributes ) {
		dest.clearAttributes();
	}

	// mergeAttributes, in contrast, only merges back on the
	// original attributes, not the events
	if ( dest.mergeAttributes ) {
		dest.mergeAttributes( src );
	}

	nodeName = dest.nodeName.toLowerCase();

	// IE6-8 fail to clone children inside object elements that use
	// the proprietary classid attribute value (rather than the type
	// attribute) to identify the type of content to display
	if ( nodeName === "object" ) {
		dest.outerHTML = src.outerHTML;

	} else if ( nodeName === "input" && (src.type === "checkbox" || src.type === "radio") ) {
		// IE6-8 fails to persist the checked state of a cloned checkbox
		// or radio button. Worse, IE6-7 fail to give the cloned element
		// a checked appearance if the defaultChecked value isn't also set
		if ( src.checked ) {
			dest.defaultChecked = dest.checked = src.checked;
		}

		// IE6-7 get confused and end up setting the value of a cloned
		// checkbox/radio button to an empty string instead of "on"
		if ( dest.value !== src.value ) {
			dest.value = src.value;
		}

	// IE6-8 fails to return the selected option to the default selected
	// state when cloning options
	} else if ( nodeName === "option" ) {
		dest.selected = src.defaultSelected;

	// IE6-8 fails to set the defaultValue to the correct value when
	// cloning other types of input fields
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}

	// Event data gets referenced instead of copied if the expando
	// gets copied too
	dest.removeAttribute( jQuery.expando );
}

jQuery.buildFragment = function( args, nodes, scripts ) {
	var fragment, cacheable, cacheresults, doc,
	first = args[ 0 ];

	// nodes may contain either an explicit document object,
	// a jQuery collection or context object.
	// If nodes[0] contains a valid object to assign to doc
	if ( nodes && nodes[0] ) {
		doc = nodes[0].ownerDocument || nodes[0];
	}

	// Ensure that an attr object doesn't incorrectly stand in as a document object
	// Chrome and Firefox seem to allow this to occur and will throw exception
	// Fixes #8950
	if ( !doc.createDocumentFragment ) {
		doc = document;
	}

	// Only cache "small" (1/2 KB) HTML strings that are associated with the main document
	// Cloning options loses the selected state, so don't cache them
	// IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
	// Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
	// Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501
	if ( args.length === 1 && typeof first === "string" && first.length < 512 && doc === document &&
		first.charAt(0) === "<" && !rnocache.test( first ) &&
		(jQuery.support.checkClone || !rchecked.test( first )) &&
		(jQuery.support.html5Clone || !rnoshimcache.test( first )) ) {

		cacheable = true;

		cacheresults = jQuery.fragments[ first ];
		if ( cacheresults && cacheresults !== 1 ) {
			fragment = cacheresults;
		}
	}

	if ( !fragment ) {
		fragment = doc.createDocumentFragment();
		jQuery.clean( args, doc, fragment, scripts );
	}

	if ( cacheable ) {
		jQuery.fragments[ first ] = cacheresults ? fragment : 1;
	}

	return { fragment: fragment, cacheable: cacheable };
};

jQuery.fragments = {};

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var ret = [],
			insert = jQuery( selector ),
			parent = this.length === 1 && this[0].parentNode;

		if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {
			insert[ original ]( this[0] );
			return this;

		} else {
			for ( var i = 0, l = insert.length; i < l; i++ ) {
				var elems = ( i > 0 ? this.clone(true) : this ).get();
				jQuery( insert[i] )[ original ]( elems );
				ret = ret.concat( elems );
			}

			return this.pushStack( ret, name, insert.selector );
		}
	};
});

function getAll( elem ) {
	if ( typeof elem.getElementsByTagName !== "undefined" ) {
		return elem.getElementsByTagName( "*" );

	} else if ( typeof elem.querySelectorAll !== "undefined" ) {
		return elem.querySelectorAll( "*" );

	} else {
		return [];
	}
}

// Used in clean, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
	if ( elem.type === "checkbox" || elem.type === "radio" ) {
		elem.defaultChecked = elem.checked;
	}
}
// Finds all inputs and passes them to fixDefaultChecked
function findInputs( elem ) {
	var nodeName = ( elem.nodeName || "" ).toLowerCase();
	if ( nodeName === "input" ) {
		fixDefaultChecked( elem );
	// Skip scripts, get other children
	} else if ( nodeName !== "script" && typeof elem.getElementsByTagName !== "undefined" ) {
		jQuery.grep( elem.getElementsByTagName("input"), fixDefaultChecked );
	}
}

// Derived From: http://www.iecss.com/shimprove/javascript/shimprove.1-0-1.js
function shimCloneNode( elem ) {
	var div = document.createElement( "div" );
	safeFragment.appendChild( div );

	div.innerHTML = elem.outerHTML;
	return div.firstChild;
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var srcElements,
			destElements,
			i,
			// IE<=8 does not properly clone detached, unknown element nodes
			clone = jQuery.support.html5Clone || !rnoshimcache.test( "<" + elem.nodeName ) ?
				elem.cloneNode( true ) :
				shimCloneNode( elem );

		if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {
			// IE copies events bound via attachEvent when using cloneNode.
			// Calling detachEvent on the clone will also remove the events
			// from the original. In order to get around this, we use some
			// proprietary methods to clear the events. Thanks to MooTools
			// guys for this hotness.

			cloneFixAttributes( elem, clone );

			// Using Sizzle here is crazy slow, so we use getElementsByTagName instead
			srcElements = getAll( elem );
			destElements = getAll( clone );

			// Weird iteration because IE will replace the length property
			// with an element if you are cloning the body and one of the
			// elements on the page has a name or id of "length"
			for ( i = 0; srcElements[i]; ++i ) {
				// Ensure that the destination node is not null; Fixes #9587
				if ( destElements[i] ) {
					cloneFixAttributes( srcElements[i], destElements[i] );
				}
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			cloneCopyEvent( elem, clone );

			if ( deepDataAndEvents ) {
				srcElements = getAll( elem );
				destElements = getAll( clone );

				for ( i = 0; srcElements[i]; ++i ) {
					cloneCopyEvent( srcElements[i], destElements[i] );
				}
			}
		}

		srcElements = destElements = null;

		// Return the cloned set
		return clone;
	},

	clean: function( elems, context, fragment, scripts ) {
		var checkScriptType;

		context = context || document;

		// !context.createElement fails in IE with an error but returns typeof 'object'
		if ( typeof context.createElement === "undefined" ) {
			context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
		}

		var ret = [], j;

		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			if ( typeof elem === "number" ) {
				elem += "";
			}

			if ( !elem ) {
				continue;
			}

			// Convert html string into DOM nodes
			if ( typeof elem === "string" ) {
				if ( !rhtml.test( elem ) ) {
					elem = context.createTextNode( elem );
				} else {
					// Fix "XHTML"-style tags in all browsers
					elem = elem.replace(rxhtmlTag, "<$1></$2>");

					// Trim whitespace, otherwise indexOf won't work as expected
					var tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase(),
						wrap = wrapMap[ tag ] || wrapMap._default,
						depth = wrap[0],
						div = context.createElement("div");

					// Append wrapper element to unknown element safe doc fragment
					if ( context === document ) {
						// Use the fragment we've already created for this document
						safeFragment.appendChild( div );
					} else {
						// Use a fragment created with the owner document
						createSafeFragment( context ).appendChild( div );
					}

					// Go to html and back, then peel off extra wrappers
					div.innerHTML = wrap[1] + elem + wrap[2];

					// Move to the right depth
					while ( depth-- ) {
						div = div.lastChild;
					}

					// Remove IE's autoinserted <tbody> from table fragments
					if ( !jQuery.support.tbody ) {

						// String was a <table>, *may* have spurious <tbody>
						var hasBody = rtbody.test(elem),
							tbody = tag === "table" && !hasBody ?
								div.firstChild && div.firstChild.childNodes :

								// String was a bare <thead> or <tfoot>
								wrap[1] === "<table>" && !hasBody ?
									div.childNodes :
									[];

						for ( j = tbody.length - 1; j >= 0 ; --j ) {
							if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j ].childNodes.length ) {
								tbody[ j ].parentNode.removeChild( tbody[ j ] );
							}
						}
					}

					// IE completely kills leading whitespace when innerHTML is used
					if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
						div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
					}

					elem = div.childNodes;
				}
			}

			// Resets defaultChecked for any radios and checkboxes
			// about to be appended to the DOM in IE 6/7 (#8060)
			var len;
			if ( !jQuery.support.appendChecked ) {
				if ( elem[0] && typeof (len = elem.length) === "number" ) {
					for ( j = 0; j < len; j++ ) {
						findInputs( elem[j] );
					}
				} else {
					findInputs( elem );
				}
			}

			if ( elem.nodeType ) {
				ret.push( elem );
			} else {
				ret = jQuery.merge( ret, elem );
			}
		}

		if ( fragment ) {
			checkScriptType = function( elem ) {
				return !elem.type || rscriptType.test( elem.type );
			};
			for ( i = 0; ret[i]; i++ ) {
				if ( scripts && jQuery.nodeName( ret[i], "script" ) && (!ret[i].type || ret[i].type.toLowerCase() === "text/javascript") ) {
					scripts.push( ret[i].parentNode ? ret[i].parentNode.removeChild( ret[i] ) : ret[i] );

				} else {
					if ( ret[i].nodeType === 1 ) {
						var jsTags = jQuery.grep( ret[i].getElementsByTagName( "script" ), checkScriptType );

						ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );
					}
					fragment.appendChild( ret[i] );
				}
			}
		}

		return ret;
	},

	cleanData: function( elems ) {
		var data, id,
			cache = jQuery.cache,
			special = jQuery.event.special,
			deleteExpando = jQuery.support.deleteExpando;

		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			if ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) {
				continue;
			}

			id = elem[ jQuery.expando ];

			if ( id ) {
				data = cache[ id ];

				if ( data && data.events ) {
					for ( var type in data.events ) {
						if ( special[ type ] ) {
							jQuery.event.remove( elem, type );

						// This is a shortcut to avoid jQuery.event.remove's overhead
						} else {
							jQuery.removeEvent( elem, type, data.handle );
						}
					}

					// Null the DOM reference to avoid IE6/7/8 leak (#7054)
					if ( data.handle ) {
						data.handle.elem = null;
					}
				}

				if ( deleteExpando ) {
					delete elem[ jQuery.expando ];

				} else if ( elem.removeAttribute ) {
					elem.removeAttribute( jQuery.expando );
				}

				delete cache[ id ];
			}
		}
	}
});

function evalScript( i, elem ) {
	if ( elem.src ) {
		jQuery.ajax({
			url: elem.src,
			async: false,
			dataType: "script"
		});
	} else {
		jQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML || "" ).replace( rcleanScript, "/*$0*/" ) );
	}

	if ( elem.parentNode ) {
		elem.parentNode.removeChild( elem );
	}
}




var ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity=([^)]*)/,
	// fixed for IE9, see #8346
	rupper = /([A-Z]|^ms)/g,
	rnumpx = /^-?\d+(?:px)?$/i,
	rnum = /^-?\d/,
	rrelNum = /^([\-+])=([\-+.\de]+)/,

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssWidth = [ "Left", "Right" ],
	cssHeight = [ "Top", "Bottom" ],
	curCSS,

	getComputedStyle,
	currentStyle;

jQuery.fn.css = function( name, value ) {
	// Setting 'undefined' is a no-op
	if ( arguments.length === 2 && value === undefined ) {
		return this;
	}

	return jQuery.access( this, name, value, true, function( elem, name, value ) {
		return value !== undefined ?
			jQuery.style( elem, name, value ) :
			jQuery.css( elem, name );
	});
};

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity", "opacity" );
					return ret === "" ? "1" : ret;

				} else {
					return elem.style.opacity;
				}
			}
		}
	},

	// Exclude the following css properties to add px
	cssNumber: {
		"fillOpacity": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, origName = jQuery.camelCase( name ),
			style = elem.style, hooks = jQuery.cssHooks[ origName ];

		name = jQuery.cssProps[ origName ] || origName;

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// convert relative number strings (+= or -=) to relative numbers. #7345
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( +( ret[1] + 1) * +ret[2] ) + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that NaN and null values aren't set. See: #7116
			if ( value == null || type === "number" && isNaN( value ) ) {
				return;
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value )) !== undefined ) {
				// Wrapped to prevent IE from throwing errors when 'invalid' values are provided
				// Fixes bug #5509
				try {
					style[ name ] = value;
				} catch(e) {}
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra ) {
		var ret, hooks;

		// Make sure that we're working with the right name
		name = jQuery.camelCase( name );
		hooks = jQuery.cssHooks[ name ];
		name = jQuery.cssProps[ name ] || name;

		// cssFloat needs a special treatment
		if ( name === "cssFloat" ) {
			name = "float";
		}

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks && (ret = hooks.get( elem, true, extra )) !== undefined ) {
			return ret;

		// Otherwise, if a way to get the computed value exists, use that
		} else if ( curCSS ) {
			return curCSS( elem, name );
		}
	},

	// A method for quickly swapping in/out CSS properties to get correct calculations
	swap: function( elem, options, callback ) {
		var old = {};

		// Remember the old values, and insert the new ones
		for ( var name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		callback.call( elem );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}
	}
});

// DEPRECATED, Use jQuery.css() instead
jQuery.curCSS = jQuery.css;

jQuery.each(["height", "width"], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			var val;

			if ( computed ) {
				if ( elem.offsetWidth !== 0 ) {
					return getWH( elem, name, extra );
				} else {
					jQuery.swap( elem, cssShow, function() {
						val = getWH( elem, name, extra );
					});
				}

				return val;
			}
		},

		set: function( elem, value ) {
			if ( rnumpx.test( value ) ) {
				// ignore negative width and height values #1599
				value = parseFloat( value );

				if ( value >= 0 ) {
					return value + "px";
				}

			} else {
				return value;
			}
		}
	};
});

if ( !jQuery.support.opacity ) {
	jQuery.cssHooks.opacity = {
		get: function( elem, computed ) {
			// IE uses filters for opacity
			return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
				( parseFloat( RegExp.$1 ) / 100 ) + "" :
				computed ? "1" : "";
		},

		set: function( elem, value ) {
			var style = elem.style,
				currentStyle = elem.currentStyle,
				opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
				filter = currentStyle && currentStyle.filter || style.filter || "";

			// IE has trouble with opacity if it does not have layout
			// Force it by setting the zoom level
			style.zoom = 1;

			// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
			if ( value >= 1 && jQuery.trim( filter.replace( ralpha, "" ) ) === "" ) {

				// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
				// if "filter:" is present at all, clearType is disabled, we want to avoid this
				// style.removeAttribute is IE Only, but so apparently is this code path...
				style.removeAttribute( "filter" );

				// if there there is no filter style applied in a css rule, we are done
				if ( currentStyle && !currentStyle.filter ) {
					return;
				}
			}

			// otherwise, set new filter values
			style.filter = ralpha.test( filter ) ?
				filter.replace( ralpha, opacity ) :
				filter + " " + opacity;
		}
	};
}

jQuery(function() {
	// This hook cannot be added until DOM ready because the support test
	// for it is not run until after DOM ready
	if ( !jQuery.support.reliableMarginRight ) {
		jQuery.cssHooks.marginRight = {
			get: function( elem, computed ) {
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// Work around by temporarily setting element display to inline-block
				var ret;
				jQuery.swap( elem, { "display": "inline-block" }, function() {
					if ( computed ) {
						ret = curCSS( elem, "margin-right", "marginRight" );
					} else {
						ret = elem.style.marginRight;
					}
				});
				return ret;
			}
		};
	}
});

if ( document.defaultView && document.defaultView.getComputedStyle ) {
	getComputedStyle = function( elem, name ) {
		var ret, defaultView, computedStyle;

		name = name.replace( rupper, "-$1" ).toLowerCase();

		if ( (defaultView = elem.ownerDocument.defaultView) &&
				(computedStyle = defaultView.getComputedStyle( elem, null )) ) {
			ret = computedStyle.getPropertyValue( name );
			if ( ret === "" && !jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
				ret = jQuery.style( elem, name );
			}
		}

		return ret;
	};
}

if ( document.documentElement.currentStyle ) {
	currentStyle = function( elem, name ) {
		var left, rsLeft, uncomputed,
			ret = elem.currentStyle && elem.currentStyle[ name ],
			style = elem.style;

		// Avoid setting ret to empty string here
		// so we don't default to auto
		if ( ret === null && style && (uncomputed = style[ name ]) ) {
			ret = uncomputed;
		}

		// From the awesome hack by Dean Edwards
		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

		// If we're not dealing with a regular pixel number
		// but a number that has a weird ending, we need to convert it to pixels
		if ( !rnumpx.test( ret ) && rnum.test( ret ) ) {

			// Remember the original values
			left = style.left;
			rsLeft = elem.runtimeStyle && elem.runtimeStyle.left;

			// Put in the new values to get a computed value out
			if ( rsLeft ) {
				elem.runtimeStyle.left = elem.currentStyle.left;
			}
			style.left = name === "fontSize" ? "1em" : ( ret || 0 );
			ret = style.pixelLeft + "px";

			// Revert the changed values
			style.left = left;
			if ( rsLeft ) {
				elem.runtimeStyle.left = rsLeft;
			}
		}

		return ret === "" ? "auto" : ret;
	};
}

curCSS = getComputedStyle || currentStyle;

function getWH( elem, name, extra ) {

	// Start with offset property
	var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		which = name === "width" ? cssWidth : cssHeight,
		i = 0,
		len = which.length;

	if ( val > 0 ) {
		if ( extra !== "border" ) {
			for ( ; i < len; i++ ) {
				if ( !extra ) {
					val -= parseFloat( jQuery.css( elem, "padding" + which[ i ] ) ) || 0;
				}
				if ( extra === "margin" ) {
					val += parseFloat( jQuery.css( elem, extra + which[ i ] ) ) || 0;
				} else {
					val -= parseFloat( jQuery.css( elem, "border" + which[ i ] + "Width" ) ) || 0;
				}
			}
		}

		return val + "px";
	}

	// Fall back to computed then uncomputed css if necessary
	val = curCSS( elem, name, name );
	if ( val < 0 || val == null ) {
		val = elem.style[ name ] || 0;
	}
	// Normalize "", auto, and prepare for extra
	val = parseFloat( val ) || 0;

	// Add padding, border, margin
	if ( extra ) {
		for ( ; i < len; i++ ) {
			val += parseFloat( jQuery.css( elem, "padding" + which[ i ] ) ) || 0;
			if ( extra !== "padding" ) {
				val += parseFloat( jQuery.css( elem, "border" + which[ i ] + "Width" ) ) || 0;
			}
			if ( extra === "margin" ) {
				val += parseFloat( jQuery.css( elem, extra + which[ i ] ) ) || 0;
			}
		}
	}

	return val + "px";
}

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.hidden = function( elem ) {
		var width = elem.offsetWidth,
			height = elem.offsetHeight;

		return ( width === 0 && height === 0 ) || (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
	};

	jQuery.expr.filters.visible = function( elem ) {
		return !jQuery.expr.filters.hidden( elem );
	};
}




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rhash = /#.*$/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
	rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rquery = /\?/,
	rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
	rselectTextarea = /^(?:select|textarea)/i,
	rspacesAjax = /\s+/,
	rts = /([?&])_=[^&]*/,
	rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,

	// Keep a copy of the old load method
	_load = jQuery.fn.load,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Document location
	ajaxLocation,

	// Document location segments
	ajaxLocParts,

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = ["*/"] + ["*"];

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
	ajaxLocation = location.href;
} catch( e ) {
	// Use the href attribute of an A element
	// since IE will modify it given document.location
	ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		if ( jQuery.isFunction( func ) ) {
			var dataTypes = dataTypeExpression.toLowerCase().split( rspacesAjax ),
				i = 0,
				length = dataTypes.length,
				dataType,
				list,
				placeBefore;

			// For each dataType in the dataTypeExpression
			for ( ; i < length; i++ ) {
				dataType = dataTypes[ i ];
				// We control if we're asked to add before
				// any existing element
				placeBefore = /^\+/.test( dataType );
				if ( placeBefore ) {
					dataType = dataType.substr( 1 ) || "*";
				}
				list = structure[ dataType ] = structure[ dataType ] || [];
				// then we add to the structure accordingly
				list[ placeBefore ? "unshift" : "push" ]( func );
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,
		dataType /* internal */, inspected /* internal */ ) {

	dataType = dataType || options.dataTypes[ 0 ];
	inspected = inspected || {};

	inspected[ dataType ] = true;

	var list = structure[ dataType ],
		i = 0,
		length = list ? list.length : 0,
		executeOnly = ( structure === prefilters ),
		selection;

	for ( ; i < length && ( executeOnly || !selection ); i++ ) {
		selection = list[ i ]( options, originalOptions, jqXHR );
		// If we got redirected to another dataType
		// we try there if executing only and not done already
		if ( typeof selection === "string" ) {
			if ( !executeOnly || inspected[ selection ] ) {
				selection = undefined;
			} else {
				options.dataTypes.unshift( selection );
				selection = inspectPrefiltersOrTransports(
						structure, options, originalOptions, jqXHR, selection, inspected );
			}
		}
	}
	// If we're only executing or nothing was selected
	// we try the catchall dataType if not done already
	if ( ( executeOnly || !selection ) && !inspected[ "*" ] ) {
		selection = inspectPrefiltersOrTransports(
				structure, options, originalOptions, jqXHR, "*", inspected );
	}
	// unnecessary when only executing (prefilters)
	// but it'll be ignored by the caller in that case
	return selection;
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};
	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}
}

jQuery.fn.extend({
	load: function( url, params, callback ) {
		if ( typeof url !== "string" && _load ) {
			return _load.apply( this, arguments );

		// Don't do a request if no elements are being requested
		} else if ( !this.length ) {
			return this;
		}

		var off = url.indexOf( " " );
		if ( off >= 0 ) {
			var selector = url.slice( off, url.length );
			url = url.slice( 0, off );
		}

		// Default to a GET request
		var type = "GET";

		// If the second parameter was provided
		if ( params ) {
			// If it's a function
			if ( jQuery.isFunction( params ) ) {
				// We assume that it's the callback
				callback = params;
				params = undefined;

			// Otherwise, build a param string
			} else if ( typeof params === "object" ) {
				params = jQuery.param( params, jQuery.ajaxSettings.traditional );
				type = "POST";
			}
		}

		var self = this;

		// Request the remote document
		jQuery.ajax({
			url: url,
			type: type,
			dataType: "html",
			data: params,
			// Complete callback (responseText is used internally)
			complete: function( jqXHR, status, responseText ) {
				// Store the response as specified by the jqXHR object
				responseText = jqXHR.responseText;
				// If successful, inject the HTML into all the matched elements
				if ( jqXHR.isResolved() ) {
					// #4825: Get the actual response in case
					// a dataFilter is present in ajaxSettings
					jqXHR.done(function( r ) {
						responseText = r;
					});
					// See if a selector was specified
					self.html( selector ?
						// Create a dummy div to hold the results
						jQuery("<div>")
							// inject the contents of the document in, removing the scripts
							// to avoid any 'Permission Denied' errors in IE
							.append(responseText.replace(rscript, ""))

							// Locate the specified elements
							.find(selector) :

						// If not, just inject the full result
						responseText );
				}

				if ( callback ) {
					self.each( callback, [ responseText, status, jqXHR ] );
				}
			}
		});

		return this;
	},

	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},

	serializeArray: function() {
		return this.map(function(){
			return this.elements ? jQuery.makeArray( this.elements ) : this;
		})
		.filter(function(){
			return this.name && !this.disabled &&
				( this.checked || rselectTextarea.test( this.nodeName ) ||
					rinput.test( this.type ) );
		})
		.map(function( i, elem ){
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val, i ){
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});

// Attach a bunch of functions for handling common AJAX events
jQuery.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split( " " ), function( i, o ){
	jQuery.fn[ o ] = function( f ){
		return this.on( o, f );
	};
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			type: method,
			url: url,
			data: data,
			success: callback,
			dataType: type
		});
	};
});

jQuery.extend({

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		if ( settings ) {
			// Building a settings object
			ajaxExtend( target, jQuery.ajaxSettings );
		} else {
			// Extending ajaxSettings
			settings = target;
			target = jQuery.ajaxSettings;
		}
		ajaxExtend( target, settings );
		return target;
	},

	ajaxSettings: {
		url: ajaxLocation,
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		type: "GET",
		contentType: "application/x-www-form-urlencoded",
		processData: true,
		async: true,
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		traditional: false,
		headers: {},
		*/

		accepts: {
			xml: "application/xml, text/xml",
			html: "text/html",
			text: "text/plain",
			json: "application/json, text/javascript",
			"*": allTypes
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText"
		},

		// List of data converters
		// 1) key format is "source_type destination_type" (a single space in-between)
		// 2) the catchall symbol "*" can be used for source_type
		converters: {

			// Convert anything to text
			"* text": window.String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			context: true,
			url: true
		}
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var // Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events
			// It's the callbackContext if one was provided in the options
			// and if it's a DOM node or a jQuery collection
			globalEventContext = callbackContext !== s &&
				( callbackContext.nodeType || callbackContext instanceof jQuery ) ?
						jQuery( callbackContext ) : jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// ifModified key
			ifModifiedKey,
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// Response headers
			responseHeadersString,
			responseHeaders,
			// transport
			transport,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// The jqXHR state
			state = 0,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Fake xhr
			jqXHR = {

				readyState: 0,

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( !state ) {
						var lname = name.toLowerCase();
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match === undefined ? null : match;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					statusText = statusText || "abort";
					if ( transport ) {
						transport.abort( statusText );
					}
					done( 0, statusText );
					return this;
				}
			};

		// Callback for when everything is done
		// It is defined here because jslint complains if it is declared
		// at the end of the function (which would be more logical and readable)
		function done( status, nativeStatusText, responses, headers ) {

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			var isSuccess,
				success,
				error,
				statusText = nativeStatusText,
				response = responses ? ajaxHandleResponses( s, jqXHR, responses ) : undefined,
				lastModified,
				etag;

			// If successful, handle type chaining
			if ( status >= 200 && status < 300 || status === 304 ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {

					if ( ( lastModified = jqXHR.getResponseHeader( "Last-Modified" ) ) ) {
						jQuery.lastModified[ ifModifiedKey ] = lastModified;
					}
					if ( ( etag = jqXHR.getResponseHeader( "Etag" ) ) ) {
						jQuery.etag[ ifModifiedKey ] = etag;
					}
				}

				// If not modified
				if ( status === 304 ) {

					statusText = "notmodified";
					isSuccess = true;

				// If we have data
				} else {

					try {
						success = ajaxConvert( s, response );
						statusText = "success";
						isSuccess = true;
					} catch(e) {
						// We have a parsererror
						statusText = "parsererror";
						error = e;
					}
				}
			} else {
				// We extract error from statusText
				// then normalize statusText and status for non-aborts
				error = statusText;
				if ( !statusText || status ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = "" + ( nativeStatusText || statusText );

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajax" + ( isSuccess ? "Success" : "Error" ),
						[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		// Attach deferreds
		deferred.promise( jqXHR );
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;
		jqXHR.complete = completeDeferred.add;

		// Status-dependent callbacks
		jqXHR.statusCode = function( map ) {
			if ( map ) {
				var tmp;
				if ( state < 2 ) {
					for ( tmp in map ) {
						statusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];
					}
				} else {
					tmp = map[ jqXHR.status ];
					jqXHR.then( tmp, tmp );
				}
			}
			return this;
		};

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
		// We also use the url parameter if available
		s.url = ( ( url || s.url ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().split( rspacesAjax );

		// Determine if a cross-domain request is in order
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] != ajaxLocParts[ 1 ] || parts[ 2 ] != ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? 80 : 443 ) ) !=
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefiler, stop there
		if ( state === 2 ) {
			return false;
		}

		// We can fire global events as of now if asked to
		fireGlobals = s.global;

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.data;
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Get ifModifiedKey before adding the anti-cache parameter
			ifModifiedKey = s.url;

			// Add anti-cache in url if needed
			if ( s.cache === false ) {

				var ts = jQuery.now(),
					// try replacing _= if it is there
					ret = s.url.replace( rts, "$1_=" + ts );

				// if nothing was replaced, add timestamp to the end
				s.url = ret + ( ( ret === s.url ) ? ( rquery.test( s.url ) ? "&" : "?" ) + "_=" + ts : "" );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			ifModifiedKey = ifModifiedKey || s.url;
			if ( jQuery.lastModified[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ ifModifiedKey ] );
			}
			if ( jQuery.etag[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ ifModifiedKey ] );
			}
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
				// Abort if not done already
				jqXHR.abort();
				return false;

		}

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;
			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout( function(){
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch (e) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		return jqXHR;
	},

	// Serialize an array of form elements or a set of
	// key/values into a query string
	param: function( a, traditional ) {
		var s = [],
			add = function( key, value ) {
				// If value is a function, invoke it and return its value
				value = jQuery.isFunction( value ) ? value() : value;
				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
			};

		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if ( traditional === undefined ) {
			traditional = jQuery.ajaxSettings.traditional;
		}

		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			});

		} else {
			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( var prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( "&" ).replace( r20, "+" );
	}
});

function buildParams( prefix, obj, traditional, add ) {
	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// If array item is non-scalar (array or object), encode its
				// numeric index to resolve deserialization ambiguity issues.
				// Note that rack (as of 1.0.0) can't currently deserialize
				// nested arrays properly, and attempting to do so may cause
				// a server error. Possible fixes are to modify rack's
				// deserialization algorithm or to provide an option or flag
				// to force array serialization to be shallow.
				buildParams( prefix + "[" + ( typeof v === "object" || jQuery.isArray(v) ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && obj != null && typeof obj === "object" ) {
		// Serialize object item.
		for ( var name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// This is still on the jQuery object... for now
// Want to move this to jQuery.ajax some day
jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {}

});

/* Handles responses to an ajax request:
 * - sets all responseXXX fields accordingly
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var contents = s.contents,
		dataTypes = s.dataTypes,
		responseFields = s.responseFields,
		ct,
		type,
		finalDataType,
		firstDataType;

	// Fill responseXXX fields
	for ( type in responseFields ) {
		if ( type in responses ) {
			jqXHR[ responseFields[type] ] = responses[ type ];
		}
	}

	// Remove auto dataType and get content-type in the process
	while( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "content-type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

// Chain conversions given the request and the original response
function ajaxConvert( s, response ) {

	// Apply the dataFilter if provided
	if ( s.dataFilter ) {
		response = s.dataFilter( response, s.dataType );
	}

	var dataTypes = s.dataTypes,
		converters = {},
		i,
		key,
		length = dataTypes.length,
		tmp,
		// Current and previous dataTypes
		current = dataTypes[ 0 ],
		prev,
		// Conversion expression
		conversion,
		// Conversion function
		conv,
		// Conversion functions (transitive conversion)
		conv1,
		conv2;

	// For each dataType in the chain
	for ( i = 1; i < length; i++ ) {

		// Create converters map
		// with lowercased keys
		if ( i === 1 ) {
			for ( key in s.converters ) {
				if ( typeof key === "string" ) {
					converters[ key.toLowerCase() ] = s.converters[ key ];
				}
			}
		}

		// Get the dataTypes
		prev = current;
		current = dataTypes[ i ];

		// If current is auto dataType, update it to prev
		if ( current === "*" ) {
			current = prev;
		// If no auto and dataTypes are actually different
		} else if ( prev !== "*" && prev !== current ) {

			// Get the converter
			conversion = prev + " " + current;
			conv = converters[ conversion ] || converters[ "* " + current ];

			// If there is no direct converter, search transitively
			if ( !conv ) {
				conv2 = undefined;
				for ( conv1 in converters ) {
					tmp = conv1.split( " " );
					if ( tmp[ 0 ] === prev || tmp[ 0 ] === "*" ) {
						conv2 = converters[ tmp[1] + " " + current ];
						if ( conv2 ) {
							conv1 = converters[ conv1 ];
							if ( conv1 === true ) {
								conv = conv2;
							} else if ( conv2 === true ) {
								conv = conv1;
							}
							break;
						}
					}
				}
			}
			// If we found no converter, dispatch an error
			if ( !( conv || conv2 ) ) {
				jQuery.error( "No conversion from " + conversion.replace(" "," to ") );
			}
			// If found converter is not an equivalence
			if ( conv !== true ) {
				// Convert with 1 or 2 converters accordingly
				response = conv ? conv( response ) : conv2( conv1(response) );
			}
		}
	}
	return response;
}




var jsc = jQuery.now(),
	jsre = /(\=)\?(&|$)|\?\?/i;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		return jQuery.expando + "_" + ( jsc++ );
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var inspectData = s.contentType === "application/x-www-form-urlencoded" &&
		( typeof s.data === "string" );

	if ( s.dataTypes[ 0 ] === "jsonp" ||
		s.jsonp !== false && ( jsre.test( s.url ) ||
				inspectData && jsre.test( s.data ) ) ) {

		var responseContainer,
			jsonpCallback = s.jsonpCallback =
				jQuery.isFunction( s.jsonpCallback ) ? s.jsonpCallback() : s.jsonpCallback,
			previous = window[ jsonpCallback ],
			url = s.url,
			data = s.data,
			replace = "$1" + jsonpCallback + "$2";

		if ( s.jsonp !== false ) {
			url = url.replace( jsre, replace );
			if ( s.url === url ) {
				if ( inspectData ) {
					data = data.replace( jsre, replace );
				}
				if ( s.data === data ) {
					// Add callback manually
					url += (/\?/.test( url ) ? "&" : "?") + s.jsonp + "=" + jsonpCallback;
				}
			}
		}

		s.url = url;
		s.data = data;

		// Install callback
		window[ jsonpCallback ] = function( response ) {
			responseContainer = [ response ];
		};

		// Clean-up function
		jqXHR.always(function() {
			// Set callback back to previous value
			window[ jsonpCallback ] = previous;
			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( previous ) ) {
				window[ jsonpCallback ]( responseContainer[ 0 ] );
			}
		});

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( jsonpCallback + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Delegate to script
		return "script";
	}
});




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /javascript|ecmascript/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and global
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
		s.global = false;
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function(s) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {

		var script,
			head = document.head || document.getElementsByTagName( "head" )[0] || document.documentElement;

		return {

			send: function( _, callback ) {

				script = document.createElement( "script" );

				script.async = "async";

				if ( s.scriptCharset ) {
					script.charset = s.scriptCharset;
				}

				script.src = s.url;

				// Attach handlers for all browsers
				script.onload = script.onreadystatechange = function( _, isAbort ) {

					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

						// Handle memory leak in IE
						script.onload = script.onreadystatechange = null;

						// Remove the script
						if ( head && script.parentNode ) {
							head.removeChild( script );
						}

						// Dereference the script
						script = undefined;

						// Callback if not abort
						if ( !isAbort ) {
							callback( 200, "success" );
						}
					}
				};
				// Use insertBefore instead of appendChild  to circumvent an IE6 bug.
				// This arises when a base node is used (#2709 and #4378).
				head.insertBefore( script, head.firstChild );
			},

			abort: function() {
				if ( script ) {
					script.onload( 0, 1 );
				}
			}
		};
	}
});




var // #5280: Internet Explorer will keep connections alive if we don't abort on unload
	xhrOnUnloadAbort = window.ActiveXObject ? function() {
		// Abort all pending requests
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]( 0, 1 );
		}
	} : false,
	xhrId = 0,
	xhrCallbacks;

// Functions to create xhrs
function createStandardXHR() {
	try {
		return new window.XMLHttpRequest();
	} catch( e ) {}
}

function createActiveXHR() {
	try {
		return new window.ActiveXObject( "Microsoft.XMLHTTP" );
	} catch( e ) {}
}

// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
jQuery.ajaxSettings.xhr = window.ActiveXObject ?
	/* Microsoft failed to properly
	 * implement the XMLHttpRequest in IE7 (can't request local files),
	 * so we use the ActiveXObject when it is available
	 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
	 * we need a fallback.
	 */
	function() {
		return !this.isLocal && createStandardXHR() || createActiveXHR();
	} :
	// For all other browsers, use the standard XMLHttpRequest object
	createStandardXHR;

// Determine support properties
(function( xhr ) {
	jQuery.extend( jQuery.support, {
		ajax: !!xhr,
		cors: !!xhr && ( "withCredentials" in xhr )
	});
})( jQuery.ajaxSettings.xhr() );

// Create transport if the browser can provide an xhr
if ( jQuery.support.ajax ) {

	jQuery.ajaxTransport(function( s ) {
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( !s.crossDomain || jQuery.support.cors ) {

			var callback;

			return {
				send: function( headers, complete ) {

					// Get a new xhr
					var xhr = s.xhr(),
						handle,
						i;

					// Open the socket
					// Passing null username, generates a login popup on Opera (#2865)
					if ( s.username ) {
						xhr.open( s.type, s.url, s.async, s.username, s.password );
					} else {
						xhr.open( s.type, s.url, s.async );
					}

					// Apply custom fields if provided
					if ( s.xhrFields ) {
						for ( i in s.xhrFields ) {
							xhr[ i ] = s.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( s.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( s.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !s.crossDomain && !headers["X-Requested-With"] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}

					// Need an extra try/catch for cross domain requests in Firefox 3
					try {
						for ( i in headers ) {
							xhr.setRequestHeader( i, headers[ i ] );
						}
					} catch( _ ) {}

					// Do send the request
					// This may raise an exception which is actually
					// handled in jQuery.ajax (so no try/catch here)
					
					xhr.send( ( s.hasContent && s.data ) || null );

					// Listener
					callback = function( _, isAbort ) {

						var status,
							statusText,
							responseHeaders,
							responses,
							xml;

						// Firefox throws exceptions when accessing properties
						// of an xhr when a network error occured
						// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
						try {

							// Was never called and is aborted or complete
							if ( callback && ( isAbort || xhr.readyState === 4 ) ) {

								// Only called once
								callback = undefined;

								// Do not keep as active anymore
								if ( handle ) {
									xhr.onreadystatechange = jQuery.noop;
									if ( xhrOnUnloadAbort ) {
										delete xhrCallbacks[ handle ];
									}
								}

								// If it's an abort
								if ( isAbort ) {
									// Abort it manually if needed
									if ( xhr.readyState !== 4 ) {
										xhr.abort();
									}
								} else {
									status = xhr.status;
									responseHeaders = xhr.getAllResponseHeaders();
									responses = {};
									xml = xhr.responseXML;
			

									// Construct response list
									if ( xml && xml.documentElement /* #4958 */ ) {
										responses.xml = xml;
									}
									responses.text = xhr.responseText;

									// Firefox throws an exception when accessing
									// statusText for faulty cross-domain requests
									try {
										statusText = xhr.statusText;
									} catch( e ) {
										// We normalize with Webkit giving an empty statusText
										statusText = "";
									}

									// Filter status for non standard behaviors

									// If the request is local and we have data: assume a success
									// (success with no data won't get notified, that's the best we
									// can do given current implementations)
									if ( !status && s.isLocal && !s.crossDomain ) {
										status = responses.text ? 200 : 404;
									// IE - #1450: sometimes returns 1223 when it should be 204
									} else if ( status === 1223 ) {
										status = 204;
									}
								}
							}
						} catch( firefoxAccessException ) {
							if ( !isAbort ) {
								complete( -1, firefoxAccessException );
							}
						}

						// Call complete if needed
						if ( responses ) {
							complete( status, statusText, responses, responseHeaders );
						}
					};

					// if we're in sync mode or it's in cache
					// and has been retrieved directly (IE6 & IE7)
					// we need to manually fire the callback
					if ( !s.async || xhr.readyState === 4 ) {
						callback();
					} else {
						handle = ++xhrId;
						if ( xhrOnUnloadAbort ) {
							// Create the active xhrs callbacks list if needed
							// and attach the unload handler
							if ( !xhrCallbacks ) {
								xhrCallbacks = {};
								jQuery( window ).unload( xhrOnUnloadAbort );
							}
							// Add to list of active xhrs callbacks
							xhrCallbacks[ handle ] = callback;
						}
						xhr.onreadystatechange = callback;
					}
				},

				abort: function() {
					if ( callback ) {
						callback(0,1);
					}
				}
			};
		}
	});
}




var elemdisplay = {},
	iframe, iframeDoc,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = /^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,
	timerId,
	fxAttrs = [
		// height animations
		[ "height", "marginTop", "marginBottom", "paddingTop", "paddingBottom" ],
		// width animations
		[ "width", "marginLeft", "marginRight", "paddingLeft", "paddingRight" ],
		// opacity animations
		[ "opacity" ]
	],
	fxNow;

jQuery.fn.extend({
	show: function( speed, easing, callback ) {
		var elem, display;

		if ( speed || speed === 0 ) {
			return this.animate( genFx("show", 3), speed, easing, callback );

		} else {
			for ( var i = 0, j = this.length; i < j; i++ ) {
				elem = this[ i ];

				if ( elem.style ) {
					display = elem.style.display;

					// Reset the inline display of this element to learn if it is
					// being hidden by cascaded rules or not
					if ( !jQuery._data(elem, "olddisplay") && display === "none" ) {
						display = elem.style.display = "";
					}

					// Set elements which have been overridden with display: none
					// in a stylesheet to whatever the default browser style is
					// for such an element
					if ( display === "" && jQuery.css(elem, "display") === "none" ) {
						jQuery._data( elem, "olddisplay", defaultDisplay(elem.nodeName) );
					}
				}
			}

			// Set the display of most of the elements in a second loop
			// to avoid the constant reflow
			for ( i = 0; i < j; i++ ) {
				elem = this[ i ];

				if ( elem.style ) {
					display = elem.style.display;

					if ( display === "" || display === "none" ) {
						elem.style.display = jQuery._data( elem, "olddisplay" ) || "";
					}
				}
			}

			return this;
		}
	},

	hide: function( speed, easing, callback ) {
		if ( speed || speed === 0 ) {
			return this.animate( genFx("hide", 3), speed, easing, callback);

		} else {
			var elem, display,
				i = 0,
				j = this.length;

			for ( ; i < j; i++ ) {
				elem = this[i];
				if ( elem.style ) {
					display = jQuery.css( elem, "display" );

					if ( display !== "none" && !jQuery._data( elem, "olddisplay" ) ) {
						jQuery._data( elem, "olddisplay", display );
					}
				}
			}

			// Set the display of the elements in a second loop
			// to avoid the constant reflow
			for ( i = 0; i < j; i++ ) {
				if ( this[i].style ) {
					this[i].style.display = "none";
				}
			}

			return this;
		}
	},

	// Save the old toggle function
	_toggle: jQuery.fn.toggle,

	toggle: function( fn, fn2, callback ) {
		var bool = typeof fn === "boolean";

		if ( jQuery.isFunction(fn) && jQuery.isFunction(fn2) ) {
			this._toggle.apply( this, arguments );

		} else if ( fn == null || bool ) {
			this.each(function() {
				var state = bool ? fn : jQuery(this).is(":hidden");
				jQuery(this)[ state ? "show" : "hide" ]();
			});

		} else {
			this.animate(genFx("toggle", 3), fn, fn2, callback);
		}

		return this;
	},

	fadeTo: function( speed, to, easing, callback ) {
		return this.filter(":hidden").css("opacity", 0).show().end()
					.animate({opacity: to}, speed, easing, callback);
	},

	animate: function( prop, speed, easing, callback ) {
		var optall = jQuery.speed( speed, easing, callback );

		if ( jQuery.isEmptyObject( prop ) ) {
			return this.each( optall.complete, [ false ] );
		}

		// Do not change referenced properties as per-property easing will be lost
		prop = jQuery.extend( {}, prop );

		function doAnimation() {
			// XXX 'this' does not always have a nodeName when running the
			// test suite

			if ( optall.queue === false ) {
				jQuery._mark( this );
			}

			var opt = jQuery.extend( {}, optall ),
				isElement = this.nodeType === 1,
				hidden = isElement && jQuery(this).is(":hidden"),
				name, val, p, e,
				parts, start, end, unit,
				method;

			// will store per property easing and be used to determine when an animation is complete
			opt.animatedProperties = {};

			for ( p in prop ) {

				// property name normalization
				name = jQuery.camelCase( p );
				if ( p !== name ) {
					prop[ name ] = prop[ p ];
					delete prop[ p ];
				}

				val = prop[ name ];

				// easing resolution: per property > opt.specialEasing > opt.easing > 'swing' (default)
				if ( jQuery.isArray( val ) ) {
					opt.animatedProperties[ name ] = val[ 1 ];
					val = prop[ name ] = val[ 0 ];
				} else {
					opt.animatedProperties[ name ] = opt.specialEasing && opt.specialEasing[ name ] || opt.easing || 'swing';
				}

				if ( val === "hide" && hidden || val === "show" && !hidden ) {
					return opt.complete.call( this );
				}

				if ( isElement && ( name === "height" || name === "width" ) ) {
					// Make sure that nothing sneaks out
					// Record all 3 overflow attributes because IE does not
					// change the overflow attribute when overflowX and
					// overflowY are set to the same value
					opt.overflow = [ this.style.overflow, this.style.overflowX, this.style.overflowY ];

					// Set display property to inline-block for height/width
					// animations on inline elements that are having width/height animated
					if ( jQuery.css( this, "display" ) === "inline" &&
							jQuery.css( this, "float" ) === "none" ) {

						// inline-level elements accept inline-block;
						// block-level elements need to be inline with layout
						if ( !jQuery.support.inlineBlockNeedsLayout || defaultDisplay( this.nodeName ) === "inline" ) {
							this.style.display = "inline-block";

						} else {
							this.style.zoom = 1;
						}
					}
				}
			}

			if ( opt.overflow != null ) {
				this.style.overflow = "hidden";
			}

			for ( p in prop ) {
				e = new jQuery.fx( this, opt, p );
				val = prop[ p ];

				if ( rfxtypes.test( val ) ) {

					// Tracks whether to show or hide based on private
					// data attached to the element
					method = jQuery._data( this, "toggle" + p ) || ( val === "toggle" ? hidden ? "show" : "hide" : 0 );
					if ( method ) {
						jQuery._data( this, "toggle" + p, method === "show" ? "hide" : "show" );
						e[ method ]();
					} else {
						e[ val ]();
					}

				} else {
					parts = rfxnum.exec( val );
					start = e.cur();

					if ( parts ) {
						end = parseFloat( parts[2] );
						unit = parts[3] || ( jQuery.cssNumber[ p ] ? "" : "px" );

						// We need to compute starting value
						if ( unit !== "px" ) {
							jQuery.style( this, p, (end || 1) + unit);
							start = ( (end || 1) / e.cur() ) * start;
							jQuery.style( this, p, start + unit);
						}

						// If a +=/-= token was provided, we're doing a relative animation
						if ( parts[1] ) {
							end = ( (parts[ 1 ] === "-=" ? -1 : 1) * end ) + start;
						}

						e.custom( start, end, unit );

					} else {
						e.custom( start, val, "" );
					}
				}
			}

			// For JS strict compliance
			return true;
		}

		return optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},

	stop: function( type, clearQueue, gotoEnd ) {
		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var index,
				hadTimers = false,
				timers = jQuery.timers,
				data = jQuery._data( this );

			// clear marker counters if we know they won't be
			if ( !gotoEnd ) {
				jQuery._unmark( true, this );
			}

			function stopQueue( elem, data, index ) {
				var hooks = data[ index ];
				jQuery.removeData( elem, index, true );
				hooks.stop( gotoEnd );
			}

			if ( type == null ) {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && index.indexOf(".run") === index.length - 4 ) {
						stopQueue( this, data, index );
					}
				}
			} else if ( data[ index = type + ".run" ] && data[ index ].stop ){
				stopQueue( this, data, index );
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					if ( gotoEnd ) {

						// force the next step to be the last
						timers[ index ]( true );
					} else {
						timers[ index ].saveState();
					}
					hadTimers = true;
					timers.splice( index, 1 );
				}
			}

			// start the next in the queue if the last step wasn't forced
			// timers currently will call their complete callbacks, which will dequeue
			// but only if they were gotoEnd
			if ( !( gotoEnd && hadTimers ) ) {
				jQuery.dequeue( this, type );
			}
		});
	}

});

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout( clearFxNow, 0 );
	return ( fxNow = jQuery.now() );
}

function clearFxNow() {
	fxNow = undefined;
}

// Generate parameters to create a standard animation
function genFx( type, num ) {
	var obj = {};

	jQuery.each( fxAttrs.concat.apply([], fxAttrs.slice( 0, num )), function() {
		obj[ this ] = type;
	});

	return obj;
}

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx( "show", 1 ),
	slideUp: genFx( "hide", 1 ),
	slideToggle: genFx( "toggle", 1 ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.extend({
	speed: function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};

		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
			opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

		// normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function( noUnmark ) {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			} else if ( noUnmark !== false ) {
				jQuery._unmark( this );
			}
		};

		return opt;
	},

	easing: {
		linear: function( p, n, firstNum, diff ) {
			return firstNum + diff * p;
		},
		swing: function( p, n, firstNum, diff ) {
			return ( ( -Math.cos( p*Math.PI ) / 2 ) + 0.5 ) * diff + firstNum;
		}
	},

	timers: [],

	fx: function( elem, options, prop ) {
		this.options = options;
		this.elem = elem;
		this.prop = prop;

		options.orig = options.orig || {};
	}

});

jQuery.fx.prototype = {
	// Simple function for setting a style value
	update: function() {
		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		( jQuery.fx.step[ this.prop ] || jQuery.fx.step._default )( this );
	},

	// Get the current size
	cur: function() {
		if ( this.elem[ this.prop ] != null && (!this.elem.style || this.elem.style[ this.prop ] == null) ) {
			return this.elem[ this.prop ];
		}

		var parsed,
			r = jQuery.css( this.elem, this.prop );
		// Empty strings, null, undefined and "auto" are converted to 0,
		// complex values such as "rotate(1rad)" are returned as is,
		// simple values such as "10px" are parsed to Float.
		return isNaN( parsed = parseFloat( r ) ) ? !r || r === "auto" ? 0 : r : parsed;
	},

	// Start an animation from one number to another
	custom: function( from, to, unit ) {
		var self = this,
			fx = jQuery.fx;

		this.startTime = fxNow || createFxNow();
		this.end = to;
		this.now = this.start = from;
		this.pos = this.state = 0;
		this.unit = unit || this.unit || ( jQuery.cssNumber[ this.prop ] ? "" : "px" );

		function t( gotoEnd ) {
			return self.step( gotoEnd );
		}

		t.queue = this.options.queue;
		t.elem = this.elem;
		t.saveState = function() {
			if ( self.options.hide && jQuery._data( self.elem, "fxshow" + self.prop ) === undefined ) {
				jQuery._data( self.elem, "fxshow" + self.prop, self.start );
			}
		};

		if ( t() && jQuery.timers.push(t) && !timerId ) {
			timerId = setInterval( fx.tick, fx.interval );
		}
	},

	// Simple 'show' function
	show: function() {
		var dataShow = jQuery._data( this.elem, "fxshow" + this.prop );

		// Remember where we started, so that we can go back to it later
		this.options.orig[ this.prop ] = dataShow || jQuery.style( this.elem, this.prop );
		this.options.show = true;

		// Begin the animation
		// Make sure that we start at a small width/height to avoid any flash of content
		if ( dataShow !== undefined ) {
			// This show is picking up where a previous hide or show left off
			this.custom( this.cur(), dataShow );
		} else {
			this.custom( this.prop === "width" || this.prop === "height" ? 1 : 0, this.cur() );
		}

		// Start by showing the element
		jQuery( this.elem ).show();
	},

	// Simple 'hide' function
	hide: function() {
		// Remember where we started, so that we can go back to it later
		this.options.orig[ this.prop ] = jQuery._data( this.elem, "fxshow" + this.prop ) || jQuery.style( this.elem, this.prop );
		this.options.hide = true;

		// Begin the animation
		this.custom( this.cur(), 0 );
	},

	// Each step of an animation
	step: function( gotoEnd ) {
		var p, n, complete,
			t = fxNow || createFxNow(),
			done = true,
			elem = this.elem,
			options = this.options;

		if ( gotoEnd || t >= options.duration + this.startTime ) {
			this.now = this.end;
			this.pos = this.state = 1;
			this.update();

			options.animatedProperties[ this.prop ] = true;

			for ( p in options.animatedProperties ) {
				if ( options.animatedProperties[ p ] !== true ) {
					done = false;
				}
			}

			if ( done ) {
				// Reset the overflow
				if ( options.overflow != null && !jQuery.support.shrinkWrapBlocks ) {

					jQuery.each( [ "", "X", "Y" ], function( index, value ) {
						elem.style[ "overflow" + value ] = options.overflow[ index ];
					});
				}

				// Hide the element if the "hide" operation was done
				if ( options.hide ) {
					jQuery( elem ).hide();
				}

				// Reset the properties, if the item has been hidden or shown
				if ( options.hide || options.show ) {
					for ( p in options.animatedProperties ) {
						jQuery.style( elem, p, options.orig[ p ] );
						jQuery.removeData( elem, "fxshow" + p, true );
						// Toggle data is no longer needed
						jQuery.removeData( elem, "toggle" + p, true );
					}
				}

				// Execute the complete function
				// in the event that the complete function throws an exception
				// we must ensure it won't be called twice. #5684

				complete = options.complete;
				if ( complete ) {

					options.complete = false;
					complete.call( elem );
				}
			}

			return false;

		} else {
			// classical easing cannot be used with an Infinity duration
			if ( options.duration == Infinity ) {
				this.now = t;
			} else {
				n = t - this.startTime;
				this.state = n / options.duration;

				// Perform the easing function, defaults to swing
				this.pos = jQuery.easing[ options.animatedProperties[this.prop] ]( this.state, n, 0, 1, options.duration );
				this.now = this.start + ( (this.end - this.start) * this.pos );
			}
			// Perform the next step of the animation
			this.update();
		}

		return true;
	}
};

jQuery.extend( jQuery.fx, {
	tick: function() {
		var timer,
			timers = jQuery.timers,
			i = 0;

		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];
			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
	},

	interval: 13,

	stop: function() {
		clearInterval( timerId );
		timerId = null;
	},

	speeds: {
		slow: 600,
		fast: 200,
		// Default speed
		_default: 400
	},

	step: {
		opacity: function( fx ) {
			jQuery.style( fx.elem, "opacity", fx.now );
		},

		_default: function( fx ) {
			if ( fx.elem.style && fx.elem.style[ fx.prop ] != null ) {
				fx.elem.style[ fx.prop ] = fx.now + fx.unit;
			} else {
				fx.elem[ fx.prop ] = fx.now;
			}
		}
	}
});

// Adds width/height step functions
// Do not set anything below 0
jQuery.each([ "width", "height" ], function( i, prop ) {
	jQuery.fx.step[ prop ] = function( fx ) {
		jQuery.style( fx.elem, prop, Math.max(0, fx.now) + fx.unit );
	};
});

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep(jQuery.timers, function( fn ) {
			return elem === fn.elem;
		}).length;
	};
}

// Try to restore the default display value of an element
function defaultDisplay( nodeName ) {

	if ( !elemdisplay[ nodeName ] ) {

		var body = document.body,
			elem = jQuery( "<" + nodeName + ">" ).appendTo( body ),
			display = elem.css( "display" );
		elem.remove();

		// If the simple way fails,
		// get element's real default display by attaching it to a temp iframe
		if ( display === "none" || display === "" ) {
			// No iframe to use yet, so create it
			if ( !iframe ) {
				iframe = document.createElement( "iframe" );
				iframe.frameBorder = iframe.width = iframe.height = 0;
			}

			body.appendChild( iframe );

			// Create a cacheable copy of the iframe document on first call.
			// IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
			// document to it; WebKit & Firefox won't allow reusing the iframe document.
			if ( !iframeDoc || !iframe.createElement ) {
				iframeDoc = ( iframe.contentWindow || iframe.contentDocument ).document;
				iframeDoc.write( ( document.compatMode === "CSS1Compat" ? "<!doctype html>" : "" ) + "<html><body>" );
				iframeDoc.close();
			}

			elem = iframeDoc.createElement( nodeName );

			iframeDoc.body.appendChild( elem );

			display = jQuery.css( elem, "display" );
			body.removeChild( iframe );
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return elemdisplay[ nodeName ];
}




var rtable = /^t(?:able|d|h)$/i,
	rroot = /^(?:body|html)$/i;

if ( "getBoundingClientRect" in document.documentElement ) {
	jQuery.fn.offset = function( options ) {
		var elem = this[0], box;

		if ( options ) {
			return this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
		}

		if ( !elem || !elem.ownerDocument ) {
			return null;
		}

		if ( elem === elem.ownerDocument.body ) {
			return jQuery.offset.bodyOffset( elem );
		}

		try {
			box = elem.getBoundingClientRect();
		} catch(e) {}

		var doc = elem.ownerDocument,
			docElem = doc.documentElement;

		// Make sure we're not dealing with a disconnected DOM node
		if ( !box || !jQuery.contains( docElem, elem ) ) {
			return box ? { top: box.top, left: box.left } : { top: 0, left: 0 };
		}

		var body = doc.body,
			win = getWindow(doc),
			clientTop  = docElem.clientTop  || body.clientTop  || 0,
			clientLeft = docElem.clientLeft || body.clientLeft || 0,
			scrollTop  = win.pageYOffset || jQuery.support.boxModel && docElem.scrollTop  || body.scrollTop,
			scrollLeft = win.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft,
			top  = box.top  + scrollTop  - clientTop,
			left = box.left + scrollLeft - clientLeft;

		return { top: top, left: left };
	};

} else {
	jQuery.fn.offset = function( options ) {
		var elem = this[0];

		if ( options ) {
			return this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
		}

		if ( !elem || !elem.ownerDocument ) {
			return null;
		}

		if ( elem === elem.ownerDocument.body ) {
			return jQuery.offset.bodyOffset( elem );
		}

		var computedStyle,
			offsetParent = elem.offsetParent,
			prevOffsetParent = elem,
			doc = elem.ownerDocument,
			docElem = doc.documentElement,
			body = doc.body,
			defaultView = doc.defaultView,
			prevComputedStyle = defaultView ? defaultView.getComputedStyle( elem, null ) : elem.currentStyle,
			top = elem.offsetTop,
			left = elem.offsetLeft;

		while ( (elem = elem.parentNode) && elem !== body && elem !== docElem ) {
			if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
				break;
			}

			computedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;
			top  -= elem.scrollTop;
			left -= elem.scrollLeft;

			if ( elem === offsetParent ) {
				top  += elem.offsetTop;
				left += elem.offsetLeft;

				if ( jQuery.support.doesNotAddBorder && !(jQuery.support.doesAddBorderForTableAndCells && rtable.test(elem.nodeName)) ) {
					top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
					left += parseFloat( computedStyle.borderLeftWidth ) || 0;
				}

				prevOffsetParent = offsetParent;
				offsetParent = elem.offsetParent;
			}

			if ( jQuery.support.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== "visible" ) {
				top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
				left += parseFloat( computedStyle.borderLeftWidth ) || 0;
			}

			prevComputedStyle = computedStyle;
		}

		if ( prevComputedStyle.position === "relative" || prevComputedStyle.position === "static" ) {
			top  += body.offsetTop;
			left += body.offsetLeft;
		}

		if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
			top  += Math.max( docElem.scrollTop, body.scrollTop );
			left += Math.max( docElem.scrollLeft, body.scrollLeft );
		}

		return { top: top, left: left };
	};
}

jQuery.offset = {

	bodyOffset: function( body ) {
		var top = body.offsetTop,
			left = body.offsetLeft;

		if ( jQuery.support.doesNotIncludeMarginInBodyOffset ) {
			top  += parseFloat( jQuery.css(body, "marginTop") ) || 0;
			left += parseFloat( jQuery.css(body, "marginLeft") ) || 0;
		}

		return { top: top, left: left };
	},

	setOffset: function( elem, options, i ) {
		var position = jQuery.css( elem, "position" );

		// set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		var curElem = jQuery( elem ),
			curOffset = curElem.offset(),
			curCSSTop = jQuery.css( elem, "top" ),
			curCSSLeft = jQuery.css( elem, "left" ),
			calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
			props = {}, curPosition = {}, curTop, curLeft;

		// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;
		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	}
};


jQuery.fn.extend({

	position: function() {
		if ( !this[0] ) {
			return null;
		}

		var elem = this[0],

		// Get *real* offsetParent
		offsetParent = this.offsetParent(),

		// Get correct offsets
		offset       = this.offset(),
		parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

		// Subtract element margins
		// note: when an element has margin: auto the offsetLeft and marginLeft
		// are the same in Safari causing offset.left to incorrectly be 0
		offset.top  -= parseFloat( jQuery.css(elem, "marginTop") ) || 0;
		offset.left -= parseFloat( jQuery.css(elem, "marginLeft") ) || 0;

		// Add offsetParent borders
		parentOffset.top  += parseFloat( jQuery.css(offsetParent[0], "borderTopWidth") ) || 0;
		parentOffset.left += parseFloat( jQuery.css(offsetParent[0], "borderLeftWidth") ) || 0;

		// Subtract the two offsets
		return {
			top:  offset.top  - parentOffset.top,
			left: offset.left - parentOffset.left
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || document.body;
			while ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") ) {
				offsetParent = offsetParent.offsetParent;
			}
			return offsetParent;
		});
	}
});


// Create scrollLeft and scrollTop methods
jQuery.each( ["Left", "Top"], function( i, name ) {
	var method = "scroll" + name;

	jQuery.fn[ method ] = function( val ) {
		var elem, win;

		if ( val === undefined ) {
			elem = this[ 0 ];

			if ( !elem ) {
				return null;
			}

			win = getWindow( elem );

			// Return the scroll offset
			return win ? ("pageXOffset" in win) ? win[ i ? "pageYOffset" : "pageXOffset" ] :
				jQuery.support.boxModel && win.document.documentElement[ method ] ||
					win.document.body[ method ] :
				elem[ method ];
		}

		// Set the scroll offset
		return this.each(function() {
			win = getWindow( this );

			if ( win ) {
				win.scrollTo(
					!i ? val : jQuery( win ).scrollLeft(),
					 i ? val : jQuery( win ).scrollTop()
				);

			} else {
				this[ method ] = val;
			}
		});
	};
});

function getWindow( elem ) {
	return jQuery.isWindow( elem ) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
}




// Create width, height, innerHeight, innerWidth, outerHeight and outerWidth methods
jQuery.each([ "Height", "Width" ], function( i, name ) {

	var type = name.toLowerCase();

	// innerHeight and innerWidth
	jQuery.fn[ "inner" + name ] = function() {
		var elem = this[0];
		return elem ?
			elem.style ?
			parseFloat( jQuery.css( elem, type, "padding" ) ) :
			this[ type ]() :
			null;
	};

	// outerHeight and outerWidth
	jQuery.fn[ "outer" + name ] = function( margin ) {
		var elem = this[0];
		return elem ?
			elem.style ?
			parseFloat( jQuery.css( elem, type, margin ? "margin" : "border" ) ) :
			this[ type ]() :
			null;
	};

	jQuery.fn[ type ] = function( size ) {
		// Get window width or height
		var elem = this[0];
		if ( !elem ) {
			return size == null ? null : this;
		}

		if ( jQuery.isFunction( size ) ) {
			return this.each(function( i ) {
				var self = jQuery( this );
				self[ type ]( size.call( this, i, self[ type ]() ) );
			});
		}

		if ( jQuery.isWindow( elem ) ) {
			// Everyone else use document.documentElement or document.body depending on Quirks vs Standards mode
			// 3rd condition allows Nokia support, as it supports the docElem prop but not CSS1Compat
			var docElemProp = elem.document.documentElement[ "client" + name ],
				body = elem.document.body;
			return elem.document.compatMode === "CSS1Compat" && docElemProp ||
				body && body[ "client" + name ] || docElemProp;

		// Get document width or height
		} else if ( elem.nodeType === 9 ) {
			// Either scroll[Width/Height] or offset[Width/Height], whichever is greater
			return Math.max(
				elem.documentElement["client" + name],
				elem.body["scroll" + name], elem.documentElement["scroll" + name],
				elem.body["offset" + name], elem.documentElement["offset" + name]
			);

		// Get or set width or height on the element
		} else if ( size === undefined ) {
			var orig = jQuery.css( elem, type ),
				ret = parseFloat( orig );

			return jQuery.isNumeric( ret ) ? ret : orig;

		// Set the width or height on the element (default to pixels if value is unitless)
		} else {
			return this.css( type, typeof size === "string" ? size : size + "px" );
		}
	};

});




// Expose jQuery to the global object
window.jQuery = window.$ = jQuery;

// Expose jQuery as an AMD module, but only for AMD loaders that
// understand the issues with loading multiple versions of jQuery
// in a page that all might call define(). The loader will indicate
// they have special allowances for multiple jQuery versions by
// specifying define.amd.jQuery = true. Register as a named module,
// since jQuery can be concatenated with other files that may use define,
// but not use a proper concatenation script that understands anonymous
// AMD modules. A named AMD is safest and most robust way to register.
// Lowercase jquery is used because AMD module names are derived from
// file names, and jQuery is normally delivered in a lowercase file name.
// Do this after creating the global so that if an AMD module wants to call
// noConflict to hide this version of jQuery, it will work.
if ( typeof define === "function" && define.amd && define.amd.jQuery ) {
	define( "jquery", [], function () { return jQuery; } );
}



})( window );

/*
 * jQuery UI Position 1.8.17
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Position
 */
(function( $, undefined ) {

$.ui = $.ui || {};

var horizontalPositions = /left|center|right/,
	verticalPositions = /top|center|bottom/,
	center = "center",
	support = {},
	_position = $.fn.position,
	_offset = $.fn.offset;

$.fn.position = function( options ) {
	if ( !options || !options.of ) {
		return _position.apply( this, arguments );
	}

	// make a copy, we don't want to modify arguments
	options = $.extend( {}, options );

	var target = $( options.of ),
		targetElem = target[0],
		collision = ( options.collision || "flip" ).split( " " ),
		offset = options.offset ? options.offset.split( " " ) : [ 0, 0 ],
		targetWidth,
		targetHeight,
		basePosition;

	if ( targetElem.nodeType === 9 ) {
		targetWidth = target.width();
		targetHeight = target.height();
		basePosition = { top: 0, left: 0 };
	// TODO: use $.isWindow() in 1.9
	} else if ( targetElem.setTimeout ) {
		targetWidth = target.width();
		targetHeight = target.height();
		basePosition = { top: target.scrollTop(), left: target.scrollLeft() };
	} else if ( targetElem.preventDefault ) {
		// force left top to allow flipping
		options.at = "left top";
		targetWidth = targetHeight = 0;
		basePosition = { top: options.of.pageY, left: options.of.pageX };
	} else {
		targetWidth = target.outerWidth();
		targetHeight = target.outerHeight();
		basePosition = target.offset();
	}

	// force my and at to have valid horizontal and veritcal positions
	// if a value is missing or invalid, it will be converted to center 
	$.each( [ "my", "at" ], function() {
		var pos = ( options[this] || "" ).split( " " );
		if ( pos.length === 1) {
			pos = horizontalPositions.test( pos[0] ) ?
				pos.concat( [center] ) :
				verticalPositions.test( pos[0] ) ?
					[ center ].concat( pos ) :
					[ center, center ];
		}
		pos[ 0 ] = horizontalPositions.test( pos[0] ) ? pos[ 0 ] : center;
		pos[ 1 ] = verticalPositions.test( pos[1] ) ? pos[ 1 ] : center;
		options[ this ] = pos;
	});

	// normalize collision option
	if ( collision.length === 1 ) {
		collision[ 1 ] = collision[ 0 ];
	}

	// normalize offset option
	offset[ 0 ] = parseInt( offset[0], 10 ) || 0;
	if ( offset.length === 1 ) {
		offset[ 1 ] = offset[ 0 ];
	}
	offset[ 1 ] = parseInt( offset[1], 10 ) || 0;

	if ( options.at[0] === "right" ) {
		basePosition.left += targetWidth;
	} else if ( options.at[0] === center ) {
		basePosition.left += targetWidth / 2;
	}

	if ( options.at[1] === "bottom" ) {
		basePosition.top += targetHeight;
	} else if ( options.at[1] === center ) {
		basePosition.top += targetHeight / 2;
	}

	basePosition.left += offset[ 0 ];
	basePosition.top += offset[ 1 ];

	return this.each(function() {
		var elem = $( this ),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			marginLeft = parseInt( $.curCSS( this, "marginLeft", true ) ) || 0,
			marginTop = parseInt( $.curCSS( this, "marginTop", true ) ) || 0,
			collisionWidth = elemWidth + marginLeft +
				( parseInt( $.curCSS( this, "marginRight", true ) ) || 0 ),
			collisionHeight = elemHeight + marginTop +
				( parseInt( $.curCSS( this, "marginBottom", true ) ) || 0 ),
			position = $.extend( {}, basePosition ),
			collisionPosition;

		if ( options.my[0] === "right" ) {
			position.left -= elemWidth;
		} else if ( options.my[0] === center ) {
			position.left -= elemWidth / 2;
		}

		if ( options.my[1] === "bottom" ) {
			position.top -= elemHeight;
		} else if ( options.my[1] === center ) {
			position.top -= elemHeight / 2;
		}

		// prevent fractions if jQuery version doesn't support them (see #5280)
		if ( !support.fractions ) {
			position.left = Math.round( position.left );
			position.top = Math.round( position.top );
		}

		collisionPosition = {
			left: position.left - marginLeft,
			top: position.top - marginTop
		};

		$.each( [ "left", "top" ], function( i, dir ) {
			if ( $.ui.position[ collision[i] ] ) {
				$.ui.position[ collision[i] ][ dir ]( position, {
					targetWidth: targetWidth,
					targetHeight: targetHeight,
					elemWidth: elemWidth,
					elemHeight: elemHeight,
					collisionPosition: collisionPosition,
					collisionWidth: collisionWidth,
					collisionHeight: collisionHeight,
					offset: offset,
					my: options.my,
					at: options.at
				});
			}
		});

		if ( $.fn.bgiframe ) {
			elem.bgiframe();
		}
		elem.offset( $.extend( position, { using: options.using } ) );
	});
};

$.ui.position = {
	fit: {
		left: function( position, data ) {
			var win = $( window ),
				over = data.collisionPosition.left + data.collisionWidth - win.width() - win.scrollLeft();
			position.left = over > 0 ? position.left - over : Math.max( position.left - data.collisionPosition.left, position.left );
		},
		top: function( position, data ) {
			var win = $( window ),
				over = data.collisionPosition.top + data.collisionHeight - win.height() - win.scrollTop();
			position.top = over > 0 ? position.top - over : Math.max( position.top - data.collisionPosition.top, position.top );
		}
	},

	flip: {
		left: function( position, data ) {
			if ( data.at[0] === center ) {
				return;
			}
			var win = $( window ),
				over = data.collisionPosition.left + data.collisionWidth - win.width() - win.scrollLeft(),
				myOffset = data.my[ 0 ] === "left" ?
					-data.elemWidth :
					data.my[ 0 ] === "right" ?
						data.elemWidth :
						0,
				atOffset = data.at[ 0 ] === "left" ?
					data.targetWidth :
					-data.targetWidth,
				offset = -2 * data.offset[ 0 ];
			position.left += data.collisionPosition.left < 0 ?
				myOffset + atOffset + offset :
				over > 0 ?
					myOffset + atOffset + offset :
					0;
		},
		top: function( position, data ) {
			if ( data.at[1] === center ) {
				return;
			}
			var win = $( window ),
				over = data.collisionPosition.top + data.collisionHeight - win.height() - win.scrollTop(),
				myOffset = data.my[ 1 ] === "top" ?
					-data.elemHeight :
					data.my[ 1 ] === "bottom" ?
						data.elemHeight :
						0,
				atOffset = data.at[ 1 ] === "top" ?
					data.targetHeight :
					-data.targetHeight,
				offset = -2 * data.offset[ 1 ];
			position.top += data.collisionPosition.top < 0 ?
				myOffset + atOffset + offset :
				over > 0 ?
					myOffset + atOffset + offset :
					0;
		}
	}
};

// offset setter from jQuery 1.4
if ( !$.offset.setOffset ) {
	$.offset.setOffset = function( elem, options ) {
		// set position first, in-case top/left are set even on static elem
		if ( /static/.test( $.curCSS( elem, "position" ) ) ) {
			elem.style.position = "relative";
		}
		var curElem   = $( elem ),
			curOffset = curElem.offset(),
			curTop    = parseInt( $.curCSS( elem, "top",  true ), 10 ) || 0,
			curLeft   = parseInt( $.curCSS( elem, "left", true ), 10)  || 0,
			props     = {
				top:  (options.top  - curOffset.top)  + curTop,
				left: (options.left - curOffset.left) + curLeft
			};
		
		if ( 'using' in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	};

	$.fn.offset = function( options ) {
		var elem = this[ 0 ];
		if ( !elem || !elem.ownerDocument ) { return null; }
		if ( options ) { 
			return this.each(function() {
				$.offset.setOffset( this, options );
			});
		}
		return _offset.call( this );
	};
}

// fraction support test (older versions of jQuery don't support fractions)
(function () {
	var body = document.getElementsByTagName( "body" )[ 0 ], 
		div = document.createElement( "div" ),
		testElement, testElementParent, testElementStyle, offset, offsetTotal;

	//Create a "fake body" for testing based on method used in jQuery.support
	testElement = document.createElement( body ? "div" : "body" );
	testElementStyle = {
		visibility: "hidden",
		width: 0,
		height: 0,
		border: 0,
		margin: 0,
		background: "none"
	};
	if ( body ) {
		jQuery.extend( testElementStyle, {
			position: "absolute",
			left: "-1000px",
			top: "-1000px"
		});
	}
	for ( var i in testElementStyle ) {
		testElement.style[ i ] = testElementStyle[ i ];
	}
	testElement.appendChild( div );
	testElementParent = body || document.documentElement;
	testElementParent.insertBefore( testElement, testElementParent.firstChild );

	div.style.cssText = "position: absolute; left: 10.7432222px; top: 10.432325px; height: 30px; width: 201px;";

	offset = $( div ).offset( function( _, offset ) {
		return offset;
	}).offset();

	testElement.innerHTML = "";
	testElementParent.removeChild( testElement );

	offsetTotal = offset.top + offset.left + ( body ? 2000 : 0 );
	support.fractions = offsetTotal > 21 && offsetTotal < 22;
})();

}( jQuery ));

/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/**
 * @class Provides base functionality of the SAP jQuery plugin as extension of the jQuery framework.<br/>
 * See also <a href="http://api.jquery.com/jQuery/">jQuery</a> for details.<br/>
 * Although these functions appear as static ones, they are meant to be used on jQuery instances.<br/>
 * If not stated differently, the functions follow the fluent interface paradigm and return the jQuery instance for chaining of statements.
 *
 * Example for usage of an instance method:
 * <pre>
 *   var oRect = jQuery("#myDiv").rect();
 *   alert("Top Position: " + oRect.top);
 * </pre>
 *
 * @name jQuery
 * @static
 * @public
 */

(function() {
	//ensure not to initialize twice
	// one could also provide more specific tests but as global should come first this would be over-engineered
	//if(jQuery.sap && jQuery.sap.includeScript && jQuery.sap.includeStyleSheet) {
	if (jQuery.sap) {
		return;
	}

	// Fixes the CORS issue (introduced by jQuery 1.7) when loading resources
	// (e.g. SAPUI5 script) from other domains for IE browsers.
	// The CORS check in jQuery filters out such browsers who do not have the
	// property "withCredentials" which is the IE and Opera and prevents those
	// browsers to request data from other domains with jQuery.ajax. The CORS
	// requests are simply forbidden nevertheless if it works. In our case we
	// simply load our script resources from another domain when using the CDN
	// variant of SAPUI5. The following fix is also recommended by jQuery:
	if (jQuery.browser.msie) {
		jQuery.support.cors = true;
	}


	/**
	 * Window that the sap plugin has been initialized for.
	 * @private
	 */
	var _window = window;

	var _earlyErrors = [];

	var _sBootstrapUrl = undefined;

	/**
	 * Find the script URL where the SAPUI5 is loaded from and return an object which
	 * contains the identified script-tag and resource root
	 */
	var _oBootstrap = (function() {
		var oTag, sUrl, sResourceRoot,
			reConfigurator = /\/download\/configurator[\/\?]/,
			reBootScripts = /\/(sap-ui-(core|custom|boot)(-.*)?)\.js(\W|$)/,
			reResources = /^(.*\/)?resources\//;

		// check all script tags that have a src attribute
		jQuery("script[src]").each(function() {
			var src = this.getAttribute("src"),
				m;
			if ( m = src.match(reConfigurator) ) {
				// guess 1: script tag src contains "/download/configurator[/?]" (for dynamically created bootstrap files)
				oTag = this;
				sUrl = src;
				sResourceRoot = src.substring(0, m.index) + "/resources/";
				return false;
			} else if ( m = src.match(reBootScripts) ) {
				// guess 2: src contains one of the well known boot script names
				oTag = this;
				sUrl = src;
				sResourceRoot = src.substring(0, m.index) + "/";
				return false;
			} else if ( this.id == 'sap-ui-bootstrap' && (m=src.match(reResources)) ) {
				// guess 2: script tag has well known id and src contains "resources/"
				oTag = this;
				sUrl = src;
				sResourceRoot = m[0];
				return false;
			}
		});
		return {
			tag: oTag,
			url: sUrl,
			resourceRoot: sResourceRoot
		}
	})();

	/**
	 * Determine whether sap-bootstrap-debug is set, run debugger statement and allow
	 * to restart the core from a new URL
	 */
	(function() {
		if (/sap-bootstrap-debug=(true|x|X)/.test(location.search)) {
			var bRestart = false,
				sRestartUrl = "http://localhost:8080/sapui5/resources/sap-ui-core.js";

			// function to replace the bootstrap tag with a newly created script tag to enable
			// restarting the core from a different server
			function restartCore() {
				var oScript = _oBootstrap.tag,
					sScript = "<script src=\"" + sRestartUrl + "\"";
				jQuery.each(oScript.attributes, function(i, oAttr) {
					if (oAttr.nodeName.indexOf("data-sap-ui-") == 0) {
						sScript += " " + oAttr.nodeName + "=\"" + oAttr.nodeValue + "\"";
					}
				});
				sScript += "></script>";
				oScript.parentNode.removeChild(oScript);
				document.write(sScript);
				var oRestart = new Error("Aborting UI5 bootstrap and restarting from: " + sRestartUrl);
				oRestart.name = "Restart";
				throw oRestart;
			};

			// debugger stops here. if you want to restart from a different server you can adapt the URL
			// here and set bRestart to true.
			debugger;
			if (bRestart) {
				restartCore();
			}
		}
	})();

	/**
	 * Determine whether to use debug sources depending on URL parameter and local storage
	 * and load debug library if necessary
	 */
	(function() {
		//Check URI param
		var bDebugSources = /sap-ui-debug=(true|x|X)/.test(location.search),
			bIsOptimized = window["sap-ui-optimized"];

		//Check local storage
		try { //Necessary for FF when Cookies are deactivated
			bDebugSources = bDebugSources || (window.localStorage.getItem("sap-ui-debug") == "X");
		} catch(e) {}

		// if bootstap URL already contains -dbg URL, just set sap-ui-loaddbg
		if (/-dbg\.js$/.test(_oBootstrap.url)) {
			window["sap-ui-loaddbg"] = true;
		}

		// if current sources are optimized and debug sources are wanted, restart with debug URL
		if (bIsOptimized && bDebugSources) {
			var sDebugUrl = _oBootstrap.url.replace(/\/(?:sap-ui-cachebuster\/)?([^\/]+)\.js/, "/$1-dbg.js");
			window["sap-ui-optimized"] = false;
			window["sap-ui-loaddbg"] = true;
			document.write("<script type=\"text/javascript\" src=\"" + sDebugUrl + "\"></script>");
			var oRestart = new Error("Aborting UI5 bootstrap and restarting from: " + sDebugUrl);
			oRestart.name = "Restart";
			throw oRestart;
		}
	})();

	/*
	 * Merged, raw (un-interpreted) configuration data from the following sources
	 * (last one wins)
	 * <ol>
	 * <li>global configuration object <code>window["sap-ui-config"]</code>
	 * <li><code>data-sap-ui-config</code> attribute of the bootstrap script tag
	 * <li>other <code>data-sap-ui-<i>xyz</i></code> attributes of the bootstrap tag
	 * </ol>
	 */
	var oCfgData = _window["sap-ui-config"] = (function() {

		function normalize(o) {
			jQuery.each(o, function(i, v) {
				var il=i.toLowerCase();
				if ( !o.hasOwnProperty(il) ) {
					o[il] = v;
					delete o[i];
				}
			});
			return o;
		}

		var oCfg = normalize(_window["sap-ui-config"] || {}),
			oScriptTag = _oBootstrap.tag;

		oCfg.resourceroots = oCfg.resourceroots || {};
		oCfg.themeroots = oCfg.themeroots || {};
		oCfg.resourceroots[''] = oCfg.resourceroots[''] || _oBootstrap.resourceRoot;

		oCfg['xx-loadallmode'] = !!(_oBootstrap.url && _oBootstrap.url.match(/(^|\/)(sap-?ui5|[^\/]+-all).js$/));

		// if a script tag has been identified, collect its configuration info
		if ( oScriptTag ) {
			// evaluate the config attribute first - if present
			var sConfig = oScriptTag.getAttribute("data-sap-ui-config");
			if ( sConfig ) {
				try {
				  jQuery.extend(oCfg, normalize((new Function("return {" + sConfig + "};"))())); // TODO jQuery.parseJSON would be better but imposes unwanted restrictions on valid syntax
				} catch(e) {
				  // no log yet, how to report this error?
				  _earlyErrors.push("failed to parse data-sap-ui-config attribute: " + (e.message || e));
				}
			}

			// merge with any existing "data-sap-ui-" attributes
			jQuery.each(oScriptTag.attributes, function(i, attr) {
				var m = attr.name.match(/^data-sap-ui-(.*)$/);
				if ( m ) {
					// the following (deactivated) conversion would implement multi-word names like "resource-roots"
					m = m[1].toLowerCase(); // .replace(/\-([a-z])/g, function(s,w) { return w.toUpperCase(); })
					if ( m === 'resourceroots' ) {
						// merge map entries instead of overwriting map
						jQuery.extend(oCfg[m], jQuery.parseJSON(attr.value));
					} else if ( m === 'theme-roots' ) {
						// merge map entries, but rename to camelCase
						jQuery.extend(oCfg.themeroots, jQuery.parseJSON(attr.value));
					} else if ( m !== 'config' ) {
						oCfg[m] = attr.value;
					}
				}
			});
		}

		return oCfg;
	}());

	// check whether noConflict must be used...
	if ( oCfgData.noconflict === true || oCfgData.noconflict === "true"  || oCfgData.noconflict === "x" ) {
		jQuery.noConflict();
	}

	/**
	 * Root Namespace for the jQuery plug-in provided by SAP AG.
	 *
	 * @version 1.5.0-SNAPSHOT
	 * @namespace
	 * @public
	 * @static
	 */
	jQuery.sap = {};

	// -------------------------- DEBUG LOCAL STORAGE -------------------------------------

	jQuery.sap.debug = function(bEnable) {
		if(!window.localStorage){
			return null;
		}
		
		function reloadHint(bUsesDbgSrc){
			alert("Usage of debug sources is " + (bUsesDbgSrc ? "on" : "off") + " now.\nFor the change to take effect, you need to reload the page.");
		};

		if (bEnable === true) {
			window.localStorage.setItem("sap-ui-debug", "X");
			reloadHint(true);
		} else if (bEnable === false) {
			window.localStorage.removeItem("sap-ui-debug");
			reloadHint(false);
		}

		return window.localStorage.getItem("sap-ui-debug") == "X";
	};

	// -------------------------- Logging -------------------------------------

	(function() {

		var FATAL=0, ERROR=1, WARNING=2, INFO=3, DEBUG=4, TRACE=5;

		/**
		 * Unique prefix for this instance of the core in a multi-frame environment.
		 */
		var sWindowName = (window.top == window) ? "" : "[" + window.location.pathname.split('/').slice(-1)[0] + "] ";
		// Note: comparison must use type coercion (==, not ===), otherwise test fails in IE

		/**
		 * The array that holds the log entries that have been recorded so far
		 */
		var aLog = [];

		/**
		 * Maximum log level to be recorded (per component).
		 */
		var mMaxLevel = { '' : ERROR };

		/**
		 * Registered listener to be informed about new log entries.
		 */
		var oListener = null;

		function pad0(i,w) { return ("000" + String(i)).slice(-w); }

		function level(sComponent) {
			return (!sComponent || isNaN(mMaxLevel[sComponent])) ? mMaxLevel[''] : mMaxLevel[sComponent];
		}
		
		function listener(){
			if(!oListener){
				oListener = {
					listeners: [],
					onLogEntry: function(oLogEntry){
						for(var i=0; i<oListener.listeners.length; i++){
							if(oListener.listeners[i].onLogEntry){
								oListener.listeners[i].onLogEntry(oLogEntry);
							}
						}
					},
					attach: function(oLogger, oLstnr){
						if(oLstnr){
							oListener.listeners.push(oLstnr);
							if(oLstnr.onAttachToLog){
								oLstnr.onAttachToLog(oLogger);
							}
						}
					},
					detach: function(oLogger, oLstnr){
						for(var i=0; i<oListener.listeners.length; i++){
							if(oListener.listeners[i] === oLstnr){
								if(oLstnr.onDetachFromLog){
									oLstnr.onDetachFromLog(oLogger);
								}
								oListener.listeners.splice(i,1);
								return;
							}
						}
					}
				};
			}
			return oListener;
		}

		/**
		 * Creates a new log entry depending on its level and component.
		 *
		 * If the given level is higher than the max level for the given component
		 * (or higher than the global level, if no component is given),
		 * then no entry is created.
		 */
		function log(iLevel, sMessage, sDetails, sComponent) {
			if (iLevel <= level(sComponent) ) {
				var oNow = new Date(),
					oLogEntry = {
						time     : pad0(oNow.getHours(),2)+":"+pad0(oNow.getMinutes(),2)+":"+pad0(oNow.getSeconds(),2),
						date     : pad0(oNow.getFullYear(),4) + "-" + pad0(oNow.getMonth()+1,2) + "-" + pad0(oNow.getDate(),2),
						timestamp: oNow.getTime(),
						level    : iLevel,
						message  : sMessage || "",
						details  : sDetails || "",
						component: sComponent || ""
					};
				aLog.push( oLogEntry );
				if (oListener) {
					oListener.onLogEntry(oLogEntry);
				}

				/*
				 * Console Log, also tries to log to the window.console, if available.
                 *
				 * Unfortunately, the support for window.console is quite different between the UI5 browsers. The most important differences are:
				 * - in IE (checked until IE9), the console object does not exist in a window, until the developer tools are opened for that window.
				 *   After opening the dev tools, the console remains available even when the tools are closed again. Only using a new window (or tab)
				 *   restores the old state without console.
				 *   When the console is available, it provides most standard methods, but not debug and trace
				 * - in FF3.6 the console is not available, until FireBug is opened. It disappears again, when fire bug is closed.
				 *   But when the settings for a web site are stored (convenience), the console remains open
				 *   When the console is available, it supports all relevant methods
				 * - in FF9.0, the console is always available, but method assert is only available when firebug is open
				 * - in Webkit browsers, the console object is always available and has all required methods
				 */
				
				 /* MJH: TRYING TO FIGURE OUT LOGGING. TEMP FOR NOW */
				 
				 if (window.console) { // in IE and FF, console might not exist; in FF it might even disappear
					var logText = oLogEntry.date + " " + oLogEntry.time + " " + sWindowName + oLogEntry.message + " - " + oLogEntry.details + " " + oLogEntry.component;
					switch(iLevel) {
					//case FATAL:
					//case ERROR: console.error(logText); break;
					//case WARNING: console.warn(logText); break;
					//case INFO: console.info(logText); break;
					//case DEBUG: console.debug ? console.debug(logText) : console.log(logText); break; // debug not available in IE, fallback to log
					//case TRACE: console.trace ? console.trace(logText) : console.log(logText); break; // trace not available in IE, fallback to log (no trace)
					}
				}
				return oLogEntry;
			}
		}

		/**
		 * @class A Logger class
		 * @param sDefaultComponent
		 * @name jQuery.sap.log.Logger
		 * @since 1.1.2
		 * @public
		 */
		function Logger(sDefaultComponent) {

			/**
			 * Creates a new fatal-level entry in the log with the given message, details and calling component.
			 *
			 * @param {string} sMessage Message text to display
			 * @param {string} [sDetails=""] Details about the message, might be omitted
			 * @param {string} [sComponent=""] Name of the component that produced the log entry
			 * @return {jQuery.sap.log.Logger} The log instance for method chaining
			 * @name jQuery.sap.log.Logger#fatal
			 * @function
			 * @public
			 * @SecSink {0 1 2|SECRET} Could expose secret data in logs
			 */
			this.fatal = function (sMessage, sDetails, sComponent) {
				log(FATAL, sMessage, sDetails, sComponent || sDefaultComponent);
				return this;
			};

			/**
			 * Creates a new error-level entry in the log with the given message, details and calling component.
			 *
			 * @param {string} sMessage Message text to display
			 * @param {string} [sDetails=""] Details about the message, might be omitted
			 * @param {string} [sComponent=""] Name of the component that produced the log entry
			 * @return {jQuery.sap.log.Logger} The log instance
			 * @name jQuery.sap.log.Logger#error
			 * @function
			 * @public
			 * @SecSink {0 1 2|SECRET} Could expose secret data in logs
			 */
			this.error = function error(sMessage, sDetails, sComponent) {
				log(ERROR, sMessage, sDetails, sComponent || sDefaultComponent);
				return this;
			};

			/**
			 * Creates a new warning-level entry in the log with the given message, details and calling component.
			 *
			 * @param {string} sMessage Message text to display
			 * @param {string} [sDetails=""] Details about the message, might be omitted
			 * @param {string} [sComponent=""] Name of the component that produced the log entry
			 * @return {jQuery.sap.log.Logger} The log instance
			 * @name jQuery.sap.log.Logger#warning
			 * @function
			 * @public
			 * @SecSink {0 1 2|SECRET} Could expose secret data in logs
			 */
			this.warning = function warning(sMessage, sDetails, sComponent) {
				log(WARNING, sMessage, sDetails, sComponent || sDefaultComponent);
				return this;
			};
			/**
			 * Creates a new info-level entry in the log with the given message, details and calling component.
			 *
			 * @param {string} sMessage Message text to display
			 * @param {string} [sDetails=""] Details about the message, might be omitted
			 * @param {string} [sComponent=""] Name of the component that produced the log entry
			 * @return {jQuery.sap.log.Logger} The log instance
			 * @name jQuery.sap.log.Logger#info
			 * @function
			 * @public
			 * @SecSink {0 1 2|SECRET} Could expose secret data in logs
			 */
			this.info = function info(sMessage, sDetails, sComponent) {
				log(INFO, sMessage, sDetails, sComponent || sDefaultComponent);
				return this;
			};
			/**
			 * Creates a new debug-level entry in the log with the given message, details and calling component.
			 *
			 * @param {string} sMessage Message text to display
			 * @param {string} [sDetails=""] Details about the message, might be omitted
			 * @param {string} [sComponent=""] Name of the component that produced the log entry
			 * @return {jQuery.sap.log.Logger} The log instance
			 * @name jQuery.sap.log.Logger#debug
			 * @function
			 * @public
			 * @SecSink {0 1 2|SECRET} Could expose secret data in logs
			 */
			this.debug = function debug(sMessage, sDetails, sComponent) {
				log(DEBUG, sMessage, sDetails, sComponent || sDefaultComponent);
				return this;
			};
			/**
			 * Creates a new trace-level entry in the log with the given message, details and calling component.
			 *
			 * @param {string} sMessage Message text to display
			 * @param {string} [sDetails=""] Details about the message, might be omitted
			 * @param {string} [sComponent=""] Name of the component that produced the log entry
			 * @return {jQuery.sap.log.Logger} The log-instance
			 * @name jQuery.sap.log.Logger#trace
			 * @function
			 * @public
			 * @SecSink {0 1 2|SECRET} Could expose secret data in logs
			 */
			this.trace = function trace(sMessage, sDetails, sComponent) {
				log(TRACE, sMessage, sDetails, sComponent || sDefaultComponent);
				return this;
			};

			/**
			 * Defines the maximum jQuery.sap.log.Level of log entries that will be recorded.
			 * Log entries with a higher (less important) log level will be omitted from the log.
			 * When a component name is given, the log level will be configured for that component
			 * only, otherwise the log level for the default component of this logger is set.
			 * For the global logger, the global default level is set.
			 *
			 * <b>Note</b>: Setting a global default log level has no impact on already defined
			 * component log levels. They always override the global default log level.
			 *
			 * @param {jQuery.sap.log.Level} iLogLevel
			 * @param {string} [sComponent] The log component to set the log level for.
			 * @return {jQuery.sap.log} The global logger to allow method chaining
			 * @name jQuery.sap.log.Logger#setLevel
			 * @function
			 * @public
			 */
			this.setLevel = function setLevel(iLogLevel, sComponent) {
				sComponent = sComponent || sDefaultComponent || '';
				mMaxLevel[sComponent] = iLogLevel;
				var mBackMapping = [];
				jQuery.each(jQuery.sap.log.LogLevel, function(idx, v){
					mBackMapping[v] = idx;
				});
				log(INFO, "Changing log level " + (sComponent ? "for '" + sComponent + "' " : "") + "to " + mBackMapping[iLogLevel], "", "jQuery.sap.log");
				return this;
			};

			/**
			 * Returns the log level currently effective for the given component.
			 * If no component is given or when no level has been configured for a
			 * given component, the log level for the default component of this logger is returned.
			 *
			 * @param {string} [sComponent] Name of the component to retrieve the log level for
			 * @return {int} The log level for the given component or the default log level
			 * @name jQuery.sap.log.Logger#getLevel
			 * @function
			 * @public
			 * @since 1.1.2
			 */
			this.getLevel = function getLevel(sComponent) {
				return level(sComponent || sDefaultComponent);
			};

		}

		/**
		 * A Logging API for JavaScript.
		 *
		 * Provides methods to manage a client-side log and to create entries in it. Each of the logging methods
		 * {@link jQuery.sap.log.#debug}, {@link jQuery.sap.log.#info}, {@link jQuery.sap.log.#warning},
		 * {@link jQuery.sap.log.#error} and {@link jQuery.sap.log.#fatal} creates and records a log entry,
		 * containing a timestamp, a log level, a message with details and a component info.
		 * The log level will be one of {@link jQuery.sap.log.Level} and equals the name of the concrete logging method.
		 *
		 * By using the {@link jQuery.sap.log#setLevel} method, consumers can determine the least important
		 * log level which should be recorded. Less important entries will be filtered out. (Note that higher numeric
		 * values represent less important levels). The initially set level depends on the mode that UI5 is running in.
		 * When the optimized sources are executed, the default level will be {@link jQuery.sap.log.Level.ERROR}.
		 * For normal (debug sources), the default level is {@link jQuery.sap.log.Level.DEBUG}.
		 *
		 * All logging methods allow to specify a <b>component</b>. These components are simple strings and
		 * don't have a special meaning to the UI5 framework. However they can be used to semantically group
		 * log entries that belong to the same software component (or feature). There are two APIs that help
		 * to manage logging for such a component. With <code>{@link jQuery.sap.log.getLogger}(sComponent)</code>,
		 * one can retrieve a logger that automatically adds the given <code>sComponent</code> as component
		 * parameter to each log entry, if no other component is specified. Typically, JavaScript code will
		 * retrieve such a logger once during startup and reuse it for the rest of its lifecycle.
		 * Second, the {@link jQuery.sap.log.Logger#setLevel}(iLevel, sComponent) method allows to set the log level
		 * for a specific component only. This allows a more fine granular control about the created logging entries.
		 * {@link jQuery.sap.log.Logger.getLevel} allows to retrieve the currently effective log level for a given
		 * component.
		 *
		 * {@link jQuery.sap.log#getLog} returns an array of the currently collected log entries.
		 *
		 * Furthermore, a listener can be registered to the log. It will be notified whenever a new entry
		 * is added to the log. The listener can be used for displaying log entries in a separate page area,
		 * or for sending it to some external target (server).
		 *
		 * @author SAP AG
		 * @since 0.9.0
		 * @namespace
		 * @public
		 * @borrows jQuery.sap.log.Logger#fatal as this.fatal
		 * @borrows jQuery.sap.log.Logger#error as this.error
		 * @borrows jQuery.sap.log.Logger#warning as this.warning
		 * @borrows jQuery.sap.log.Logger#info as this.info
		 * @borrows jQuery.sap.log.Logger#debug as this.debug
		 * @borrows jQuery.sap.log.Logger#trace as this.trace
		 * @borrows jQuery.sap.log.Logger#getLevel as this.getLevel
		 * @borrows jQuery.sap.log.Logger#setLevel as this.setLevel
		 */
		jQuery.sap.log = jQuery.extend(new Logger(), /** @lends jQuery.sap.log */ {

			/**
			 * Enumeration of the configurable log levels that a Logger should persist to the log.
			 *
			 * Only if the current LogLevel is higher than the level {@link jQuery.sap.log.Level} of the currently added log entry,
			 * then this very entry is permanently added to the log. Otherwise it is ignored.
			 * @see jQuery.sap.log.Logger#setLevel
			 * @namespace
			 * @public
			 */
			Level : {

				/**
				 * Do not log anything
				 * @public
				 */
				NONE : FATAL-1,

				/**
				 * Fatal level. Use this for logging unrecoverable situations
				 * @public
				 */
				FATAL : FATAL,

				/**
				 * Error level. Use this for logging of erroneous but still recoverable situations
				 * @public
				 */
				ERROR : ERROR,

				/**
				 * Warning level. Use this for logging unwanted but foreseen situations
				 * @public
				 */
				WARNING : WARNING,

				/**
				 * Info level. Use this for logging information of purely informative nature
				 * @public
				 */
				INFO : INFO,

				/**
				 * Debug level. Use this for logging information necessary for debugging
				 * @public
				 */
				DEBUG : DEBUG,

				/**
				 * Trace level. Use this for tracing the program flow.
				 * @public
				 */
				TRACE : TRACE, /* TODO Think about changing to 10 and thus to pull out of logging... -> Make tracing explicit */

				/**
				 * Trace level to log everything.
				 */
				ALL : (TRACE + 1) /* TODO if TRACE is changed to make sure this is 6 again. There would then be some special TRACE handling. */
			},

			/**
			 * Returns a {@link jQuery.sap.log.Logger} for the given component.
			 *
			 * The method might or might not return the same logger object across multiple calls.
			 * While loggers are assumed to be light weight objects, consumers should try to
			 * avoid redundant calls and instead keep references to already retrieved loggers.
			 *
			 * @param {string} sComponent Component to create the logger for
			 * @return {jQuery.sap.log.Logger} A logger for the component.
			 * @public
			 * @static
			 * @since 1.1.2
			 */
			getLogger : function(sComponent) {
				return new Logger(sComponent);
			},

			/**
			 * Returns the logged entries recorded so far as an array.
			 *
			 * Log entries are plain JavaScript objects with the following properties
			 * <ul>
			 * <li>timestamp {number} point in time when the entry was created
			 * <li>level {int} LogLevel level of the entry
			 * <li>message {string} message text of the entry
			 * </ul>
			 *
			 * @return {object[]} an array containing the recorded log entries
			 * @public
			 * @static
			 * @since 1.1.2
			 */
			getLogEntries : function () {
				return aLog.slice();
			},
			
			/**
			 * Allows to add a new LogListener that will be notified for new log entries.
			 * The given object must provide method <code>onLogEntry</code> and can also be informed
			 * about <code>onDetachFromLog</code> and <code>onAttachToLog</code>
			 * @param {object} oListener The new listener object that should be informed
			 * @return {jQuery.sap.log} The global logger
			 * @public
			 * @static
			 */
			addLogListener : function(oListener) {
				listener().attach(this, oListener);
				return this;
			},
			
			/**
			 * Allows to remove a registered LogListener.
			 * @param {object} oListener The new listener object that should be removed
			 * @return {jQuery.sap.log} The global logger
			 * @public
			 * @static
			 */
			removeLogListener : function(oListener) {
				listener().detach(this, oListener);
				return this;
			}
			
		});

		/**
		 * Deprecated duplicate of {@link jQuery.sap.log.Level}.
		 * @deprecated Since 1.1.2. To streamline the Logging API a bit, the separation between Level and LogLevel has been given up.
		 * Use the (enriched) enumeration {@link jQuery.sap.log.Level} instead.
		 * @namespace Enumeration of levels that can be used in a call to {@link jQuery.sap.log.Logger#setLevel}(iLevel, sComponent).
		 * @public
		 */
		jQuery.sap.log.LogLevel = jQuery.sap.log.Level;

		/**
		 * Retrieves the currently recorded log entries.
		 * @deprecated Since 1.1.2. To avoid confusion with getLogger, this method has been renamed to {@link jQuery.sap.log.getLogEntries}.
		 * @function
		 * @public
		 * @static
		 */
		jQuery.sap.log.getLog = jQuery.sap.log.getLogEntries;

		/**
		 * A simple assertion mechanism that logs a message when a given condition is not met.
		 *
		 * <b>Note:</b> Calls to this method might be removed when the JavaScript code
		 *              is optimized during build. Therefore, callers should not rely on any side effects
		 *              of this method.
		 *
		 * @public
		 * @static
		 * @SecSink {1|SECRET} Could expose secret data in logs
		 */
		jQuery.sap.assert = function(bResult, sMessage) {
			if( !bResult ) {
				// console is not always available (IE, FF) and IE doesn't support console.assert
				jQuery.sap.log.debug("[Assertions] " + sMessage);
			}
			/*if( !bResult ) {
				if ( window.console && console.assert ) {
					console.assert(bResult, sWindowName + sMessage);
				} else {
					// console is not always available (IE, FF) and IE doesn't support console.assert
					jQuery.sap.log.debug("[Assertions] " + sMessage);
				}
			}*/
		};

		// against all our rules: use side effect of assert to differentiate between optimized and productive code
		jQuery.sap.assert( !!(mMaxLevel[''] = DEBUG), "will be removed in optimized version");
		if ( oCfgData.loglevel ) {
			jQuery.sap.log.setLevel(jQuery.sap.log.Level[oCfgData.loglevel.toUpperCase()] || parseInt(oCfgData.loglevel,10));
		}

		jQuery.sap.log.info("SAP Logger started.");
		// log early errors
		jQuery.each(_earlyErrors, function(i,e) { jQuery.sap.log.error(e); }); _earlyErrors = null;


	}());

	// ---------------------------------------------------------------------------------------------------

	/**
	 * Dummy implementation of a measure to be docked to a debug.js for implementation.
	 *
	 * <b>Note:</b> Calls to this method might be removed when the JavaScript code
	 *              is optimized during build.
	 * @public
	 * @static
	 * @SecSink {1 2|SECRET} Could expose secret data in logs
	 */
	jQuery.sap.measure = function(iAction, sId, sText) {
		return this;
	};

	/**
	 * Returns a new constructor function that creates objects with
	 * the given prototype.
	 *
	 * @return {function} the newly created constructor function
	 * @public
	 * @static
	 */
	jQuery.sap.factory = function factory(oPrototype) {
		function Factory() {}
		Factory.prototype = oPrototype;
		return Factory;
	};

	/**
	 * Returns a new object which has the given oPrototype as its prototype.
	 *
	 * If several objects with the same prototype are to be created,
	 * {@link jQuery.sap.factory} should be used instead.
	 *
	 * @public
	 * @static
	 */
	jQuery.sap.newObject = function newObject(oPrototype) {
		return new (jQuery.sap.factory(oPrototype))();
	};

	/**
	 * Returns a new function that returns the given <code>oValue</code> (using its closure).
	 *
	 * Avoids the need for a dedicated member for the value.
	 *
	 * As closures don't come for free, this function should only be used when polluting
	 * the enclosing object is an absolute "must-not" (as it is the case in public base classes).
	 *
	 * @public
	 * @static
	 */
	jQuery.sap.getter = function getter(oValue) {
		return function() {
			return oValue;
		};
	};

	/**
	 * Returns a JavaScript object which is identified by a sequence of names.
	 *
	 * A call to <code>getObject("a.b.C")</code> has essentially the same effect
	 * as accessing <code>window.a.b.C</code> but with the difference that missing
	 * intermediate objects (a or b in the example above) don't lead to an exception.
	 *
	 * When the addressed object exists, it is simply returned. If it doesn't exists,
	 * the behavior depends on the value of the second, optional parameter
	 * <code>iNoCreates</code> (assuming 'n' to be the number of names in the name sequence):
	 * <ul>
	 * <li>NaN: if iNoCreates is not a number and the addressed object doesn't exist,
	 *          then <code>getObject()</code> returns <code>undefined</code>.
	 * <li>0 &lt; iNoCreates &lt; n: any non-existing intermediate object is created, except
	 *          the <i>last</i> <code>iNoCreates</code> ones.
	 * </ul>
	 *
	 * Example:
	 * <pre>
	 *   getObject()            -- returns the context object (either param or window)
	 *   getObject("a.b.C")     -- will only try to get a.b.C and return undefined if not found.
	 *   getObject("a.b.C", 0)  -- will create a, b, and C in that order if they don't exists
	 *   getObject("a.b.c", 1)  -- will create a and b, but not C.
	 * </pre>
	 *
	 * When a <code>oContext</code> is given, the search starts in that object.
	 * Otherwise it starts in the <code>window</code> object that this plugin
	 * has been created in.
	 *
	 * Note: Although this method internally uses <code>object["key"]</code> to address object
	 *       properties, it does not support all possible characters in a name.
	 *       Especially the dot ('.') is not supported in the individual name segments,
	 *       as it is always interpreted as a name separator.
	 *
	 * @param {string} sName  a dot separated sequence of names that identify the required object
	 * @param {int}    [iNoCreates=NaN] number of objects (from the right) that should not be created
	 * @param {object} [oContext=window] the context to execute the search in
	 *
	 * @public
	 * @static
	 */
	jQuery.sap.getObject = function getObject(sName, iNoCreates, oContext) {
		var oObject = oContext || _window,
			aNames = (sName || "").split("."),
			l = aNames.length,
			iEndCreate = isNaN(iNoCreates) ? 0 : l - iNoCreates,
			i;

		for (i=0; oObject && i<l; i++) {
			if (!oObject[aNames[i]] && i<iEndCreate ) {
				oObject[aNames[i]] = {};
			}
			oObject = oObject[aNames[i]];
		}
		return oObject;

	};

	/**
	 * Sets an object property to a given value, where the property is
	 * identified by a sequence of names (path).
	 *
	 * When a <code>oContext</code> is given, the path starts in that object.
	 * Otherwise it starts in the <code>window</code> object that this plugin
	 * has been created for.
	 *
	 * Note: Although this method internally uses <code>object["key"]</code> to address object
	 *       properties, it does not support all possible characters in a name.
	 *       Especially the dot ('.') is not supported in the individual name segments,
	 *       as it is always interpreted as a name separator.
	 *
	 * @param {string} sName  a dot separated sequence of names that identify the property
	 * @param {any}    vValue value to be set, can have any type
	 * @param {object} [oContext=window] the context to execute the search in
	 * @public
	 * @static
	 */
	jQuery.sap.setObject = function (sName, vValue, oContext) {
		var oObject = oContext || _window,
			aNames = (sName || "").split("."),
			l = aNames.length, i;

		if ( l>0 ) {
			for (i=0; oObject && i<l-1; i++) {
				if (!oObject[aNames[i]] ) {
					oObject[aNames[i]] = {};
				}
				oObject = oObject[aNames[i]];
			}
			oObject[aNames[l-1]] = vValue;
		}
	};

	// ---------------------- require/declare --------------------------------------------------------

	/**
	 * A map of URL prefixes keyed by the corresponding module name prefix.
	 * @see jQuery.sap.registerModulePath
	 *
	 * Note that the empty prefix ('') will always match and thus serves as a fallback.
	 */
	var mUrlPrefixes = { '' : 'resources/' };

	// take resource roots from configuration
	if ( oCfgData.resourceroots ) {
		jQuery.extend(true, mUrlPrefixes, oCfgData.resourceroots);
	}

	// dump the URL prefixes
	jQuery.sap.log.info("URL prefixes set to:");
	for(var n in mUrlPrefixes) {
		jQuery.sap.log.info("  " + (n ? "'" + n + "'" : "(default)") + " : " + mUrlPrefixes[n]);
	}

	// find prefix for module name
	var _getModulePath = function _getModulePath(sModuleName, sSuffix) {

		// split name into segments
		var aSegments = sModuleName.split(/\./);

		// search for a defined name prefix, starting with the full name and successively removing one segment
		for(var l=aSegments.length; l>=0; l--) {
			var sNamePrefix = aSegments.slice(0, l).join('.');
			if ( mUrlPrefixes[sNamePrefix] ) {
				var sResult = mUrlPrefixes[sNamePrefix];
				if ( l < aSegments.length ) {
					sResult += aSegments.slice(l).join("/");
				}
				if ( sResult.slice(-1) === '/' ) {
					sResult = sResult.slice(0, -1);
				}
				return sResult + (sSuffix || '');
			}
		}

		jQuery.sap.assert(false, "should never happen");
	};

	/* ==== Begin of HACK ==== */
	// this HACK wraps the _getModulePath function to implement some special handling
	// for the jquery.sap. modules, which contain a dot in their name
	var _HACK_orig_getModulePath = _getModulePath;
	var _getModulePath = function HACK_modified_getModulePath(sModuleName, sSuffix) {
		if ( sModuleName.indexOf("jquery.sap.") === 0 ) {
			sModuleName = sModuleName.replace(/\./gi, "%2E");
			var sPath = _HACK_orig_getModulePath(sModuleName, sSuffix);
			return sPath.replace(/%2E/gi, ".");
		}
		return _HACK_orig_getModulePath(sModuleName, sSuffix);
	};
	/* ==== End of HACK ==== */

	/**
	 * Constructs an URL to load the module with the given name and file type (suffix).
	 *
	 * Searches the longest prefix of the given module name for which a registration
	 * exists (see {@link jQuery.sap.registerModulePath}) and replaces that prefix
	 * by the registered URL prefix.
	 *
	 * The remainder of the module name is appended to the URL, replacing any dot with a slash.
	 *
	 * Finally, the given suffix (typically a file name extension) is added (unconverted).
	 *
	 * The returned name (without the suffix) doesn't end with a slash.
	 *
	 * @public
	 * @static
	 */
	jQuery.sap.getModulePath = function(sModuleName, sSuffix) {
		return _getModulePath(sModuleName, sSuffix);
	};

	/**
	 * Registers an URL prefix for a module name prefix.
	 *
	 * Before a module is loaded, the longest registered prefix of its module name
	 * is searched for and the associated URL prefix is used as a prefix for the request URL.
	 * The remainder of the module name is attached to the request URL by replacing
	 * dots ('.') with slashes ('/').
	 *
	 * The registration and search operates on full name segments only. So when a prefix
	 *
	 *    'sap.com'  ->  'http://www.sap.com/ui5/resources/'
	 *
	 * is registered, then it will match the name
	 *
	 *    'sap.com.Button'
	 *
	 * but not
	 *
	 *    'sap.commons.Button'
	 *
	 * Note that the empty prefix ('') will always match and thus serves as a fallback for
	 * any search.
	 *
	 * @public
	 * @static
	 * @SecSink {1|PATH} Parameter is used for future HTTP requests
	 */
	jQuery.sap.registerModulePath = function registerModulePath(sModuleName, sUrlPrefix) {
		// must not be empty
		sUrlPrefix = sUrlPrefix || '.';

		// ensure that the prefix ends with a '/'
		if ( sUrlPrefix.slice(-1) != '/' ) {
			sUrlPrefix += '/';
		}

		mUrlPrefixes[sModuleName] = sUrlPrefix;

		jQuery.sap.log.info("sap.registerModulePath ('" + sModuleName + "', '" + sUrlPrefix + "')");

	};


	/**
	 * Set of modules that have been loaded (required) so far
	 * @private
	 */
	var mModules = {};

	// make the module loading more verbose
	var _verbose = false; // not yet configurable as Url params are not available here... oCfgData.debug === true || oCfgData.debug === "true" || oCfgData.debug === "x";

	/**
	 * Stack of modules that are currently executed.
	 * Allows to identify the containing module in case of multi module files (e.g. sap-ui-core)
	 */
	var _execStack = [ ];
	var sLogPrefix = "";

	/**
	 * Check whether a given module has been loaded / declared already
	 * @param {string} sModuleName name of the module to be checked
	 * @return {boolean} whether the module has been declared already
	 * @public
	 * @static
	 */
	jQuery.sap.isDeclared = function isDeclared(sModuleName) {
		return !!mModules[sModuleName];
	};
	
	/**
	 * Returns the names of all declared modules.
	 * @return {string[]} the names of all declared modules
	 * @see jQuery.sap.isDeclared
	 * @public
	 * @static
	 */
	jQuery.sap.getAllDeclaredModules = function() {
		var aModules = [];
		jQuery.each(mModules, function(i,v) {
			aModules.push(i);
		});
		return aModules;
	};

	/**
	 * Declares a module as existing.
	 *
	 * By default, this function assumes that the module will create a JavaScript object
	 * with the same name as the module. As a convenience it ensures that the parent
	 * namespace for that object exists (by calling jQuery.sap.getObject).
	 * If such an object creation is not desired, <code>bCreateNamespace</code> must be set to false.
	 *
	 * @param {string || object} sModuleName name of the module to be declared
	 *                           or in case of an object {modName: "...", type: "..."}
	 *                           where modName is the name of the module and the type
	 *                           could be a specific dot separated extension e.g.
	 *                           <code>{modName: "sap.ui.core.Dev", type: "view"}</code>
	 *                           loads <code>sap/ui/core/Dev.view.js</code> and
	 *                           registers as <code>sap.ui.core.Dev.view</code>
	 * @param {string} [bCreateNamespace=true] whether to create the parent namespace
	 *
	 * @public
	 * @static
	 */
	jQuery.sap.declare = function declare(sModuleName, bCreateNamespace) {
		if ( _verbose ) {
			jQuery.sap.log.debug(sLogPrefix + "sap.declare '" + sModuleName + "'");
		}

		// check for an object as parameter for sModuleName
		// in case of this the object contains the module name and the type
		// which could be {modName: "sap.ui.core.Dev", type: "view"}
		var sType = "";
		if (typeof(sModuleName) === "object") {
			sType = sModuleName.type ? "." + sModuleName.type : "";
			sModuleName = sModuleName.modName + sType;
		}

		if ( !jQuery.sap.isDeclared(sModuleName) ) {
			if ( !mModules[sModuleName] ) {
				mModules[sModuleName] = { };
			}
			mModules[sModuleName].state = 'ready';
		}

		// identify the bootstrap module
		// Note: this is only a guess and fails e.g. when multiple modules are loaded via a script tag
		// to make it safe, we could convert 'declare' calls to e.g. 'subdeclare' calls at build time.
		if ( _execStack.length === 0 && sModuleName !== "jquery.sap.global" ) {
			_execStack.push(sModuleName);
			mModules[sModuleName].url = mModules[sModuleName].url || _sBootstrapUrl;
		}

		// remember parent module if any
		if ( !mModules[sModuleName].parent ) {
		  mModules[sModuleName].parent = _execStack[_execStack.length-1];
		}

		// ensure parent namespace even if module was declared already
		// (as declare might have been called by require)
		if (bCreateNamespace !== false) {
			// ensure parent namespace
			jQuery.sap.getObject(sModuleName, 1);
		}

		return this;
	};

	function requireModule(sModuleName) {

		// handle multiple imports
		if ( arguments.length > 1 ) {
			for(var i=0; i<arguments.length; i++) {
				jQuery.sap.require(arguments[i]);
			}
			return this;
		}

		// check for an object as parameter for sModuleName
		// in case of this the object contains the module name and the type
		// which could be {modName: "sap.ui.core.Dev", type: "view"}
		var sType = "";
		if (typeof(sModuleName) === "object") {
			sType = sModuleName.type ? "." + sModuleName.type : "";
			sModuleName = sModuleName.modName + sType;
		}

		if ( _verbose ) {
			jQuery.sap.log.debug(sLogPrefix + "require '" + sModuleName + "' of type '" + sType + "'");
		}

		// check if module has been loaded already
		if ( mModules[sModuleName] ) {
			if ( mModules[sModuleName].state === 'loaded' ) {
				execModule(sModuleName);
			}

			if ( mModules[sModuleName].state === 'ready' ) {
				if ( _verbose ) {
					jQuery.sap.log.debug("module '" + sModuleName + "' has already been loaded (skipped).");
				}
				return this;
			} else if ( mModules[sModuleName].state === 'failed' ) {
				throw new Error("found in negative cache: '" + sModuleName+  "' from " + mModules[sModuleName].url + ": " + mModules[sModuleName].error);
			} else {
				// currently loading
				return this;
			}
		}

		// set marker for loading modules (to break cycles)
		var mod = mModules[sModuleName] = { state: 'loading' };

		// in case of having a type specified ignore the type for the module path creation and add it as file extension
		var sBaseName = sType ? sModuleName.substring(0, sModuleName.length - sType.length) : sModuleName;

		// if debug is enabled, try to load debug module first
		if (window["sap-ui-loaddbg"]) {
			// create module URL for the debug version
			mod.url = jQuery.sap.getModulePath(sBaseName + "-dbg", sType + '.js');
			if ( _verbose ) {
				jQuery.sap.log.debug("loading debug version of '" + sModuleName + "' from '" + mod.url + "'");
			}
			jQuery.ajax({
				url : mod.url,
				dataType : 'text',
				async : false,
				success : function(response, textStatus, xhr) {
					mod.state = 'loaded';
					mod.data = response;
				},
				error : function(xhr, textStatus, error) {
					mod.state = 'failed';
					mod.error = xhr ? xhr.status + " - " + xhr.statusText : textStatus;
				}
			});
		}

		// try to load the module, if debug was not enabled/not successful
		if ( mod.state !== 'loaded' ) {
			// create module URL
			mod.url = jQuery.sap.getModulePath(sBaseName, sType + '.js');
			if ( _verbose ) {
				jQuery.sap.log.debug("loading '" + sModuleName + "' from '" + mod.url + "'");
			}
			jQuery.ajax({
				url : mod.url,
				dataType : 'text',
				async : false,
				success : function(response, textStatus, xhr) {
					mod.state = 'loaded';
					mod.data = response;
				},
				error : function(xhr, textStatus, error) {
					mod.state = 'failed';
					mod.error = xhr ? xhr.status + " - " + xhr.statusText : textStatus;
				}
			});
		}

		// execute module __after__ loading it, this reduces the required stack space!
		if ( mod.state === 'loaded' ) {
			execModule(sModuleName);
		}

		if ( mod.state !== 'ready' ) {
			throw new Error("failed to load '" + sModuleName+  "' from " + mod.url + ": " + mod.error);
		}

		return this;

	}

	function execModule(sModuleName) {

		var mod = mModules[sModuleName];

		if ( mod && mod.state === 'loaded' && typeof mod.data !== "undefined" ) {
			try {

				if ( _verbose ) {
					var oldPrefix = sLogPrefix;
					sLogPrefix = sLogPrefix + "  ";
					jQuery.sap.log.debug(sLogPrefix + "executing '" + sModuleName + "'");
				}

				// execute the script in the window context
				mod.state = 'executing';
				_execStack.push(sModuleName);
				if (_window.execScript) {
					try {
						mod.data && _window.execScript(mod.data); // execScript fails if data is empty
					} catch (e) {
						_execStack.pop();
						// eval again with different approach - should fail with a more informative exception
						jQuery.sap.globalEval(mod.data);
						throw e; // rethrow err in case globalEval succeeded unexpectedly
					}
				} else {
					_window.eval(mod.data + "\r\n//@ sourceURL=" + mod.url); // Firebug and Safari debugging help, seems to cost ZERO performance
				}
				_execStack.pop();
				mod.state = 'ready';
				mod.data = undefined;
				if ( _verbose ) {
					jQuery.sap.log.debug(sLogPrefix + "finished executing '" + sModuleName + "'");
					sLogPrefix = oldPrefix;
				}

			} catch (err) {
				mod.state = 'failed';
				mod.error = ((err.toString && err.toString()) || err.message) + (err.line ? "(line " + err.line + ")" : "" );
				mod.data = undefined;
			}
		}
	}

	/**
	 * Ensures that the given module is loaded and executed before execution of the
	 * current script continues.
	 *
	 * By issuing a call to this method, the caller declares a dependency to the listed modules.
	 *
	 * Any required and not yet loaded script will be loaded and execute synchronously.
	 * Already loaded modules will be skipped.
	 *
	 * @param {string... || object} sModuleName one or more names of modules to be loaded
	 *                              or in case of an object {modName: "...", type: "..."}
	 *                              where modName is the name of the module and the type
	 *                              could be a specific dot separated extension e.g.
	 *                              <code>{modName: "sap.ui.core.Dev", type: "view"}</code>
	 *                              loads <code>sap/ui/core/Dev.view.js</code> and
	 *                              registers as <code>sap.ui.core.Dev.view</code>
	 *
	 * @public
	 * @static
	 * @function
	 * @SecSink {0|PATH} Parameter is used for future HTTP requests
	 */
	jQuery.sap.require = requireModule;


	jQuery.sap.registerPreloadedModules = function(oModules) {
		var sExecutingModule = _execStack.slice(-1),
			sURL = sExecutingModule && mModules[sExecutingModule] && mModules[sExecutingModule].url;

		if ( _verbose ) {
			jQuery.sap.log.debug(sLogPrefix + "adding preloaded modules from '" + sURL + "'");
		}

		jQuery.each(oModules, function(sModuleName,data) {
			if ( !mModules[sModuleName] ) {
				mModules[sModuleName] = { state : 'loaded', url : sURL + "#" + sModuleName, data : data };
			}
		});
	};

	// declare our own module
	jQuery.sap.declare("jquery.sap.global", false);

	// --------------------- script and stylesheet handling --------------------------------------------------

	// appends a link object to the head
	function appendHead(oElement) {
		var head = window.document.getElementsByTagName("head")[0];
		if (head) {
			head.appendChild(oElement);
		}
	}

	/**
	 * Includes the script (via &lt;script&gt;-tag) into the head for the
	 * specified <code>sUrl</code> and optional <code>sId</code>.
	 *
	 * @param {string}
	 *            sUrl the URL of the script to load
	 * @param {string}
	 *            [sId] id that should be used for the script include tag
	 *
	 * @public
	 * @static
	 * @SecSink {0|PATH} Parameter is used for future HTTP requests
	 */
	jQuery.sap.includeScript = function includeScript(sUrl, sId){
		var oScript = window.document.createElement("script");
		oScript.src = sUrl;
		oScript.type = "text/javascript";
		if (sId) {
			oScript.id = sId;
		}
		// jQuery("head").append(oScript) doesn't work because they filter for the script
		// and execute them directly instead adding the SCRIPT tag to the head
		appendHead(oScript);
	};

	/**
	 * Includes the specified stylesheet via a &lt;link&gt;-tag in the head of the current document.
	 * If there is call to <code>includeStylesheet</code> providing the sId of an already included stylesheet,
	 * the existing element will be replaced.
	 *
	 * @param {string} sUrl the URL of the script to load
	 * @param {string} [sId] id that should be used for the script include tag
	 *
	 * @public
	 * @static
	 * @SecSink {0|PATH} Parameter is used for future HTTP requests
	 */
	jQuery.sap.includeStyleSheet = function includeStyleSheet(sUrl, sId){

		// create the new link element
		var oLink = document.createElement("link");
		oLink.type = "text/css";
		oLink.rel = "stylesheet";
		oLink.href = sUrl;
		if (sId) {
			oLink.id = sId;
		}

		// check for existence of the link
		var oOld, bReplace;
		if ((sId && (oOld = jQuery.sap.domById(sId)) && (bReplace = oOld.tagName === "LINK" && oOld.rel ==="stylesheet")) || window.document.body) {
			if (bReplace) {
				jQuery(oOld).replaceWith(oLink);
			} else {
				appendHead(oLink);
			}
		} else {
			appendHead(oLink);
		}

	};

	// TODO should be in core, but then the 'callback' could not be implemented
	if ( !(oCfgData.productive === true || oCfgData.productive === "true"  || oCfgData.productive === "x") ) {
		jQuery(function() {
			jQuery(document.body).keydown(function(e) {
				if ( e.keyCode == 80 && e.shiftKey && e.altKey && e.ctrlKey ) {
					try {
						jQuery.sap.require("sap.ui.debug.TechnicalInfo");
					} catch (e) {
						// alert("Sorry, failed to activate 'P'-mode!");
						return;
					}
					sap.ui.debug.TechnicalInfo.open(function() {
						return { modules : mModules, prefixes : mUrlPrefixes, config: oCfgData };
					});
				}
			});
		});
		
		jQuery(function() {
			jQuery(document.body).keydown(function(e) {
				if ( e.keyCode == 83 /*S*/ && e.shiftKey && e.altKey && e.ctrlKey ) { //TODO: Is this ok?
					try {
						jQuery.sap.require("sap.ui.core.support.Support");
						var oSupport = sap.ui.core.support.Support.getStub();
						if(oSupport.getType() != sap.ui.core.support.Support.StubType.APPLICATION){
							return;
						}
						oSupport.openSupportTool();
					} catch(e) {
					}
				}
			});
		});
	}

	// *********** feature detection, enriching jQuery.support *************
	// this might go into its own file once there is more stuff added

	if (!jQuery.support) {
		jQuery.support = {};
	}

	/**
	 * jQuery.support.flexBoxLayout is true if the current browser supports the CSS3 Flexible Box Layout directly or via vendor prefixes
	 */
	if (jQuery.support.flexBoxLayout === undefined) {
		jQuery.support.flexBoxLayout =
			((document.documentElement.style.MozBoxFlex !== undefined) ||
				(document.documentElement.style.WebkitBoxFlex !== undefined) ||
				(document.documentElement.style.MsBoxFlex !== undefined) ||
				(document.documentElement.style.BoxFlex !== undefined));
	}

	// *********** fixes for (pending) jQuery bugs **********
	if (!jQuery.support.opacity) {
		(function() {
			// jQuery cssHook for setOpacity[IE8] doesn't properly cleanup the CSS filter property
			var oldSet = jQuery.cssHooks.opacity.set;
			jQuery.cssHooks.opacity.set = function( elem, value ) {
				oldSet.apply(this, arguments);
				if ( !jQuery.trim(elem.style.filter) ) {
					elem.style.removeAttribute("filter");
				}
			};
		}());
	}

	// *** Performance measure ***
	function PerfMeasurement(){

		function Measurement( sId, sInfo, iStart, iEnd ){
			this.id = sId;
			this.info = sInfo;
			this.start = iStart;
			this.end = iEnd;
			this.pause = 0;
			this.resume = 0;
			this.duration = 0; // used time
			this.time = 0; // time from start to end
		}

		var bActive = /sap-ui-measure=(true|x|X)/.test(location.search);

		this.getActive = function(){
			return bActive;
		};

		this.setActive = function( bOn ){
			bActive = bOn;
		};

		this.mMeasurements = {};

		this.start = function( sId, sInfo ){
			if (!bActive) {
				return;
			}

			var iTime = new Date().getTime();
			var oMeasurement = new Measurement( sId, sInfo, iTime, 0);
//			jQuery.sap.log.info("Performance measurement start: "+ sId + " on "+ iTime);

			if (oMeasurement) {
				this.mMeasurements[sId] = oMeasurement;
				return({id: oMeasurement.id, info: oMeasurement.info, start: oMeasurement.start });
			}else{
				return false;
			}
		};

		this.pause = function( sId ){
			if (!bActive) {
				return;
			}

			var iTime = new Date().getTime();
			var oMeasurement = this.mMeasurements[sId];

			if (oMeasurement && oMeasurement.pause == 0) {
				// not already paused
				oMeasurement.pause = iTime;
				if (oMeasurement.pause >= oMeasurement.resume && oMeasurement.resume > 0) {
					oMeasurement.duration = oMeasurement.duration + oMeasurement.pause - oMeasurement.resume;
					oMeasurement.resume = 0;
				}else if (oMeasurement.pause >= oMeasurement.start) {
					oMeasurement.duration = oMeasurement.pause - oMeasurement.start;
				}
			}
//			jQuery.sap.log.info("Performance measurement pause: "+ sId + " on "+ iTime + " duration: "+ oMeasurement.duration);

			if (oMeasurement) {
				return({id: oMeasurement.id, info: oMeasurement.info, start: oMeasurement.start, pause: oMeasurement.pause });
			}else{
				return false;
			}
		};

		this.resume = function( sId ){
			if (!bActive) {
				return;
			}

			var iTime = new Date().getTime();
			var oMeasurement = this.mMeasurements[sId];
//			jQuery.sap.log.info("Performance measurement resume: "+ sId + " on "+ iTime + " duration: "+ oMeasurement.duration);

			if (oMeasurement && oMeasurement.pause > 0) {
				// already paused
				oMeasurement.pause = 0;
				oMeasurement.resume = iTime;
			}

			if (oMeasurement) {
				return({id: oMeasurement.id, info: oMeasurement.info, start: oMeasurement.start, resume: oMeasurement.resume });
			}else{
				return false;
			}
		};

		this.end = function( sId ){
			if (!bActive) {
				return;
			}

			var iTime = new Date().getTime();
			var oMeasurement = this.mMeasurements[sId];
//			jQuery.sap.log.info("Performance measurement end: "+ sId + " on "+ iTime);

			if (oMeasurement && !oMeasurement.end) {
				oMeasurement.end = iTime;
				if (oMeasurement.end >= oMeasurement.resume && oMeasurement.resume > 0) {
					oMeasurement.duration = oMeasurement.duration + oMeasurement.end - oMeasurement.resume;
					oMeasurement.resume = 0;
				}else if (oMeasurement.pause > 0) {
					// duration already calculated
					oMeasurement.pause = 0;
				}else if (oMeasurement.end >= oMeasurement.start) {
					oMeasurement.duration = oMeasurement.end - oMeasurement.start;
				}
				if (oMeasurement.end >= oMeasurement.start) {
					oMeasurement.time = oMeasurement.end - oMeasurement.start;
				}
			}

			if (oMeasurement) {
				return({id: oMeasurement.id,
					    info: oMeasurement.info,
					    start: oMeasurement.start,
					    end: oMeasurement.end,
					    time: oMeasurement.time,
					    duration: oMeasurement.duration});
			}else{
				return false;
			}
		};

		this.getTime = function( sId ){
			if (!bActive) {
				return;
			}

			var oMeasurement = this.mMeasurements[sId];

			if (oMeasurement) {
				return({id: oMeasurement.id,
						info: oMeasurement.info,
						start: oMeasurement.start,
						end: oMeasurement.end,
						time: oMeasurement.time,
						duration: oMeasurement.duration});
			}else{
				return false;
			}
		};

		this.clear = function( ){
			if (!bActive) {
				return;
			}

			this.mMeasurements = {};
			return;
		};

		this.remove = function( sId ){
			if (!bActive) {
				return;
			}

			delete this.mMeasurements[sId];
			return;
		};

		this.getAllMeasurements = function( ){
			if (!bActive) {
				return;
			}

			var aMeasurements = new Array();

			jQuery.each(this.mMeasurements, function(sId, oMeasurement){
				aMeasurements.push({id: oMeasurement.id,
					                info: oMeasurement.info,
					                start: oMeasurement.start,
					                end: oMeasurement.end,
					                duration: oMeasurement.duration,
					                time: oMeasurement.time});
			});
			return aMeasurements;
		};

	}

	jQuery.sap.perfMeasure = new PerfMeasurement();

}());

/**
 * Executes an 'eval' for its arguments in the global context (without closure variables).
 *
 * This is a synchronous replacement for <code>jQuery.globalEval</code> which in some
 * browsers (e.g. FireFox) behaves asynchronously.
 *
 * @type void
 * @public
 * @static
 * @SecSink {0|XSS} Parameter is evaluated
 */
jQuery.sap.globalEval = function() {
	eval(arguments[0]);
};

jQuery.sap.declare('sap-ui-core');
jQuery.sap.declare('jquery-1.7.1'); // raw module, declared by SAPUI5 CreateModule Ant-Task
jQuery.sap.declare('jquery-ui-position'); // raw module, declared by SAPUI5 CreateModule Ant-Task
jQuery.sap.declare('jquery.sap.global'); // raw module, declared by SAPUI5 CreateModule Ant-Task
if ( !jQuery.sap.isDeclared('sap.ui.core.Core') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides the real core class sap.ui.core.Core of SAPUI5
jQuery.sap.declare("sap.ui.core.Core");

if ( !jQuery.sap.isDeclared('jquery.sap.dom') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides functionality related to DOM analysis and manipulation which is not provided by jQuery itself.
jQuery.sap.declare("jquery.sap.dom", false);

(function() {

	/**
	 * Shortcut for document.getElementById() with additionally an IE6/7 bug fixed.
	 * Used to replace the jQuery.sap.domById when running in IE < v8.
	 *
	 * @param {String} sId the id of the DOM element to return
	 * @param {window} oWindow the window (optional)
	 * @return {DOMNode} the DOMNode identified by the given sId
	 * @private
	 */
	var domByIdInternal = function(sId, oWindow) {

		if (!oWindow) {
			oWindow = window;
		}
		if (!sId || sId=="") {
			return null;
		}

		var oDomRef = oWindow.document.getElementById(sId);

		// IE also returns the element with the name or id whatever is first
		// => the following line makes sure that this was the id
		if (oDomRef && oDomRef.id == sId) {
			return oDomRef;
		}

		// otherwise try to lookup the name
		var oRefs = oWindow.document.getElementsByName(sId);
		for (var i=0;i<oRefs.length;i++) {
			oDomRef = oRefs[i];
			if (oDomRef && oDomRef.id == sId) {
				return oDomRef;
			}
		}

		return null;

	};

	/**
	 * Shortcut for document.getElementById(), including a bug fix for older IE versions.
	 *
	 * @param {String} sId The id of the DOM element to return
	 * @param {window} [oWindow=window] The window (optional)
	 * @return {DOMNode} The DOMNode identified by the given sId
	 * @public
	 * @function
	 * @since 0.9.0
	 */
	jQuery.sap.domById = jQuery.browser.msie && jQuery.browser.version < 8 ? domByIdInternal : function domById(sId, oWindow) {
		return sId ? (oWindow || window).document.getElementById(sId) : null;
	};


	/**
	 * Shortcut for jQuery("#" + id) with additionally the id being escaped properly.
	 * I.e.: returns the jQuery object for the DOM element with the given id
	 *
	 * Use this method instead of jQuery(...) if you know the argument is exactly one id and
	 * the id is not known in advance because it is in a variable (as opposed to a string
	 * constant with known content).
	 *
	 * @param {String} sId The id to search for and construct the jQuery object
	 * @param {DomNode} oContext The context DomNode
	 * @return {Object} The jQuery object for the DOM element identified by the given sId
	 * @public
	 * @since 0.9.1
	 */
	jQuery.sap.byId = function byId(sId, oContext) {
		var escapedId = "";
		if (sId) {
			escapedId = "#" + sId.replace(/(:|\.)/g,'\\$1');
		}
		return jQuery(escapedId, oContext);
	};


	/**
	 * Calls focus() on the given DOM element, but catches and ignores any errors that occur when doing so.
	 * (i.e. IE8 throws an error when the DOM element is invisible or disabled)
	 *
	 * @param {DomNode} oDomRef The DOM element to focus (or null - in this case the method does nothing)
	 * @return {boolean} Whether the focus() command was executed without an error
	 * @public
	 * @since 1.1.2
	 */
	jQuery.sap.focus = function focus(oDomRef) {
		if (!oDomRef) {
			return;
		}
		try {
			oDomRef.focus();
		} catch (e) {
			var id = (oDomRef && oDomRef.id) ? " (ID: '" + oDomRef.id + "')" : "";
			jQuery.sap.log.warning("Error when trying to focus a DOM element" + id + ": " + e.message);
			return false;
		}
		return true;
	};


	/**
	 * Sets or gets the position of the cursor in an element that supports cursor positioning
	 *
	 * @param {int} iPos The cursor position to set (or no parameter to retrieve the cursor position)
	 * @return {int | jQuery} The cursor position (or the jQuery collection if the position has been set)
	 * @public
	 * @methodOf jQuery.prototype
	 * @name cursorPos
	 * @author SAP AG
	 * @since 0.9.0
	 */
	jQuery.fn.cursorPos = function cursorPos(iPos) {
		var len = arguments.length,
			oTextRange,iLength,
			sTagName,
			sType;

		// in jQuery > 1.6 attr() don't gives results for some property, instead there is a prop() method
		if (this.prop) {
			sTagName = this.prop("tagName");
			sType = this.prop("type");
		}else{
			sTagName = this.attr("tagName");
			sType = this.attr("type");
		}

		if( this.length === 1 && ((sTagName == "INPUT" && (sType == "text" || sType == "password"))
				|| sTagName == "TEXTAREA" )) {

			var oDomRef = this.get(0);

			if (len > 0) { // SET

				if (oDomRef.createTextRange) { // IE method
					oTextRange = oDomRef.createTextRange();
					var iMaxLength = oDomRef.value.length;

					if(iPos < 0 || iPos > iMaxLength) {
						iPos = iMaxLength;
					}
					if(oTextRange) {
						oTextRange.collapse();
						oTextRange.moveEnd("character",iPos);
						oTextRange.moveStart("character",iPos);
						oTextRange.select();
					}
				} else if (typeof(oDomRef.selectionStart) == "number") { // FF method
					oDomRef.focus();
					oDomRef.selectionStart = iPos;
					oDomRef.selectionEnd = iPos;
				}

				return this;
				// end of SET

			} else { // GET

				if (oDomRef.createTextRange) { //IE
					oTextRange = window.document.selection.createRange();
					var oCopiedTextRange = oTextRange.duplicate();
					// Logic in TEXTAREA and INPUT is different in IE -> check for element type
					if(oDomRef.tagName == "TEXTAREA"){
						oCopiedTextRange.moveToElementText(oDomRef);
						var oCheckTextRange = oCopiedTextRange.duplicate();
						iLength = oCopiedTextRange.text.length;

						// first check if cursor on last position
						oCheckTextRange.moveStart("character", iLength);
						if(oCheckTextRange.inRange(oTextRange)){
							iStart = iLength;
						}else{
							// find out cursor position using a bisection algorithm
							var iCheckLength = iLength;
							var iStart = 0;
							while(iLength > 1){
								iCheckLength = Math.round(iLength / 2);
								iStart = iStart + iCheckLength;

								oCheckTextRange = oCopiedTextRange.duplicate();
								oCheckTextRange.moveStart("character", iStart);
								if(oCheckTextRange.inRange(oTextRange)){
									//cursor is after or on iStart -> Length = not checked Length
									iLength = iLength - iCheckLength;

								}else{
									//cursor is before iStart  -> Length = checked Length
									iStart = iStart - iCheckLength;
									iLength = iCheckLength;
								}
							}
						}
						return iStart;
					} else if (oCopiedTextRange.parentElement() === oDomRef) {
						// ensure there is only the cursor and not the range (as this would create erroneous position)!
						oCopiedTextRange.collapse();
						// now, move the selection range to the beginning of the inputField and simply get the selected range's length
						var iLength = oDomRef.value.length;
						oCopiedTextRange.moveStart('character', -iLength);
						return oCopiedTextRange.text.length;
					}
				} else if (typeof(oDomRef.selectionStart) == "number") { // Firefox etc.
					return oDomRef.selectionStart;
				}

				return -1;
			} // end of GET
		} else {
			// shouldn't really happen, but to be safe...
			return this;
		}
	};

	/**
	 * Sets the text selection in the first element of the collection
	 *
	 * @param {int} iStart Start position of the selection (inclusive)
	 * @param {int} iEnd End position of the selection (exclusive)
	 * @return {jQuery} The jQuery collection
	 * @public
	 * @methodOf jQuery.prototype
	 * @name selectText
	 * @author SAP AG
	 * @since 0.9.0
	 */
	jQuery.fn.selectText = function selectText(iStart, iEnd) {
		var oDomRef = this.get(0);

		if (oDomRef) {
			if(oDomRef.createTextRange) { // IE
				var oTextEditRange = oDomRef.createTextRange();
				oTextEditRange.collapse();
				oTextEditRange.moveStart('character', iStart);
				oTextEditRange.moveEnd('character', iEnd - iStart);
				oTextEditRange.select();
			} else if(typeof(oDomRef.selectionStart) == "number") { // Firefox
				// sanity checks
				if (iStart < 0) {
					iStart = 0;
				}
				if (iEnd > oDomRef.value.length) {
					iEnd = oDomRef.value.length;
				}
				if (!iEnd || iStart > iEnd) {
					iStart = 0;
					iEnd = 0;
				}
				oDomRef.selectionStart = iStart; // TODO: maybe need to decouple via setTimeout?
				oDomRef.selectionEnd = iEnd;
			}
		}

		return this;
	};


	/**
	 * Returns the outer HTML of the given HTML element
	 *
	 * @return {String} outer HTML
	 * @public
	 * @methodOf jQuery.prototype
	 * @name outerHTML
	 * @author SAP AG
	 * @since 0.9.0
	 */
	jQuery.fn.outerHTML = function outerHTML() {
		var oDomRef = this.get(0);

		if (oDomRef && oDomRef.outerHTML) {
			return jQuery.trim(oDomRef.outerHTML);
		} else {
			var doc = this[0] ? this[0].ownerDocument : document;

			var oDummy = doc.createElement("div");
			oDummy.appendChild(oDomRef.cloneNode(true));
			return oDummy.innerHTML;
		}
	};


	/**
	 * Returns whether oDomRefChild is oDomRefContainer or is contained in oDomRefContainer.
	 *
	 * This is a browser-independent version of the .contains method of Internet Explorer.
	 * For compatibility reasons it returns true if oDomRefContainer and oDomRefChild are equal.
	 *
	 * This method intentionally does not operate on the jQuery object, as the original jQuery.contains()
	 * method also does not do so.
	 *
	 * @param {DOMNode} oDomRefContainer The container element
	 * @param {DOMNode} oDomRefChild The child element (must not be a text node, must be an element)
	 * @return {boolean} 'true' if oDomRefChild is contained in oDomRefContainer or oDomRefChild is oDomRefContainer
	 * @public
	 * @author SAP AG
	 * @since 0.9.0
	 */
	jQuery.sap.containsOrEquals = function containsOrEquals(oDomRefContainer, oDomRefChild) {
		if (oDomRefChild && oDomRefContainer && oDomRefChild != document && oDomRefChild != window) {
			return (oDomRefContainer === oDomRefChild) || jQuery.contains(oDomRefContainer, oDomRefChild);
		}
		return false;
	};


	/**
	 * Returns a rectangle describing the current visual positioning of the first DOM object in the collection
	 * (or null if no element was given)
	 *
	 * @return {object} An object with left, top, width and height
	 * @public
	 * @methodOf jQuery.prototype
	 * @name rect
	 * @author SAP AG
	 * @since 0.9.0
	 */
	jQuery.fn.rect = function rect() {
		var oDomRef = this.get(0);

		if (oDomRef) {
			// this should be available in all 'modern browsers'
			if (oDomRef.getBoundingClientRect) {
				var oClientRect = oDomRef.getBoundingClientRect();
				var oRect = { top : oClientRect.top,
						left : oClientRect.left,
						width : oClientRect.right - oClientRect.left,
						height : oClientRect.bottom - oClientRect.top };

				var oWnd = jQuery.sap.ownerWindow(oDomRef);
				oRect.left += jQuery(oWnd).scrollLeft();
				oRect.top += jQuery(oWnd).scrollTop();

				return oRect;
			} else {
				// IE6 and older; avoid crashing and give some hardcoded size
				return { top : 10, left : 10, width : oDomRef.offsetWidth, height : oDomRef.offsetWidth };
			}
		}
		return null;
	};


	/**
	 * Returns whether a point described by X and Y is inside this Rectangle's boundaries
	 *
	 * @param {int} iPosX
	 * @param {int} iPosY
	 * @return Whether X and Y are inside this Rectangle's boundaries
	 * @public
	 * @methodOf jQuery.prototype
	 * @name rectContains
	 * @author SAP AG
	 * @since 0.18.0
	 */
	jQuery.fn.rectContains = function rectContains(iPosX, iPosY) {
		jQuery.sap.assert(!isNaN(iPosX), "iPosX must be a number");
		jQuery.sap.assert(!isNaN(iPosY), "iPosY must be a number");

		var oRect = this.rect();

		if (oRect) {

			return iPosX >= oRect.left
				&& iPosX <= oRect.left + oRect.width
				&& iPosY >= oRect.top
				&& iPosY <= oRect.top + oRect.height;

		}
		return false;
	};


	/**
	 * Returns true if the first element has a set tabindex
	 *
	 * @return {boolean} If the first element has a set tabindex
	 * @public
	 * @methodOf jQuery.prototype
	 * @name hasTabIndex
	 * @author SAP AG
	 * @since 0.9.0
	 */
	jQuery.fn.hasTabIndex = function hasTabIndex() {
		var oDomRef = this.get(0);
		var iTabIndex = jQuery(oDomRef).attr("tabIndex");
		return !isNaN(iTabIndex) && iTabIndex >= 0;
	};


	/**
	 * Returns the first focusable domRef in a given container (the first element of the collection)
	 *
	 * @return {DOMNode} The domRef
	 * @public
	 * @methodOf jQuery.prototype
	 * @name firstFocusableDomRef
	 * @author SAP AG
	 * @since 0.9.0
	 */
	jQuery.fn.firstFocusableDomRef = function firstFocusableDomRef() {
		var oContainerDomRef = this.get(0);
		var visibilityHiddenFilter = function (idx){return jQuery(this).css("visibility") == "hidden";};
		if (!oContainerDomRef || jQuery(oContainerDomRef).is(':hidden') ||
				jQuery(oContainerDomRef).filter(visibilityHiddenFilter).length == 1) {
			return null;
		}

		var oCurrDomRef = oContainerDomRef.firstChild,
			oDomRefFound = null;

		while (oCurrDomRef) {
			if(oCurrDomRef.nodeType == 1 && jQuery(oCurrDomRef).is(':visible')) {
				if (jQuery(oCurrDomRef).hasTabIndex()) {
					return oCurrDomRef;
				}

				if(oCurrDomRef.childNodes) {
					oDomRefFound = jQuery(oCurrDomRef).firstFocusableDomRef();
					if(oDomRefFound) {
						return oDomRefFound;
					}
				}
			}
			oCurrDomRef = oCurrDomRef.nextSibling;
		}

		return null;
	};


	/**
	 * Returns the last focusable domRef in a given container
	 *
	 * @return {DOMNode} The last domRef
	 * @public
	 * @methodOf jQuery.prototype
	 * @name lastFocusableDomRef
	 * @author SAP AG
	 * @since 0.9.0
	 */
	jQuery.fn.lastFocusableDomRef = function lastFocusableDomRef() {
		var oContainerDomRef = this.get(0);
		var visibilityHiddenFilter = function (idx){return jQuery(this).css("visibility") == "hidden";};
		if (!oContainerDomRef || jQuery(oContainerDomRef).is(':hidden') ||
				jQuery(oContainerDomRef).filter(visibilityHiddenFilter).length == 1) {
			return null;
		}

		var oCurrDomRef = oContainerDomRef.lastChild,
			oDomRefFound = null;

		while (oCurrDomRef) {
			if(oCurrDomRef.nodeType == 1 && jQuery(oCurrDomRef).is(':visible')) {
				if(oCurrDomRef.childNodes) {
					oDomRefFound = jQuery(oCurrDomRef).lastFocusableDomRef();
					if(oDomRefFound) {
						return oDomRefFound;
					}
				}

				if (jQuery(oCurrDomRef).hasTabIndex()) {
					return oCurrDomRef;
				}
			}
			oCurrDomRef = oCurrDomRef.previousSibling;
		}

		return null;
	};


	/**
	 * Sets or returns the scrollLeft value of the first element in the given jQuery collection in right-to-left mode.
	 * Precondition: The element is rendered in RTL mode.
	 *
	 * Reason for this method is that the major browsers use three different values for the same scroll position when in RTL mode.
	 * This method hides those differences and returns/applies the same value that would be returned in LTR mode: The distance in px
	 * how far the given container is scrolled away from the leftmost scroll position.
	 *
	 * Returns "undefined" if no element and no iPos is given.
	 *
	 * @return {jQuery | int} The jQuery collection if iPos is given, otherwise the scroll position, counted from the leftmost position
	 * @public
	 * @methodOf jQuery.prototype
	 * @name scrollLeftRTL
	 * @author SAP AG
	 * @since 0.20.0
	 */
	jQuery.fn.scrollLeftRTL = function scrollLeftRTL(iPos) {
		var oDomRef = this.get(0);
		if (oDomRef) {

			if (iPos === undefined) { // GETTER code
				if (jQuery.browser.msie) {
					return oDomRef.scrollWidth - oDomRef.scrollLeft - oDomRef.clientWidth;

				} else if (jQuery.browser.webkit) {
					return oDomRef.scrollLeft;

				} else if (jQuery.browser.mozilla) {
					return oDomRef.scrollWidth + oDomRef.scrollLeft - oDomRef.clientWidth;

				} else {
					// unrecognized browser; it is hard to return a best guess, as browser strategies are very different, so return the actual value
					return oDomRef.scrollLeft;
				}

			} else { // SETTER code
				oDomRef.scrollLeft = jQuery.sap.denormalizeScrollLeftRTL(iPos);
				return this;
			}
		}
	};

	/**
	 * Returns the MIRRORED scrollLeft value of the first element in the given jQuery collection in right-to-left mode.
	 * Precondition: The element is rendered in RTL mode.
	 *
	 * Reason for this method is that the major browsers return three different values for the same scroll position when in RTL mode.
	 * This method hides those differences and returns the value that would be returned in LTR mode if the UI would be mirrored horizontally:
	 * The distance in px how far the given container is scrolled away from the rightmost scroll position.
	 *
	 * Returns "undefined" if no element is given.
	 *
	 * @return {int} The scroll position, counted from the rightmost position
	 * @public
	 * @methodOf jQuery.prototype
	 * @name scrollRightRTL
	 * @author SAP AG
	 * @since 0.20.0
	 */
	jQuery.fn.scrollRightRTL = function scrollRightRTL() {
		var oDomRef = this.get(0);
		if (oDomRef) {

			if (jQuery.browser.msie) {
				return oDomRef.scrollLeft;

			} else if (jQuery.browser.webkit) {
				return oDomRef.scrollWidth - oDomRef.scrollLeft - oDomRef.clientWidth;

			} else if (jQuery.browser.mozilla) {
				return (-oDomRef.scrollLeft);

			} else {
				// unrecognized browser; it is hard to return a best guess, as browser strategies are very different, so return the actual value
				return oDomRef.scrollLeft;
			}
		}
	};


	/**
	 * For the given scrollLeft value this method returns the scrollLeft value as understood by the current browser in RTL mode.
	 * This value is specific to the given DOM element, as the computation may involve its dimensions.
	 *
	 * So when oDomRef should be scrolled 2px from the leftmost position, the number "2" must be given as iNormalizedScrollLeft
	 * and the result of this method (which may be a large or even negative number, depending on the browser) can then be set as
	 * oDomRef.scrollLeft to achieve the desired (cross-browser-consistent) scrolling position.
	 *
	 * This method does no scrolling on its own, it only calculates the value to set (so it can also be used for animations).
	 *
	 * @param {int} iNormalizedScrollLeft The distance from the leftmost position to which the element should be scrolled
	 * @param {DOMNode} oDomRef The DOM element to which scrollLeft will be applied
	 * @return {int} The scroll position that must be set for the DOM element
	 * @public
	 * @author SAP AG
	 * @since 0.20.0
	 */
	jQuery.sap.denormalizeScrollLeftRTL = function byId(iNormalizedScrollLeft, oDomRef) {

		if (oDomRef) {
			if (jQuery.browser.msie) {
				return oDomRef.scrollWidth - oDomRef.clientWidth - iNormalizedScrollLeft;

			} else if (jQuery.browser.webkit) {
				return iNormalizedScrollLeft;

			} else if (jQuery.browser.mozilla) {
				return oDomRef.clientWidth + iNormalizedScrollLeft - oDomRef.scrollWidth;

			} else {
				// unrecognized browser; it is hard to return a best guess, as browser strategies are very different, so return the actual value
				return iNormalizedScrollLeft;
			}
		}
	};




	/*!
	 * The following functions are taken from jQuery UI 1.8.17
	 *
	 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
	 * Dual licensed under the MIT or GPL Version 2 licenses.
	 * http://jquery.org/license
	 *
	 * http://docs.jquery.com/UI
	 */
	function visible( element ) {
		return !jQuery( element ).parents().andSelf().filter(function() {
			return jQuery.curCSS( this, "visibility" ) === "hidden" ||
			jQuery.expr.filters.hidden( this );
		}).length;
	}

	function focusable( element, isTabIndexNotNaN ) {
		var nodeName = element.nodeName.toLowerCase();
		if ( "area" === nodeName ) {
			var map = element.parentNode,
				mapName = map.name,
				img;
			if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
				return false;
			}
			img = jQuery( "img[usemap=#" + mapName + "]" )[0];
			return !!img && visible( img );
		}
		return ( /input|select|textarea|button|object/.test( nodeName )
			? !element.disabled
			: "a" == nodeName
				? element.href || isTabIndexNotNaN
				: isTabIndexNotNaN)
			// the element and all of its ancestors must be visible
			&& visible( element );
	}


	if (!jQuery.expr[":"].focusable) {
		/*!
		 * The following function is taken from jQuery UI 1.8.17
		 *
		 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
		 * Dual licensed under the MIT or GPL Version 2 licenses.
		 * http://jquery.org/license
		 *
		 * http://docs.jquery.com/UI
		 */
		jQuery.extend( jQuery.expr[ ":" ], {
			/**
			 * This defines the jQuery ":focusable" selector; it is also defined in jQuery UI. If already present, nothing is
			 * done here, so we will not overwrite any previous implementation.
			 * If jQuery UI is loaded later on, this implementation here will be overwritten by that one, which is fine,
			 * as it is semantically the same thing and intended to do exactly the same.
			 */
			focusable: function( element ) {
				return focusable( element, !isNaN( jQuery.attr( element, "tabindex" ) ) );
			}
		});
	}

	/**
	 * Gets the next parent DOM element with a given attribute and attribute value starting above the first given element
	 *
	 * @param {String} sAttibute Name of the attribute
	 * @param {String} sValue Value of the attribute (optional)
	 * @return {DOMNode} null or the DOM reference
	 * @public
	 * @methodOf jQuery.prototype
	 * @name parentByAttribute
	 * @author SAP AG
	 * @since 0.9.0
	 */
	jQuery.fn.parentByAttribute = function parentByAttribute(sAttribute, sValue) {
		if (this.length>0) {
			if (sValue) {
				return this.first().parents("["+sAttribute+"='"+sValue+"']").get(0);
			} else {
				return this.first().parents("["+sAttribute+"]").get(0);
			}
		}
	};


	/**
	 * Returns the window reference for a DomRef
	 *
	 * @param {DOMNode} oDomRef The DOM reference
	 * @return {window} Window reference
	 * @public
	 * @since 0.9.0
	 */
	jQuery.sap.ownerWindow = function ownerWindow(oDomRef){
		if (oDomRef.ownerDocument.parentWindow) {
			return oDomRef.ownerDocument.parentWindow;
		}
		return oDomRef.ownerDocument.defaultView;
	};
	
	
	var _oScrollbarSize;
	
	/**
	 * Returns the size (width of the vertical / height of the horizontal) native browser scrollbars.
	 * 
	 * This function must only be used when the DOM is ready.
	 *
	 * @param {boolean} [bForce=false] force recalculation of size (e.g. when CSS was changed)
	 * @return {object} JSON object with properties <code>width</code> and <code>height</code> (the values are of type number and are pixels).
	 * @public
	 * @since 1.4.0
	 */
	jQuery.sap.scrollbarSize = function(bForce) {
		if(_oScrollbarSize && !bForce){
			return _oScrollbarSize;
		}
		
		if(!document.body){
			return {width: 0, height: 0};
		}
		
		var $Area = jQuery("<DIV/>")
			.css("visibility", "hidden")
			.css("height", "0")
			.css("width", "0")
			.css("overflow", "hidden");
		$Area.prependTo(document.body);
		
		var $Dummy = jQuery("<div style=\"visibility:visible;position:absolute;height:100px;width:100px;overflow:scroll;opacity:0;\"></div>");
		$Area.append($Dummy);

		var oDomRef = $Dummy.get(0);
		var iWidth = oDomRef.offsetWidth - oDomRef.scrollWidth;
		var iHeight = oDomRef.offsetHeight - oDomRef.scrollHeight;

		$Area.remove();
		
		_oScrollbarSize = {width: iWidth, height: iHeight};

		return _oScrollbarSize;
	};

}());

}; // end of jquery.sap.dom

if ( !jQuery.sap.isDeclared('jquery.sap.events') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides functionality related to eventing.
jQuery.sap.declare("jquery.sap.events");
if ( !jQuery.sap.isDeclared('jquery.sap.keycodes') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/*
 * Provides constants for key codes. Useful in the implementation of keypress/keydown event handlers.
 */
jQuery.sap.declare("jquery.sap.keycodes", false);

/**
 * Enumeration of key codes.
 *
 * @namespace
 * @public
 * @since 0.9.0
 */
jQuery.sap.KeyCodes = {
	/**
	 * @type number
	 * @public
	 */
	BACKSPACE : 8,
	/**
	 * @type number
	 * @public
	 */
	TAB : 9,
	/**
	 * @type number
	 * @public
	 */
	ENTER : 13,
	/**
	 * @type number
	 * @public
	 */
	SHIFT : 16,
	/**
	 * @type number
	 * @public
	 */
	CONTROL : 17,
	/**
	 * @type number
	 * @public
	 */
	ALT : 18,
	/**
	 * @type number
	 * @public
	 */
	BREAK : 19,
	/**
	 * @type number
	 * @public
	 */
	CAPS_LOCK : 20,
	/**
	 * @type number
	 * @public
	 */
	ESCAPE : 27,
	/**
	 * @type number
	 * @public
	 */
	SPACE : 32,
	/**
	 * @type number
	 * @public
	 */
	PAGE_UP : 33,
	/**
	 * @type number
	 * @public
	 */
	PAGE_DOWN : 34,
	/**
	 * @type number
	 * @public
	 */
	END : 35,
	/**
	 * @type number
	 * @public
	 */
	HOME : 36,
	/**
	 * @type number
	 * @public
	 */
	ARROW_LEFT : 37,
	/**
	 * @type number
	 * @public
	 */
	ARROW_UP : 38,
	/**
	 * @type number
	 * @public
	 */
	ARROW_RIGHT : 39,
	/**
	 * @type number
	 * @public
	 */
	ARROW_DOWN : 40,
	/**
	 * @type number
	 * @public
	 */
	PRINT : 44,
	/**
	 * @type number
	 * @public
	 */
	INSERT : 45,
	/**
	 * @type number
	 * @public
	 */
	DELETE : 46,
	/**
	 * @type number
	 * @public
	 */
	DIGIT_0 : 48,
	/**
	 * @type number
	 * @public
	 */
	DIGIT_1 : 49,
	/**
	 * @type number
	 * @public
	 */
	DIGIT_2 : 50,
	/**
	 * @type number
	 * @public
	 */
	DIGIT_3 : 51,
	/**
	 * @type number
	 * @public
	 */
	DIGIT_4 : 52,
	/**
	 * @type number
	 * @public
	 */
	DIGIT_5 : 53,
	/**
	 * @type number
	 * @public
	 */
	DIGIT_6 : 54,
	/**
	 * @type number
	 * @public
	 */
	DIGIT_7 : 55,
	/**
	 * @type number
	 * @public
	 */
	DIGIT_8 : 56,
	/**
	 * @type number
	 * @public
	 */
	DIGIT_9 : 57,
	/**
	 * @type number
	 * @public
	 */
	A : 65,
	/**
	 * @type number
	 * @public
	 */
	B : 66,
	/**
	 * @type number
	 * @public
	 */
	C : 67,
	/**
	 * @type number
	 * @public
	 */
	D : 68,
	/**
	 * @type number
	 * @public
	 */
	E : 69,
	/**
	 * @type number
	 * @public
	 */
	F : 70,
	/**
	 * @type number
	 * @public
	 */
	G : 71,
	/**
	 * @type number
	 * @public
	 */
	H : 72,
	/**
	 * @type number
	 * @public
	 */
	I : 73,
	/**
	 * @type number
	 * @public
	 */
	J : 74,
	/**
	 * @type number
	 * @public
	 */
	K : 75,
	/**
	 * @type number
	 * @public
	 */
	L : 76,
	/**
	 * @type number
	 * @public
	 */
	M : 77,
	/**
	 * @type number
	 * @public
	 */
	N : 78,
	/**
	 * @type number
	 * @public
	 */
	O : 79,
	/**
	 * @type number
	 * @public
	 */
	P : 80,
	/**
	 * @type number
	 * @public
	 */
	Q : 81,
	/**
	 * @type number
	 * @public
	 */
	R : 82,
	/**
	 * @type number
	 * @public
	 */
	S : 83,
	/**
	 * @type number
	 * @public
	 */
	T : 84,
	/**
	 * @type number
	 * @public
	 */
	U : 85,
	/**
	 * @type number
	 * @public
	 */
	V : 86,
	/**
	 * @type number
	 * @public
	 */
	W : 87,
	/**
	 * @type number
	 * @public
	 */
	X : 88,
	/**
	 * @type number
	 * @public
	 */
	Y : 89,
	/**
	 * @type number
	 * @public
	 */
	Z : 90,
	/**
	 * @type number
	 * @public
	 */
	WINDOWS : 91,
	/**
	 * @type number
	 * @public
	 */
	CONTEXT_MENU : 93,
	/**
	 * @type number
	 * @public
	 */
	TURN_OFF : 94,
	/**
	 * @type number
	 * @public
	 */
	SLEEP : 95,
	/**
	 * @type number
	 * @public
	 */
	NUMPAD_0 : 96,
	/**
	 * @type number
	 * @public
	 */
	NUMPAD_1 : 97,
	/**
	 * @type number
	 * @public
	 */
	NUMPAD_2 : 98,
	/**
	 * @type number
	 * @public
	 */
	NUMPAD_3 : 99,
	/**
	 * @type number
	 * @public
	 */
	NUMPAD_4 : 100,
	/**
	 * @type number
	 * @public
	 */
	NUMPAD_5 : 101,
	/**
	 * @type number
	 * @public
	 */
	NUMPAD_6 : 102,
	/**
	 * @type number
	 * @public
	 */
	NUMPAD_7 : 103,
	/**
	 * @type number
	 * @public
	 */
	NUMPAD_8 : 104,
	/**
	 * @type number
	 * @public
	 */
	NUMPAD_9 : 105,
	/**
	 * @type number
	 * @public
	 */
	NUMPAD_ASTERISK : 106,
	/**
	 * @type number
	 * @public
	 */
	NUMPAD_PLUS : 107,
	/**
	 * @type number
	 * @public
	 */
	NUMPAD_MINUS : 109,
	/**
	 * @type number
	 * @public
	 */
	NUMPAD_COMMA : 110,
	/**
	 * @type number
	 * @public
	 */
	NUMPAD_SLASH : 111,
	/**
	 * @type number
	 * @public
	 */
	F1 : 112,
	/**
	 * @type number
	 * @public
	 */
	F2 : 113,
	/**
	 * @type number
	 * @public
	 */
	F3 : 114,
	/**
	 * @type number
	 * @public
	 */
	F4 : 115,
	/**
	 * @type number
	 * @public
	 */
	F5 : 116,
	/**
	 * @type number
	 * @public
	 */
	F6 : 117,
	/**
	 * @type number
	 * @public
	 */
	F7 : 118,
	/**
	 * @type number
	 * @public
	 */
	F8 : 119,
	/**
	 * @type number
	 * @public
	 */
	F9 : 120,
	/**
	 * @type number
	 * @public
	 */
	F10 : 121,
	/**
	 * @type number
	 * @public
	 */
	F11 : 122,
	/**
	 * @type number
	 * @public
	 */
	F12 : 123,
	/**
	 * @type number
	 * @public
	 */
	NUM_LOCK : 144,
	/**
	 * @type number
	 * @public
	 */
	SCROLL_LOCK : 145,
	/**
	 * @type number
	 * @public
	 */
	OPEN_BRACKET : 186,
	/**
	 * @type number
	 * @public
	 */
	PLUS : 187,
	/**
	 * @type number
	 * @public
	 */
	COMMA : 188,
	/**
	 * @type number
	 * @public
	 */
	SLASH : 189,
	/**
	 * @type number
	 * @public
	 */
	DOT : 190,
	/**
	 * @type number
	 * @public
	 */
	PIPE : 191,
	/**
	 * @type number
	 * @public
	 */
	SEMICOLON : 192,
	/**
	 * @type number
	 * @public
	 */
	MINUS : 219,
	/**
	 * @type number
	 * @public
	 */
	GREAT_ACCENT : 220,
	/**
	 * @type number
	 * @public
	 */
	EQUALS : 221,
	/**
	 * @type number
	 * @public
	 */
	SINGLE_QUOTE : 222,
	/**
	 * @type number
	 * @public
	 */
	BACKSLASH : 226
};
}; // end of jquery.sap.keycodes


(function(){

	/**
	 * List of DOM events that a UIArea automatically takes care of.
	 *
	 * A control/element doesn't have to bind listeners for these events.
	 * It instead can implement an <code>on<i>event</i>(oEvent)</code> method
	 * for any of these events that it wants to be notified about.
	 *
	 * @public
	 */
	jQuery.sap.ControlEvents = [
		"click",
		"dblclick",
		"focusin",
		"focusout",
		"keydown",
		"keypress",
		"keyup",
		"mousedown",
		"mouseout",
		"mouseover",
		"mouseup",
		"select",
		"selectstart",
		"dragstart",
		"dragenter",
		"dragover",
		"dragleave",
		"dragend",
		"drop",
		"paste"
	];


	/**
	 * Enumeration of all so called "pseudo events", a useful classification
	 * of standard browser events as implied by SAP product standards.
	 *
	 * Whenever a browser event is recognized as one or more pseudo events, then this
	 * classification is attached to the original {@link jQuery.Event} object and thereby
	 * delivered to any jQuery-style listeners registered for that browser event.
	 *
	 * Pure JavaScript listeners can evaluate the classification information using
	 * the {@link jQuery.Event#isPseudoType} method.
	 *
	 * Instead of using the procedure as described above, the SAPUI5 controls and elements
	 * should simply implement an <code>on<i>pseudo-event</i>(oEvent)</code> method. It will
	 * be invoked only when that specific pseudo event has been recognized. This simplifies event
	 * dispatching even further.
	 *
	 * @namespace
	 * @public
	 */
	jQuery.sap.PseudoEvents = {

		/* Pseudo keyboard events */

		/**
		 * Pseudo event for keyboard arrow down without modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapdown: {sName: "sapdown", aTypes: ["keydown"], fnCheck: function (oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.ARROW_DOWN && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard arrow down with modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapdownmodifiers: {sName: "sapdownmodifiers", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.ARROW_DOWN && hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for pseudo 'show' event (F4, Alt + down-Arrow)
		 * @public
		 */
		sapshow: {sName: "sapshow", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return (oEvent.keyCode == jQuery.sap.KeyCodes.F4 && !hasModifierKeys(oEvent)) ||
				(oEvent.keyCode == jQuery.sap.KeyCodes.ARROW_DOWN && checkModifierKeys(oEvent, /*Ctrl*/false, /*Alt*/true, /*Shift*/false));
		}},
		/**
		 * Pseudo event for keyboard arrow up without modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapup: {sName: "sapup", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.ARROW_UP && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard arrow up with modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapupmodifiers: {sName: "sapupmodifiers", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.ARROW_UP && hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for pseudo 'hide' event (Alt + up-Arrow)
		 * @public
		 */
		saphide: {sName: "saphide", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.ARROW_UP && checkModifierKeys(oEvent, /*Ctrl*/false, /*Alt*/true, /*Shift*/false);
		}},
		/**
		 * Pseudo event for keyboard arrow left without modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapleft: {sName: "sapleft", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.ARROW_LEFT && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard arrow left with modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapleftmodifiers: {sName: "sapleftmodifiers", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.ARROW_LEFT && hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard arrow right without modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapright: {sName: "sapright", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.ARROW_RIGHT && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard arrow right with modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		saprightmodifiers: {sName: "saprightmodifiers", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.ARROW_RIGHT && hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard Home/Pos1 with modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		saphome: {sName: "saphome", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.HOME && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard Home/Pos1 without modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		saphomemodifiers: {sName: "saphomemodifiers", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.HOME && hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for  pseudo top event
		 * @public
		 */
		saptop: {sName: "saptop", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.HOME && checkModifierKeys(oEvent, /*Ctrl*/true, /*Alt*/false, /*Shift*/false);
		}},
		/**
		 * Pseudo event for keyboard End without modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapend: {sName: "sapend", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.END && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard End with modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapendmodifiers: {sName: "sapendmodifiers", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.END && hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for pseudo bottom event
		 * @public
		 */
		sapbottom: {sName: "sapbottom", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.END && checkModifierKeys(oEvent, /*Ctrl*/true, /*Alt*/false, /*Shift*/false);
		}},
		/**
		 * Pseudo event for keyboard page up without modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sappageup: {sName: "sappageup", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.PAGE_UP && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard page up with modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sappageupmodifiers: {sName: "sappageupmodifiers", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.PAGE_UP && hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard page down without modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sappagedown: {sName: "sappagedown", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.PAGE_DOWN && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard page down with modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sappagedownmodifiers: {sName: "sappagedownmodifiers", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.PAGE_DOWN && hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for pseudo 'select' event... space, enter, ... without modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapselect: {sName: "sapselect", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return (oEvent.keyCode == jQuery.sap.KeyCodes.ENTER || oEvent.keyCode == jQuery.sap.KeyCodes.SPACE) && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for pseudo 'select' event... space, enter, ... with modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapselectmodifiers: {sName: "sapselectmodifiers", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return (oEvent.keyCode == jQuery.sap.KeyCodes.ENTER || oEvent.keyCode == jQuery.sap.KeyCodes.SPACE) && hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard space without modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapspace: {sName: "sapspace", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.SPACE && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard space with modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapspacemodifiers: {sName: "sapspacemodifiers", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.SPACE && hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard enter without modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapenter: {sName: "sapenter", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.ENTER && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard enter with modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapentermodifiers: {sName: "sapentermodifiers", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.ENTER && hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard backspace without modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapbackspace: {sName: "sapbackspace", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.BACKSPACE && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard backspace with modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapbackspacemodifiers: {sName: "sapbackspacemodifiers", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.BACKSPACE && hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard delete without modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapdelete: {sName: "sapdelete", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.DELETE && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard delete with modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapdeletemodifiers: {sName: "sapdeletemodifiers", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.DELETE && hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for pseudo expand event (keyboard numpad +) without modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapexpand: {sName: "sapexpand", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.NUMPAD_PLUS && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for pseudo expand event (keyboard numpad +) with modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapexpandmodifiers: {sName: "sapexpandmodifiers", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.NUMPAD_PLUS && hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for pseudo collapse event (keyboard numpad -) without modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapcollapse: {sName: "sapcollapse", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.NUMPAD_MINUS && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for pseudo collapse event (keyboard numpad -) with modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapcollapsemodifiers: {sName: "sapcollapsemodifiers", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.NUMPAD_MINUS && hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for pseudo collapse event (keyboard numpad *)
		 * @public
		 */
		sapcollapseall: {sName: "sapcollapseall", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.NUMPAD_ASTERISK && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard escape
		 * @public
		 */
		sapescape: {sName: "sapescape", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.ESCAPE && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard tab (TAB + no modifier)
		 * @public
		 */
		saptabnext: {sName: "saptabnext", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.TAB && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard tab (TAB + shift modifier)
		 * @public
		 */
		saptabprevious: {sName: "saptabprevious", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.TAB && checkModifierKeys(oEvent, /*Ctrl*/false, /*Alt*/false, /*Shift*/true);
		}},
		/**
		 * Pseudo event for pseudo skip forward (F6 + no modifier)
		 * @public
		 */
		sapskipforward: {sName: "sapskipforward", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.F6 && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for pseudo skip back (F6 + shift modifier)
		 * @public
		 */
		sapskipback: {sName: "sapskipback", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.F6 && checkModifierKeys(oEvent, /*Ctrl*/false, /*Alt*/false, /*Shift*/true);
		}},
		//// contextmenu Shift-F10 hack
		//{sName: "sapcontextmenu", aTypes: ["keydown"], fnCheck: function(oEvent) {
		//	return oEvent.keyCode == jQuery.sap.KeyCodes.F10 && checkModifierKeys(oEvent, /*Ctrl*/false, /*Alt*/false, /*Shift*/true);
		//}},

		/**
		 * Pseudo event for pseudo 'decrease' event without modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapdecrease: {sName: "sapdecrease", aTypes: ["keydown"], fnCheck: function(oEvent) {
			var bRtl = sap.ui.getCore().getConfiguration().getRTL();
			var iPreviousKey = bRtl ? jQuery.sap.KeyCodes.ARROW_RIGHT : jQuery.sap.KeyCodes.ARROW_LEFT;
			return (oEvent.keyCode == iPreviousKey || oEvent.keyCode == jQuery.sap.KeyCodes.ARROW_DOWN) && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for pseudo 'decrease' event with modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapdecreasemodifiers: {sName: "sapdecreasemodifiers", aTypes: ["keydown"], fnCheck: function(oEvent) {
			var bRtl = sap.ui.getCore().getConfiguration().getRTL();
			var iPreviousKey = bRtl ? jQuery.sap.KeyCodes.ARROW_RIGHT : jQuery.sap.KeyCodes.ARROW_LEFT;
			return (oEvent.keyCode == iPreviousKey || oEvent.keyCode == jQuery.sap.KeyCodes.ARROW_DOWN) && hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for pseudo 'increase' event without modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapincrease: {sName: "sapincrease", aTypes: ["keydown"], fnCheck: function(oEvent) {
			var bRtl = sap.ui.getCore().getConfiguration().getRTL();
			var iNextKey = bRtl ? jQuery.sap.KeyCodes.ARROW_LEFT : jQuery.sap.KeyCodes.ARROW_RIGHT;
			return (oEvent.keyCode == iNextKey || oEvent.keyCode == jQuery.sap.KeyCodes.ARROW_UP) && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for pseudo 'increase' event with modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapincreasemodifiers: {sName: "sapincreasemodifiers", aTypes: ["keydown"], fnCheck: function(oEvent) {
			var bRtl = sap.ui.getCore().getConfiguration().getRTL();
			var iNextKey = bRtl ? jQuery.sap.KeyCodes.ARROW_LEFT : jQuery.sap.KeyCodes.ARROW_RIGHT;
			return (oEvent.keyCode == iNextKey || oEvent.keyCode == jQuery.sap.KeyCodes.ARROW_UP) && hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for pseudo 'previous' event without modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapprevious: {sName: "sapprevious", aTypes: ["keydown"], fnCheck: function(oEvent) {
			var bRtl = sap.ui.getCore().getConfiguration().getRTL();
			var iPreviousKey = bRtl ? jQuery.sap.KeyCodes.ARROW_RIGHT : jQuery.sap.KeyCodes.ARROW_LEFT;
			return (oEvent.keyCode == iPreviousKey || oEvent.keyCode == jQuery.sap.KeyCodes.ARROW_UP) && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for pseudo 'previous' event with modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sappreviousmodifiers: {sName: "sappreviousmodifiers", aTypes: ["keydown"], fnCheck: function(oEvent) {
			var bRtl = sap.ui.getCore().getConfiguration().getRTL();
			var iPreviousKey = bRtl ? jQuery.sap.KeyCodes.ARROW_RIGHT : jQuery.sap.KeyCodes.ARROW_LEFT;
			return (oEvent.keyCode == iPreviousKey || oEvent.keyCode == jQuery.sap.KeyCodes.ARROW_UP) && hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for pseudo 'next' event without modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapnext: {sName: "sapnext", aTypes: ["keydown"], fnCheck: function(oEvent) {
			var bRtl = sap.ui.getCore().getConfiguration().getRTL();
			var iNextKey = bRtl ? jQuery.sap.KeyCodes.ARROW_LEFT : jQuery.sap.KeyCodes.ARROW_RIGHT;
			return (oEvent.keyCode == iNextKey || oEvent.keyCode == jQuery.sap.KeyCodes.ARROW_DOWN) && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for pseudo 'next' event with modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapnextmodifiers: {sName: "sapnextmodifiers", aTypes: ["keydown"], fnCheck: function(oEvent) {
			var bRtl = sap.ui.getCore().getConfiguration().getRTL();
			var iNextKey = bRtl ? jQuery.sap.KeyCodes.ARROW_LEFT : jQuery.sap.KeyCodes.ARROW_RIGHT;
			return (oEvent.keyCode == iNextKey || oEvent.keyCode == jQuery.sap.KeyCodes.ARROW_DOWN) && hasModifierKeys(oEvent);
		}},
		//// pseudo hotkey event
		//{sName: "saphotkey", aTypes: ["keydown"], fnCheck: function(oEvent) {
		//  return false;
		//}},
		/* TODO: hotkeys: all other events could be hotkeys
		if(UCF_KeyboardHelper.bIsValidHotkey(iKey, bCtrl, bAlt, bShift)) {

			if (iKey == jQuery.sap.KeyCodes.F1 && bNoModifiers) {
				//special handling for FF - in IE the help is handeled by onHelp
				if (UCF_System.sDevice == "ff1") {
					this.fireSapEvent(this.E_SAP_EVENTS.hotkey, oEvent);
				}
			}
			else if (bCtrlOnly && iKey == jQuery.sap.KeyCodes.C && document.selection) {
				//handle ctrl+c centrally if text is selected to allow to copy it instead of firing the hotkey
				var oTextRange = document.selection.createRange();
				if (!oTextRange || oTextRange.text.length <= 0) {
					this.fireSapEvent(this.E_SAP_EVENTS.hotkey, oEvent);
				}
			}
			else {
				this.fireSapEvent(this.E_SAP_EVENTS.hotkey, oEvent);
			}
		}
		*/

		/*
		 * Other pseudo events
		 * @public
		 */

		/**
		 * Pseudo event indicating delayed double click (e.g. for inline edit)
		 * @public
		 */
		sapdelayeddoubleclick: {sName: "sapdelayeddoubleclick", aTypes: ["click"], fnCheck: function(oEvent) {
			var element = jQuery(oEvent.target);
			var currentTimestamp = oEvent.timeStamp;
			var data = element.data("sapdelayeddoubleclick_lastClickTimestamp");
			var lastTimestamp = data || 0;
			element.data("sapdelayeddoubleclick_lastClickTimestamp", currentTimestamp);
			var diff = currentTimestamp - lastTimestamp;
			return (diff >= 300 && diff <= 1300);
		}}

	};

	/**
	 * Ordered array of the {@link jQuery.sap.PseudoEvents}.
	 *
	 * Order is significant as some check methods rely on the fact that they are tested before other methods.
	 * The array is processed during event analysis (when classifying browser events as pseudo events).
	 * @private
	 */
	var PSEUDO_EVENTS = ["sapdown", "sapdownmodifiers", "sapshow", "sapup", "sapupmodifiers", "saphide", "sapleft", "sapleftmodifiers", "sapright", "saprightmodifiers", "saphome", "saphomemodifiers", "saptop", "sapend", "sapendmodifiers", "sapbottom", "sappageup", "sappageupmodifiers", "sappagedown", "sappagedownmodifiers", "sapselect", "sapselectmodifiers", "sapspace", "sapspacemodifiers", "sapenter", "sapentermodifiers", "sapexpand", "sapbackspace", "sapbackspacemodifiers", "sapdelete", "sapdeletemodifiers", "sapexpandmodifiers", "sapcollapse", "sapcollapsemodifiers", "sapcollapseall", "sapescape", "saptabnext", "saptabprevious", "sapskipforward", "sapskipback", "sapprevious", "sappreviousmodifiers", "sapnext", "sapnextmodifiers", "sapdecrease", "sapdecreasemodifiers", "sapincrease", "sapincreasemodifiers", "sapdelayeddoubleclick"];


	//Add mobile touch events if touch is supported or we run in special dev test mode
	(function initTouchEventSupport() {

		function simulateMobileTouchEventSupport(){
			var sConfigKey = "xx-test-mobile"; //see sap.ui.core.Configuration -> M_SETTINGS
			var oCfgData = window["sap-ui-config"];
			return document.location.href.indexOf("sap-ui-"+sConfigKey) > -1 || (oCfgData && oCfgData[sConfigKey]);
		}

		jQuery.sap.touchEventMode = "OFF";

		var aAdditionalControlEvents = [];
		var aAdditionalPseudoEvents = [];

		if("ontouchend" in document){ //Touch events natively supported
			jQuery.sap.touchEventMode = "ON";

			//ensure that "oEvent.touches", ... works (and not only "oEvent.originalEvent.touches", ...)
			jQuery.event.props.push("touches", "targetTouches", "changedTouches");

			//Define additional native events to be added to the event list
			//TODO maybe add "gesturestart", "gesturechange", "gestureend" later ?
			aAdditionalControlEvents.push("touchstart", "touchend", "touchmove", "touchcancel");

		}else if(simulateMobileTouchEventSupport()){ //Touch Simulation mode
			jQuery.sap.touchEventMode = "SIM";
			jQuery.sap.log.warning("MOBILE TOUCH EVENT TEST MODE ACTIVE", "", "jQuery.sap.events");

			function createSimulatedTouch(sName, aOrigEvents) {
				var sHandlerKey = "__"+sName+"Handler";
				var sSapName = "sap"+sName;
				aAdditionalControlEvents.push(sSapName);
				aAdditionalPseudoEvents.push({sName: sName, aTypes: [sSapName], fnCheck: function (oEvent) { return true; }});

				jQuery.event.special[sSapName] = {
					add: function(oHandle) {
						var that = this,
						$this = jQuery(this);
						var fHandler = function(oEvent) {
							if(!(oEvent.type != "mouseout" || (oEvent.type === "mouseout" && jQuery.sap.checkMouseEnterOrLeave(oEvent, that)))){
								return;
							}

							var oNewEvent = jQuery.event.fix(oEvent.originalEvent);
							oNewEvent.type = sSapName;

							//TODO Extend if necessary
							oNewEvent.touches = [{
								identifier: 1,
								pageX: oNewEvent.pageX,
								pageY: oNewEvent.pageY,
								clientX: oNewEvent.clientX,
								clientY: oNewEvent.clientY,
								screenX: oNewEvent.screenX,
								screenY: oNewEvent.screenY,
								radiusX: 1,
								radiusY: 1,
								rotationAngle: 0
							}];

							if(sName === "touchstart" || $this.data("__touch_in_progress")){
								$this.data("__touch_in_progress", "X");
								oHandle.handler.call(that, oNewEvent);
								if(sName === "touchend"){
									$this.removeData("__touch_in_progress");
								}
							}
						};
						$this.data(sHandlerKey + oHandle.guid, fHandler);
						for(var i=0; i<aOrigEvents.length; i++){
							$this.bind(aOrigEvents[i], fHandler);
						}
					},
					remove: function(oHandle) {
						var $this = jQuery(this);
						var fHandler = $this.data(sHandlerKey + oHandle.guid);
						$this.removeData(sHandlerKey + oHandle.guid);
						for(var i=0; i<aOrigEvents.length; i++){
							jQuery.event.remove(this, aOrigEvents[i], fHandler);
						}
					}
				};
			};

			createSimulatedTouch("touchstart", ["mousedown"]);
			createSimulatedTouch("touchend", ["mouseup", "mouseout"]);
			createSimulatedTouch("touchmove", ["mousemove"]);
		}

		if(jQuery.sap.touchEventMode != "OFF"){
			jQuery.sap.require("jquery-mobile-custom");

			//Define additional jQuery Mobile events to be added to the event list
			//TODO taphold cannot be used (does not bubble / has no target property) -> Maybe provide own solution
			aAdditionalControlEvents.push("swipe", "tap", "swipeleft", "swiperight", "scrollstart", "scrollstop");

			//Define additional pseudo events to be added to the event list
			aAdditionalPseudoEvents.push({sName: "swipebegin", aTypes: ["swipeleft", "swiperight"], fnCheck: function (oEvent) {
				var bRtl = sap.ui.getCore().getConfiguration().getRTL();
				return (bRtl && oEvent.type === "swiperight") || (!bRtl && oEvent.type === "swipeleft");
			}});
			aAdditionalPseudoEvents.push({sName: "swipeend", aTypes: ["swipeleft", "swiperight"], fnCheck: function (oEvent) {
				var bRtl = sap.ui.getCore().getConfiguration().getRTL();
				return (!bRtl && oEvent.type === "swiperight") || (bRtl && oEvent.type === "swipeleft");
			}});

			//Add all defined events to the event infrastructure
			jQuery.sap.ControlEvents = jQuery.sap.ControlEvents.concat(aAdditionalControlEvents);

			for(var i=0; i<aAdditionalPseudoEvents.length; i++){
				jQuery.sap.PseudoEvents[aAdditionalPseudoEvents[i].sName] = aAdditionalPseudoEvents[i];
				PSEUDO_EVENTS.push(aAdditionalPseudoEvents[i].sName);
			}
		}
	}());


	/**
	 * Function for initialization of an Array containing all basic event types of the available pseudo events.
	 * @private
	 */
	function initPseudoEventBasicTypes(){
		var mEvents = jQuery.sap.PseudoEvents;
		var aResult = [];
		for (var sName in mEvents) {
			if (mEvents[sName].aTypes) {
				for (var j = 0, js = mEvents[sName].aTypes.length; j < js; j++) {
					var sType = mEvents[sName].aTypes[j];
					if (jQuery.inArray(sType, aResult) == -1) {
						aResult.push(sType);
					}
				}
			}
		}
		return aResult;
	}

	/**
	 * Array containing all basic event types of the available pseudo events.
	 * @private
	 */
	var PSEUDO_EVENTS_BASIC_TYPES = initPseudoEventBasicTypes();

	/**
	 * Convenience method to check an event for a certain combination of modifier keys
	 * @private
	 */
	function checkModifierKeys(oEvent, bCtrlKey, bAltKey, bShiftKey) {
		return oEvent.shiftKey == bShiftKey && oEvent.altKey == bAltKey && getCtrlKey(oEvent) == bCtrlKey;
	}

	/**
	 * Convenience method to check an event for any modifier key
	 * @private
	 */
	function hasModifierKeys(oEvent) {
		return oEvent.shiftKey || oEvent.altKey || getCtrlKey(oEvent);
	}

	/**
	 * Convenience method for handling of Ctrl key, meta key etc.
	 * @private
	 */
	function getCtrlKey(oEvent) {
		return !!(oEvent.metaKey || oEvent.ctrlKey); // double negation doesn't have effect on boolean but ensures null and undefined are equivalent to false.
	}


	/**
	 * Returns an array of names (as strings) identifying {@link jQuery.sap.PseudoEvents} that are fulfilled by this very Event instance.
	 * @returns {String[]} Array of names identifying {@link jQuery.sap.PseudoEvents} that are fulfilled by this very Event instance.
	 * @public
	 */
	jQuery.Event.prototype.getPseudoTypes = function() {
		var aPseudoTypes = [];
		if (jQuery.inArray(this.type, PSEUDO_EVENTS_BASIC_TYPES) != -1) {
			var aPseudoEvents = PSEUDO_EVENTS;
			var ilength = aPseudoEvents.length;
			var oPseudo = null;
			for(var i=0; i<ilength; i++){
				oPseudo = jQuery.sap.PseudoEvents[aPseudoEvents[i]];
				if(oPseudo.aTypes
						&& jQuery.inArray(this.type, oPseudo.aTypes) > -1
						&& oPseudo.fnCheck
						&& oPseudo.fnCheck(this)){
					aPseudoTypes.push(oPseudo.sName);
				}
			}
		}

		this.getPseudoTypes = function(){return aPseudoTypes.slice();};

		return aPseudoTypes.slice();
	};

	/**
	 * Checks whether this instance of {@link jQuery.Event} is of the given <code>sType</code> pseudo type.
	 * @param {string} sType The name of the pseudo type this event should be checked for.
	 * @returns {boolean} <code>true</code> if this instance of jQuery.Event is of the given sType, <code>false</code> otherwise.
	 * @public
	 */
	jQuery.Event.prototype.isPseudoType = function(sType) {
		var aPseudoTypes = this.getPseudoTypes();
		if ( sType ) {
			return jQuery.inArray(sType, aPseudoTypes) > -1;
		} else {
			return aPseudoTypes.length > 0;
		}
	};


	/*
	 * store reference to original preventDefault method
	 */
	var _preventDefault = jQuery.Event.prototype.preventDefault;
	/*
	 * and introduce some keyCode fixing for IE...
	 * this e.g. suppresses the address-field drop down opening in case of sapshow (i.e. F4) in ComboBoxes
	 */
	jQuery.Event.prototype.preventDefault = function() {
		_preventDefault.apply(this, arguments);

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}
		if ( e.keyCode != 0 ) {
			try { // Sometimes setting keycode results in "Access Denied"
				if(!jQuery.browser.mozilla) {
					e.keyCode = 0;
				}
			} catch(ex) {}
		}

	};


	/**
	 * Binds all events for listening with the given callback function
	 * @param {function} fnCallback Callback function
	 * @public
	 */
	jQuery.sap.bindAnyEvent = function bindAnyEvent(fnCallback) {
		if (fnCallback) {
			jQuery(document).bind(jQuery.sap.ControlEvents.join(" "), fnCallback);
		}
	};

	/**
	 * Unbinds all events for listening with the given callback function
	 * @param {function} fnCallback Callback function
	 * @public
	 */
	jQuery.sap.unbindAnyEvent = function unbindAnyEvent(fnCallback) {
		if (fnCallback) {
			jQuery(document).unbind(jQuery.sap.ControlEvents.join(" "), fnCallback);
		}
	};

	/**
	 * Checks a given mouseover or mouseout event whether it is
	 * equivalent to a mouseenter or mousleave event regarding the given DOM reference.
	 * @param {jQuery.Event} oEvent
	 * @param {element} oDomRef
	 * @public
	 */
	jQuery.sap.checkMouseEnterOrLeave = function checkMouseEnterOrLeave(oEvent, oDomRef) {
		if(oEvent.type != "mouseover" && oEvent.type != "mouseout") {
			return false;
		}

		var isMouseEnterLeave = false;
		var element = oDomRef;
		var parent = oEvent.relatedTarget;
		try {
			while ( parent && parent !== element ) {
				parent = parent.parentNode;
			}
			if ( parent !== element ) {
				isMouseEnterLeave = true;
			}
		} catch(e) { }

		return isMouseEnterLeave;
	};

	/**
	 * Constructor for a jQuery.Event object.<br/>
	 * @see "http://www.jquery.com" and "http://api.jquery.com/category/events/event-object/".
	 *
	 * @class Check the jQuery.Event class documentation available under "http://www.jquery.com"<br/>
	 * and "http://api.jquery.com/category/events/event-object/" for details.
	 *
	 * @name jQuery.Event
	 * @public
	 */

	/**
	 * Returns OffsetX of Event. In jQuery there is a bug. In IE the value is in offsetX, in FF in layerX
	 * @returns offsetX
	 * @public
	 */
	jQuery.Event.prototype.getOffsetX = function() {

		if (this.type == 'click'){
			if (this.offsetX){
				return this.offsetX;
			}
			if (this.layerX){
				return this.layerX;
			}
			if (this.originalEvent.layerX){
				return this.originalEvent.layerX;
			}
		}
		// nothing defined -> offset = 0
		return 0;
	};

	/**
	 * Returns OffsetY of Event. In jQuery there is a bug. in IE the value is in offsetY, in FF in layerY
	 * @returns offsetY
	 * @public
	 */
	jQuery.Event.prototype.getOffsetY = function() {

		if (this.type == 'click'){
			if (this.offsetY){
				return this.offsetY;
			}
			if (this.layerY){
				return this.layerY;
			}
			if (this.originalEvent.layerY){
				return this.originalEvent.layerY;
			}
		}
		// nothing defined -> offset = 0
		return 0;
	};

}());

}; // end of jquery.sap.events

if ( !jQuery.sap.isDeclared('jquery.sap.mobile') ) {
  jQuery.sap.declare('jquery.sap.mobile');
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

(function( $ ) {

	// feature and state detection
	$.extend( $.support, {
		retina: window.devicePixelRatio >= 2
	});
	
	var landscape = (window.orientation === undefined) || window.orientation === 90 || window.orientation === -90; // landscape is assumed to be default and returned on desktop browsers
	$.device = $.extend({}, $.device);
	$.device.is = $.extend({
		standalone: window.navigator.standalone,
		landscape: landscape,
		portrait: !landscape,
		iphone: /iphone/i.test(navigator.userAgent),
		ipad: /ipad/i.test(navigator.userAgent)
	},$.device.is);
	
	
	// OS detection
	function getOS(userAgent) {
		userAgent = userAgent || navigator.userAgent;
		var platform = /[\(]([a-zA-TV-Z]+);\s(?:[U]?[;]?)([\D]+)((?:[\d._]*))(?:.*[\)][^\d]*)([\d.]*)\s/;
		var result = userAgent.match(platform);
		if (result) {
			var appleDevices = /iPhone|iPad|iPod/;
			var bbDevices = /PlayBook|BlackBerry/;
			if (result[0].match(appleDevices)){
				result[3] = result[3].replace(/_/g, ".");
				//result[1] contains info of devices
				return({os:"ios", version:result[3]});
			} else if (result[2].match(/Android/)) {
				result[2] = result[2].replace(/\s/g, "");
				return({os:"android", version:result[3]});
			} else if (result[0].match(bbDevices)) {
				return({os:"blackberry", version:result[4]});
			} else {
				// currently we only support iOS, Android, BlackBerry 6.0+ , everything else will be ignored, if more platforms should be supported, logic can be placed here
				return;
			}
		}
	}

	var os = getOS() || {};
	if ( os ) {
		$.os = $.extend({
			os: os.os,
			version: os.version,
			fVersion: parseFloat(os.version)
		}, $.os);
		$.os[os.os] = true;
	}

	var _bInitMobileTriggered = false;

	/**
	 * Does some basic modifications to the HTML page that make it more suitable for mobile apps.
	 * The "options" parameter configures what exactly should be done.
	 *  
	 * It has the following properties:
	 * - viewport: whether to set the viewport in a way that disables zooming (default: true)
	 * - statusBar: the iOS status bar color, "default", "black" or "black-translucent" (default: "default")
	 * - hideBrowser: whether the browser UI should be hidden as far as possible to make the app feel more native (default: true)
	 * - preventScroll: whether native scrolling should be disabled in order to prevent the "rubber-band" effect where the whole window is moved (default: true)
	 * - rootId: the ID of the root element that should be made fullscreen; only used when hideBrowser is set (default: the document.body)
	 * - homeIcon: The icon to be displayed on the home screen of iOS devices after the user does "add to home screen" (default: no icon).
	 *     This icon must be in PNG format. The property can either hold the URL of one single icon which is used for all devices (and possibly scaled, 
	 *     which looks not perfect), or an object holding icon URLs for the different required sizes; one example is:
	 *     {
	 *        'phone':'phone-icon.png',
	 *        'phone@2':'phone-retina.png',
	 *        'tablet':'tablet-icon.png',
	 *        'tablet@2':'tablet-retina.png'
	 *     }
	 *     The respective image sizes are 57/114 px for the phone and 72/144 px for the tablet. If an object is given but the required size is missing 
	 *     from the object, the largest given URL will be used.
	 * - homeIconPrecomposed: whether the home icon already has some glare effect (otherwise iOS will add it) (default: false)
	 * 
	 * @param options
	 * @public
	 */
	$.sap.initMobile = function(options) {
		if (!_bInitMobileTriggered) { // only one initialization per HTML page
			_bInitMobileTriggered = true;

			options = $.extend({}, { // merge in the default values
				viewport: true,
				statusBar: "default",
				hideBrowser: true,
				preventScroll: true,
				homeIconPrecomposed: false
			}, options);

			$(function() {
				var $head = $("head");

				// initialize viewport
				if (options.viewport) {
					$head.append($('<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">'));
				}

				if ($.os.ios) {
					// enable fullscreen when possible
					$head.append($('<meta name="apple-mobile-web-app-capable" content="yes">')); // since iOS 2.1

					// set the status bar style on Apple devices
					$head.append($('<meta name="apple-mobile-web-app-status-bar-style" content="' + options.statusBar + '">')); // "default" or "black" or "black-translucent", since iOS 2.1

					// splash screen
					//<link rel="apple-touch-startup-image" href="/startup.png">
				}

				// Home Icon (also working in Android depending on version and other circumstances)
				var icon = options.homeIcon;
				if (icon) {
					var precomposed = options.homeIconPrecomposed ? "-precomposed" : "";
					if (typeof icon === "string") { // case 1: one home icon to rule them all
						$head.append($('<link rel="apple-touch-icon' + precomposed + '" href="' + icon + '">'));

					} else if (typeof icon === "object") { // case 2: a config object with optimized home icons for different devices
						var getBestIcon = function(res) {
							return icon[res] || icon['tablet@2'] || icon['phone@2'] || icon['phone'] || icon['tablet']; // fallback logic
						};
						var requiredSize = ($.device.is.ipad ? "tablet" : "phone") + ($.support.retina ?  "@2": "");
						var size = ($.device.is.ipad ? 72 : 57) * ($.support.retina ?  2 : 1);
						var sizes = (size === 57) ? '' : 'sizes="' + size + 'x' + size + '"';
						$head.append($('<link rel="apple-touch-icon"' + precomposed + ' ' + sizes + ' href="' + getBestIcon(requiredSize) + '">'));
					}
				}

				// hide browser address bar
				if (options.hideBrowserUi) {
					var hideAddressBar = function() {
						document.body.style.height = (window.outerHeight + 120) + 'px'; // must be large enough to scroll out

						window.setTimeout(function(){
							window.scrollTo(0, 1); 
							var $root = options.rootId ? $.sap.byId(options.rootId) : $(document.body); // TODO: does body work?
							$root.css("height", window.innerHeight  +"px");
						}, 0);
					};

					$(window).bind("load", hideAddressBar).bind("resize", hideAddressBar); // this one helps iOS, but only AFTER initial loading
					//.bind("orientationchange", hideAddressBar) // this one does not seem to be required
				}

				if (options.preventScroll) {
					$(window).bind("touchmove", function(e){e.preventDefault();}); // this one prevents the rubber-band effect - and disables native scrolling
				}
			});
		}
	};

})( jQuery );

}; // end of jquery.sap.mobile

if ( !jQuery.sap.isDeclared('jquery.sap.properties') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides access to Java-like properties files
jQuery.sap.declare("jquery.sap.properties");
if ( !jQuery.sap.isDeclared('jquery.sap.sjax') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/*
 * Provides convenience functions for synchronous communication, based on the jQuery.ajax() function.
 */
jQuery.sap.declare("jquery.sap.sjax", false);

(function() {

	jQuery.sap.sjaxSettings = {
		/**
		 * Whether to return an object consisting of data and status and error codes or only the simple data
		 */
		complexResult: true,

		/**
		 * fallback value when complexResult is set to false and an error occurred. Then fallback will be returned.
		 */
		fallback: undefined
	};

	/**
	 * Convenience wrapper around <code>jQuery.ajax()</code> that avoids the need for callback functions when
	 * synchronous calls are made. If the setting <code>complexResult</code> is true (default), then the return value
	 * is an object with the following properties
	 * <ul>
	 * <li><code>success</code> boolean whether the call succeeded or not
	 * <li><code>data</code> any the data returned by the call. For dataType 'text' this is a string,
	 *                       for JSON it is an object, for XML it is a document. When the call failed, then data is not defined
	 * <li><code>status</code> string a textual status ('success,', 'error', 'timeout',...)
	 * <li><code>statusCode</code> string the HTTP status code of the request
	 * <li><code>error</code> Error an error object (exception) in case an error occurred
	 * </ul>
	 *
	 * When <code>complexResult</code> is false, then in the case of success, only 'data' is returned, in case of an error the
	 * 'fallback' setting is returned (defaults to undefined).
	 *
	 * Note that async=false is always enforced by this method.
	 *
	 * @param {String} oOrigSettings the ajax() settings
	 * @return result, see above
	 *
	 * @public
	 * @since 0.9.0
	 * @SecSink {0|PATH} Parameter is used for future HTTP requests
	 */
	jQuery.sap.sjax = function sjax(oOrigSettings) {

		var s = jQuery.extend(true, {}, jQuery.sap.sjaxSettings, oOrigSettings,

			// the following settings are enforced as this is the rightmost object in the extend call
			{
				async: false,
				success : function(data, textStatus, xhr) {
//					oResult = { success : true, data : data, status : textStatus, statusCode : xhr.status };
					oResult = { success : true, data : data, status : textStatus, statusCode : xhr&&xhr.status };
				},
				error : function(xhr, textStatus, error) {
					oResult = { success : false, data : undefined, status : textStatus, error : error, statusCode : xhr.status };
				}
			});

		var oResult = undefined;

		jQuery.ajax(s);

		if (!s.complexResult) {
			return oResult.success ? oResult.data : s.fallback;
		}

		return oResult;
	};

	/**
	 * Convenience wrapper that checks whether a given web resource could be accessed.
	 * @SecSink {0|PATH} Parameter is used for future HTTP requests
	 * @SecSource {return} Returned value is under control of an external resource
	 */
	jQuery.sap.syncHead = function(sUrl) {
		return jQuery.sap.sjax({type:'HEAD', url: sUrl}).success;
	};

	/**
	 * Convenience wrapper for {@link jQuery.sap.sjax} that enforeces the Http method GET and defaults the
	 * data type of the result to 'text'.
	 *
	 * @param {String} sUrl the URL
	 * @param {String|object} data request parameters in the format accepted by jQuery.ajax()
	 * @param {String} [sDataType='text'] the type of data expected from the server, default is "text"
	 * @return result @see jQuery.sap.sjax
	 *
	 * @public
	 * @since 0.9.0
	 * @SecSink {0 1|PATH} Parameter is used for future HTTP requests
	 * @SecSource {return} Returned value is under control of an external resource
	 */
	jQuery.sap.syncGet = function syncGet(sUrl, data, sDataType) {
		return jQuery.sap.sjax({
			url: sUrl,
			data: data,
			type: 'GET',
			dataType: sDataType || 'text'
		});
	};

	/**
	 * Convenience wrapper for {@link jQuery.sap.sjax} that enforces the Http method POST and defaults the
	 * data type of the result to 'text'.
	 *
	 * @param {String} sUrl the URL
	 * @param {String|object} data request parameters in the format accepted by jQuery.ajax()
	 * @param {String} [sDataType='text'] the type of data expected from the server, default is "text"
	 * @return result @see jQuery.sap.sjax
	 *
	 * @public
	 * @since 0.9.0
	 * @SecSink {0 1|PATH} Parameter is used for future HTTP requests
	 * @SecSource {return} Returned value is under control of an external resource
	 */
	jQuery.sap.syncPost = function syncPost(sUrl, data, sDataType) {
		return jQuery.sap.sjax({
			url: sUrl,
			data: data,
			type: 'POST',
			dataType: sDataType || 'text'
		});
	};

	/**
	 * Convenience wrapper for {@link jQuery.sap.sjax} that enforces the Http method GET and the data type 'text'.
	 * If a fallback value is given, the function simply returns the response as a text or - if some error occurred -
	 * the fallback value. This is useful for applications that don't require detailed error diagnostics.
	 *
	 * If applications need to know about occurring errors, they can either call <code>sjax()</code> directly
	 * or they can omit the fallback value (providing only two parameters to syncGetText()).
	 * They then receive the same complex result object as for the sjax() call.
	 *
	 * @param {String} sUrl the URL
	 * @param {String|object} data request parameters in the format accepted by jQuery.ajax()
	 * @param {String} [fallback] if set, only data is returned (and this fallback instead in case of errors); if unset, a result structure is returned
	 * @return  result @see jQuery.sap.sjax
	 *
	 * @public
	 * @since 0.9.0
	 * @SecSink {0 1|PATH} Parameter is used for future HTTP requests
	 */
	jQuery.sap.syncGetText = function syncGetText(sUrl, data, fallback) {
		return jQuery.sap.sjax({
			url: sUrl,
			data: data,
			type: 'GET',
			dataType: 'text',
			fallback: fallback,
			complexResult : (arguments.length < 3)
		});
	};

	/**
	 * Convenience wrapper for {@link jQuery.sap.sjax} that enforces the Http method GET and the data type 'json'.
	 * If a fallback value is given, the function simply returns the response as an object or - if some error occurred -
	 * the fallback value. This is useful for applications that don't require detailed error diagnostics.
	 *
	 * If applications need to know about occurring errors, they can either call <code>sjax()</code> directly
	 * or they can omit the fallback value (providing only two parameters to syncGetJSON()).
	 * They then receive the same complex result object as for the sjax() call.
	 *
	 * Note that providing "undefined" or "null" as a fallback is different from omitting the fallback (complex result).
	 *
	 * @param {String} sUrl the URL
	 * @param {String|object} data request parameters in the format accepted by jQuery.ajax()
	 * @param {object} [fallback] if set, only data is returned (and this fallback instead in case of errors); if unset, a result structure is returned
	 * @return result @see jQuery.sap.sjax
	 *
	 * @public
	 * @since 0.9.0
	 * @SecSink {0 1|PATH} Parameter is used for future HTTP requests
	 */
	jQuery.sap.syncGetJSON = function syncGetJSON(sUrl, data, fallback) {
		return jQuery.sap.sjax({
			url: sUrl,
			data: data || null,
			type: 'GET',
			dataType: 'json',
			fallback: fallback,
			complexResult : (arguments.length < 3)
		});
	};

}());
}; // end of jquery.sap.sjax


(function() {

	// Javadoc for private inner class "Properties" - this list of comments is intentional!
	/**
	 * @interface  Represents a list of properties (key/value pairs).
	 *
	 * Each key and its corresponding value in the property list is a string.
	 * Values are unicode escaped \ue0012.
	 * Keys are case-sensitive and only alpha-numeric characters with a leading character are allowed.
	 *
	 * Use {@link jQuery.sap.properties} to create an instance of jQuery.sap.util.Properties.
	 *
	 * The getProperty method is used to retrieve a value from the list.
	 * The setProperty method is used to store or change a property in the list.
	 * Additionally, the getKeys method can be used to retrieve an array of all keys that are
	 * currently in the list.
	 *
	 * @author SAP AG
	 * @version 1.5.0-SNAPSHOT
	 * @since 0.9.0
	 * @name jQuery.sap.util.Properties
	 * @public
	 */
	/**
	 * Returns the value of a given key. Optionally, a given default value is returned if the requested key is not in the list.
	 * @param {string} sKey The key of the property
	 * @param {string} [sDefaultValue] Optional, the default value if the requested key is not in the list.
	 * @return {string} The value of a given key. The default value (if given) is returned if the requested key is not in the list.
	 *
	 * @function
	 * @name jQuery.sap.util.Properties.prototype.getProperty
	 */
	/**
	 * Returns an array of all keys in the property list.
	 * @return {array} All keys in the property list.
	 *
	 * @function
	 * @name jQuery.sap.util.Properties.prototype.getKeys
	 */
	/**
	 * Adds or changes a given key to/in the list.
	 * @param {string} sKey The key of the property
	 * @param {string} sValue The value for the key with unicode encoding.
	 *
	 * @function
	 * @name jQuery.sap.util.Properties.prototype.setProperty
	 */
	/**
	 * Creates and returns a clone of the property list.
	 * @return {jQuery.sap.util.Properties} A clone of the property list
	 *
	 * @function
	 * @name jQuery.sap.util.Properties.prototype.clone
	 */

	/*
	 * Implements jQuery.sap.util.Properties
	 */
	var Properties = function() {
		this.mProperties = {};
		this.aKeys = [];
	};

	Properties.prototype = {};

	/*
	 * Implements jQuery.sap.util.Properties.prototype.getProperty
	 */
	Properties.prototype.getProperty = function(sKey, sDefaultValue) {
		var sValue = this.mProperties[sKey];
		if (typeof(sValue)=="string") {
			return sValue;
		}
		else if(sDefaultValue) {
			return sDefaultValue;
		}
		return "";
	};

	/*
	 * Implements jQuery.sap.util.Properties.prototype.getKeys
	 */
	Properties.prototype.getKeys = function() {
		return this.aKeys;
	};

	/*
	 * Implements jQuery.sap.util.Properties.prototype.setProperty
	 */
	Properties.prototype.setProperty = function(sKey, sValue) {
		if (typeof(sValue) != "string") {
			return;

		}		if (typeof(this.mProperties[sKey])!="string") {
			this.aKeys.push(sKey);
		}
		this.mProperties[sKey] = sValue;
	};

	/*
	 * Implements jQuery.sap.util.Properties.prototype.clone
	 */
	Properties.prototype.clone = function() {
		var oClone = new Properties();
		oClone.mProperties = jQuery.extend({}, this.mProperties);
		oClone.aKeys = jQuery.merge([], this.aKeys);
		return oClone;
	};

	/*
	 * Saves the property list to a given URL using a POST request.
	 */
	//sap.ui.resource.Properties.prototype.save = function(sUrl) {
	//	return jQuery.sap.syncPost(sUrl, this.mProperties);
	//};

	/*
	 * Parses the given text sText and sets the properties
	 * in the properties object oProp accordingly.
	 * @param {string} sText the text to parse
	 * @param oProp the properties object to fill
	 * @private
	 */
	function parse(sText, oProp) {
		oProp.mProperties = {};
		oProp.aKeys = [];

		var aLines = sText.split(/\r\n|\r|\n/);
		for (var i = 0; i < aLines.length; i++) {
			var sLine = aLines[i];
			sLine = sLine.replace(/^\s+/g,"");
			//empty line
			if (sLine == "") {
				continue;
			}
			//comment line
			if (sLine.indexOf("#") == 0 || sLine.indexOf("!") == 0) {
				continue;
			}
			while (sLine.lastIndexOf("\\") == sLine.length-1) {
				sLine = sLine.substring(0,sLine.length-1);
				//read lines ahead
				i++;
				var sNewLine = aLines[i].replace(/^\s+/g,"");
				if (sNewLine == "" || sNewLine.indexOf("#") == 0 || sNewLine.indexOf("!") == 0) { //empty lines and comments in the next line break
					break;
				}
				sLine += sNewLine;
			}
			var iSeperatorPos1 = sLine.indexOf("="),
				iSeperatorPos2 = sLine.indexOf(":"),
				iSeperatorPos = 0;
			if ((iSeperatorPos1 < iSeperatorPos2 && iSeperatorPos1 > -1) || iSeperatorPos2 == -1) {
				iSeperatorPos = iSeperatorPos1;
			} else {
				iSeperatorPos = iSeperatorPos2;
			}
			if (iSeperatorPos == -1) {
				continue;
			}
			var sKey = sLine.substring(0,iSeperatorPos).replace(/^\s+|\s+$/g, "");
			oProp.aKeys.push(sKey);
			var sValue = "";
			sValue = sLine.substring(iSeperatorPos+1).replace(/^\s+|\s+$/g, "");
			if (sValue.indexOf("\\") >= 0) {
				sValue = eval("\"" + sValue.replace(/"/g,"\\\"") + "\"");
			}
			oProp.mProperties[sKey] = sValue;
		}
	}

	/**
	 * Creates and returns a new instance of {@link jQuery.sap.util.Properties}.
	 *
	 * If option 'url' is passed, immediately a load request for the given target is triggered.
	 * A property file that is loaded can contain comments with a leading ! or #.
	 * The loaded property list does not contain any comments.
	 *
	 * <b>Example for loading a property file:</b>
	 * <pre>
	 *  jQuery.sap.properties({url : "../myProperty.properties"});
	 * </pre>
	 *
	 * <b>Example for creating an empty properties instance:</b>
	 * <pre>
	 *  jQuery.sap.properties();
	 * </pre>
	 *
	 * <b>Examples for getting and setting properties:</b>
	 * <pre>
	 *	var oProperties = jQuery.sap.properties();
	 *	oProperties.setProperty("KEY_1","Test Key");
	 *	var sValue1 = oProperties.getProperty("KEY_1");
	 *	var sValue2 = oProperties.getProperty("KEY_2","Default");
	 * </pre>
	 *
	 * @public
	 * @param {object} [mParams] Parameters used to initialize the property list
	 * @param {string} [mParams.url] The URL to the .properties file which should be loaded.
	 * @return {jQuery.sap.util.Properties} A new property list instance
	 * @SecSink {0|PATH} Parameter is used for future HTTP requests
	 */
	jQuery.sap.properties = function properties(mParams) {
		var oProp = new Properties();
		mParams = jQuery.extend({url: undefined}, mParams);
		if (typeof(mParams.url) == "string"){
			var sText = jQuery.sap.syncGetText(mParams.url, null, undefined);
			if (typeof(sText) == "string") {
				parse(sText, oProp);
			}
		}
		return oProp;
	};

}());

}; // end of jquery.sap.properties

if ( !jQuery.sap.isDeclared('jquery.sap.resources') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides access to Java-like resource bundles in properties file format
jQuery.sap.declare("jquery.sap.resources");


(function() {

	// Javadoc for private inner class "Bundle" - this list of comments is intentional!
	/**
	 * @interface  Contains locale-specific texts.
	 *
	 * If you need a locale-specific text within your application, you can use the
	 * resource bundle to load the locale-specific file from the server and access
	 * the texts of it.
	 *
	 * Use {@link jQuery.sap.resources} to create an instance of jQuery.sap.util.ResourceBundle.
	 * There you have to specify the URL to the base .properties file of a bundle
     * (.properties without any locale information, e.g. "mybundle.properties"), and optionally
	 * a locale. The locale is defined as a string of the language and an optional country code
	 * separated by underscore (e.g. "en_GB" or "fr"). If no locale is passed, the default
	 * locale is "en".
	 *
	 * With the getText() method of the resource bundle, a locale-specific string value
	 * for a given key will be returned.
	 *
	 * With the given locale, the ResourceBundle requests the locale-specific properties file
	 * (e.g. "mybundle_fr_FR.properties").
	 * If no file is found for the locale "fr_FR", the fall back is requested. The fall back is the
	 * language code without any specific country code, in this case "fr".
	 * The same is true if the getText() method did not find a string value for a given key.
	 * If no language-specific file is found the English file, it is requested with locale "en".
	 * If also the English file is not present, the file without language and country code is requested.
	 * This is the file that is originally used as URL parameter.
	 *
	 * Exception: Fallback for "zh_HK" is "zh_TW" before zh.
	 *
	 * @author SAP AG
	 * @version 1.5.0-SNAPSHOT
	 * @since 0.9.0
	 * @name jQuery.sap.util.ResourceBundle
	 * @public
	 */
	/**
	 * Returns a locale-specific string value for the given key sKey.
	 * @param {string} sKey
	 * @param {string[]} [aArgs] List of parameters which should replace the place holders "{n}" (n is the index) in the found locale-specific string value.
	 * @return {string} The value belonging to the key, if found; otherwise the key itself.
	 *
	 * @function
	 * @name jQuery.sap.util.ResourceBundle.prototype.getText
	 */

	/**
	 * A regular expression that describes language tags according to BCP-47.
	 * @see BCP47 "Tags for Identifying Languages" (http://www.ietf.org/rfc/bcp/bcp47.txt)
	 *
	 * The matching groups are
	 *  0=all
	 *  1=language (shortest ISO639 code + ext. language sub tags | 4digits (reserved) | registered language sub tags)
	 *  2=script (4 letters)
	 *  3=region (2letter language or 3 digits)
	 *  4=variants (separated by '-', Note: capturing group contains leading '-' to shorten the regex!)
	 *  5=extensions (including leading singleton, multiple extensions separated by '-')
	 *  6=private use section (including leading 'x', multiple sections separated by '-')
	 *  
	 *            [-------------------- language ----------------------][--- script ---][------- region --------][------------ variants --------------][--------- extensions --------------][------ private use -------]
	 */
	var rlocale=/^((?:[A-Z]{2,3}(?:-[A-Z]{3}){0,3})|[A-Z]{4}|[A-Z]{5,8})(?:-([A-Z]{4}))?(?:-([A-Z]{2}|[0-9]{3}))?(-[0-9A-Z]{5,8}|(?:[0-9][0-9A-Z]{3}))*(?:-([0-9A-WYZ](?:-[0-9A-Z]{2,8})+))*(?:-(X(?:-[0-9A-Z]{1,8})+))?$/i;

	/**
	 * Resource bundles are stored according to the Java DEvelopment Kit conventions.
	 * JDK uses old language names for a few ISO639 codes ("iw" for "he", "ji" for "yi", "in" for "id" and "sh" for "sr").
	 * Make sure to convert newer codes to older ones before creating file names.
	 */
	var M_ISO639_NEW_TO_OLD = {
		"he" : "iw",
		"yi" : "ji",
		"id" : "in", 
		"sr" : "sh" 
	};
		
	/**
	 * Helper to normalize the given locale (in BCP-47 syntax) to the java.util.Locale format.
	 * @return {string} Normalized locale or undefined if the locale can't be normalized
	 */
	function normalize(sLocale) {
		var m;
		if ( typeof sLocale === 'string' && (m = rlocale.exec(sLocale.replace(/_/g, '-'))) ) {
			var sLanguage = m[1].toLowerCase();
			sLanguage = M_ISO639_NEW_TO_OLD[sLanguage] || sLanguage;
			return sLanguage + (m[3] ? "_" + m[3].toUpperCase() + (m[4] ? "_" + m[4].slice(1).replace("-","_") : "") : "");
		}
	}

	/*
	 * Implements jQuery.sap.util.ResourceBundle
	 */
	var Bundle = function(sUrl, sLocale, bIncludeInfo){
		//last fallback is english if no or no valid locale is given
		//TODO: If the browsers allow to access the users language preference this should be the fallback
		this.sLocale = normalize(sLocale) || "en";
		this.sUrl = sUrl;
		this.bIncludeInfo = bIncludeInfo;
		//declare list of property files that are loaded
		this.aPropertyFiles = [];
		this.aLocales = [];
		//load the most specific property file
		load(this, this.sLocale);
	};

	Bundle.prototype = {};

	/*
	 * Implements jQuery.sap.util.ResourceBundle.prototype.getText
	 */
	Bundle.prototype.getText = function(sKey, aArgs){
		var sValue = null;
		//loop over all loaded property files and return the value for the key if any
		for(var i=0; i<this.aPropertyFiles.length; i++){
			sValue = this.aPropertyFiles[i].getProperty(sKey);
			if(sValue) {
				break;
			}
		}

		//value for this key was not found in the currently loaded property files,
		//load the fallback locales
		if(!sValue){
			var sTempLocale = this.aLocales[0];
			while(sTempLocale.length > 0){
				if(sTempLocale == "zh_HK"){
					sTempLocale = "zh_TW";
				}else{
					if(sTempLocale.length > 2){
						sTempLocale = sTempLocale.substring(0,2);
					}else if(sTempLocale != "en"){
						sTempLocale = "en";
					}else{
						sTempLocale = "";
					}
				}

				var oProperties = load(this, sTempLocale);
				if(oProperties == null) {
					continue;
				}

				//check whether the key is included in the newly loaded property file
				sValue = oProperties.getProperty(sKey);
				if (sValue) {
					break;
				}
			}
		}

		if(!sValue){
			sValue = sKey;
		}

		if(aArgs){
			for(var index=0; index<aArgs.length; index++){
				sValue = sValue.replace("{"+index+"}", aArgs[index]);
			}
		}

		if (this.bIncludeInfo) {
			sValue = new String(sValue);
			sValue.originInfo = {
				source: "Resource Bundle",
				url: this.sUrl,
				locale: this.sLocale,
				key: sKey
			};
		}

		return sValue;
	};

	/*
	 * If a .properties file for the given locale is not loaded yet
	 * in the given bundle, this method loads the .properties file and
	 * adds it to the bundle.
	 * @param {string} sLocale the text to parse
	 * @param oBundle the resource bundle to extend
	 * @return The newly loaded properties or <code>null</code>
	 *         when the properties for the given locale already loaded.
	 * @private
	 */
	function load(oBundle, sLocale) {
		if(jQuery.inArray(sLocale, oBundle.aLocales) == -1){
			var sTempUrl = oBundle.sUrl;
			if(sLocale) {
				sTempUrl = sTempUrl.replace(".properties","_" + sLocale + ".properties");
			}
			var props = jQuery.sap.properties({url : sTempUrl});
			oBundle.aPropertyFiles.push(props);
			oBundle.aLocales.push(sLocale);
			return props;
		}
		return null;
	}

	/**
	 * Creates and returns a new instance of {@link jQuery.sap.util.ResourceBundle}
	 * using the given URL and locale to determine what to load.
	 *
	 * @public
	 * @param {object} [mParams] Parameters used to initialize the resource bundle
	 * @param {string} [mParams.url=""] The URL to the base .properties file of a bundle (.properties file without any locale information, e.g. "mybundle.properties")
	 * @param {string} [mParams.locale="en"] Optional string of the language and an optional country code separated by underscore (e.g. "en_GB" or "fr")
	 * @param {boolean} [mParams.includeInfo=false] Optional boolean whether to include origin information into the returned property values
	 * @return {jQuery.sap.util.ResourceBundle} A new resource bundle instance
	 * @SecSink {0|PATH} Parameter is used for future HTTP requests
	 */
	jQuery.sap.resources = function resources(mParams) {
		mParams = jQuery.extend({url: "", locale: undefined, includeInfo: false}, mParams);
		var oBundle = new Bundle(mParams.url, mParams.locale, mParams.includeInfo);
		return oBundle;
	};

}());

}; // end of jquery.sap.resources

if ( !jQuery.sap.isDeclared('jquery.sap.script') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides miscellaneous utility functions that might be useful for any script
jQuery.sap.declare("jquery.sap.script", false);

(function() {

	/**
	 * Some private variable used for creation of (pseudo-)unique ids.
	 * @type integer
	 * @private
	 */
	var iIdCounter = 0;

	/**
	 * Creates and returns a pseudo-unique id.
	 *
	 * No means for detection of overlap with already present or future UIDs.
	 *
	 * @return {string} A pseudo-unique id.
	 * @public
	 */
	jQuery.sap.uid = function uid() {
		return "id-" + new Date().valueOf() + "-" + iIdCounter++;
	};

	/**
	 * Calls a method after a given delay and returns an id for this timer
	 *
	 * @param {int} iDelay Delay time in milliseconds
	 * @param {object} oObject Object from which the method should be called
	 * @param {string|object} Method function pointer or name of the method
	 * @param {array} [aParameters] Method parameters
	 * @return {string} Id which can be used to cancel the timer with clearDelayedCall
	 * @public
	 */
	jQuery.sap.delayedCall = function delayedCall(iDelay, oObject, method, aParameters) {
		return setTimeout(function(){
			if (jQuery.type(method) == "string") {
				method = oObject[method];
			}
			method.apply(oObject, aParameters ||[]);
		}, iDelay);
	};

	/**
	 * Stops the delayed call.
	 *
	 * The function given when calling delayedCall is not called anymore.
	 *
	 * @param {string} sDelayedCallId The id returned, when calling delayedCall
	 * @public
	 */
	jQuery.sap.clearDelayedCall = function clearDelayedCall(sDelayedCallId) {
		clearTimeout(sDelayedCallId);
		return this;
	};

	/**
	 * Calls a method after a given interval and returns an id for this interval.
	 *
	 * @param {int} iInterval Interval time in milliseconds
	 * @param {object} oObject Object from which the method should be called
	 * @param {string|object} Method function pointer or name of the method
	 * @param {array} [aParameters] Method parameters
	 * @return {string} Id which can be used to cancel the interval with clearIntervalCall
	 * @public
	 */
	jQuery.sap.intervalCall = function intervalCall(iInterval, oObject, method, aParameters) {
		return setInterval(function(){
			if (jQuery.type(method) == "string") {
				method = oObject[method];
			}
			method.apply(oObject, aParameters ||[]);
		}, iInterval);
	};

	/**
	 * Stops the interval call.
	 *
	 * The function given when calling intervalCall is not called anymore.
	 *
	 * @param {string} sIntervalCallId The id returned, when calling intervalCall
	 * @public
	 */
	jQuery.sap.clearIntervalCall = function clearIntervalCall(sIntervalCallId) {
		clearInterval(sIntervalCallId);
		return this;
	};

	// Javadoc for private inner class "UriParams" - this list of comments is intentional!
	/**
	 * @interface  Encapsulates all URI parameters of the current windows location (URL).
	 *
	 * Use {@link jQuery.sap.getUriParameters} to create an instance of jQuery.sap.util.UriParameters.
	 *
	 * @author SAP AG
	 * @version 1.5.0-SNAPSHOT
	 * @since 0.9.0
	 * @name jQuery.sap.util.UriParameters
	 * @public
	 */
	/**
	 * Returns the value(s) of the URI parameter with the given name sName.
	 *
	 * If the boolean parameter bAll is <code>true</code>, an array of string values of all
	 * occurrences of the URI parameter with the given name is returned. This array is empty
	 * if the URI parameter is not contained in the windows URL.
	 *
	 * If the boolean parameter bAll is <code>false</code> or is not specified, the value of the first
	 * occurrence of the URI parameter with the given name is returned. Might be <code>null</code>
	 * if the URI parameter is not contained in the windows URL.
	 *
	 * @param {string} sName The name of the URI parameter.
	 * @param {boolean} [bAll=false] Optional, specifies whether all or only the first parameter value should be returned.
	 * @return {string|array} The value(s) of the URI parameter with the given name
	 * @SecSource {return|XSS} Return value contains URL parameters
	 *
	 * @function
	 * @name jQuery.sap.util.UriParameters.prototype.get
	 */

	/*
	 * Implements jQuery.sap.util.UriParameters
	 */
	var UriParams = function(sUri) {
		this.mParams = {};
		var sQueryString = sUri || window.location.href;
		if ( sQueryString.indexOf('#') >= 0 ) {
			sQueryString = sQueryString.slice(0, sQueryString.indexOf('#'));
		}
		if(sQueryString.indexOf("?") >= 0){
			sQueryString = sQueryString.slice(sQueryString.indexOf("?") + 1);
			var aParameters = sQueryString.split("&"),
				mParameters = {},
				aParameter,
				sName,
				sValue;
			for(var i=0; i<aParameters.length; i++){
				aParameter = aParameters[i].split("=");
				sName = decodeURIComponent(aParameter[0]);
				sValue = aParameter.length > 1 ? decodeURIComponent(aParameter[1].replace(/\+/g,' ')) : "";
				if(sName){
					if(!Object.prototype.hasOwnProperty.call(mParameters, sName)){
						mParameters[sName] = [];
					}
					mParameters[sName].push(sValue);
				}
			}
			this.mParams = mParameters;
		}
	};

	UriParams.prototype = {};

	/*
	 * Implements jQuery.sap.util.UriParameters.prototype.get
	 */
	UriParams.prototype.get = function(sName, bAll) {
		var aValues = Object.prototype.hasOwnProperty.call(this.mParams, sName) ? this.mParams[sName] : [];
		return bAll === true ? aValues : (aValues[0] || null);
	};

	/**
	 * Creates and returns a new instance of {@link jQuery.sap.util.UriParameters}.
	 *
	 * Example for reading a single URI parameter (or the value of the first
	 * occurrence of the URI parameter):
	 * <pre>
	 *  var sValue = jQuery.sap.getUriParameters().get("myUriParam");
	 * </pre>
	 *
	 * Example for reading the values of the first of the URI parameter
	 * (with multiple occurrences):
	 * <pre>
	 *  var aValues = jQuery.sap.getUriParameters().get("myUriParam", true);
	 *  for(i in aValues){
	 *    var sValue = aValues[i];
	 *  }
	 * </pre>
	 *
	 * @public
	 * @return {jQuery.sap.util.UriParameters} A new URI parameters instance
	 */
	jQuery.sap.getUriParameters = function getUriParameters(sUri) {
		return new UriParams(sUri);
	};

	/**
	 * Sorts the given array in-place and removes any duplicates (identified by "===").
	 *
	 * Use <code>jQuery.unique()</code> for arrays of DOMElements.
	 *
	 * @param [Array} An Array of any type
	 * @return {Array} Same array as given (for chaining)
	 * @public
	 */
	jQuery.sap.unique = function(a) {
		jQuery.sap.assert(a instanceof Array, "unique: a must be an array");
		var l=a.length;
		if ( l > 1 ) {
			a.sort();
			for(var i=1,j=0; i<l; i++) {
				// invariant: i is the entry to check, j is the last unique entry known so far
				if ( a[i] !== a[j] ) {
					a[++j] = a[i];
				}
			}
			// cut off the rest - if any
			if ( ++j < l ) {
				a.splice(j, l-j);
			}
		}
		return a;
	};

}());

}; // end of jquery.sap.script

if ( !jQuery.sap.isDeclared('sap.ui.Global') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/**
 * @overview Initialization for the SAP UI Library
 *
 * This module creates the main SAP namespaces {@link sap} and automatically
 * registers it to the OpenAjax hub if that exists.
 *
 * This class provides method {@link #namespace} to register namespaces to the
 * SAP UI Library.
 *
 * @sample
 * Ensures a control can be used afterwards but does not load immediately
 * sap.ui.lazyRequire("sap.ui.core/Control");
 * sap.ui.lazyRequire("sap.ui.commons/Button");
 *
 * @version 1.5.0-SNAPSHOT
 * @author  Martin Schaus, Daniel Brinkmann
 * @public
 */

/*global OpenAjax */// declare unusual global vars for JSLint/SAPUI5 validation

// Register to the OpenAjax Hub if it exists
if (window.OpenAjax && window.OpenAjax.hub) {
	OpenAjax.hub.registerLibrary("sap", "http://www.sap.com/", "0.1", {});
}

jQuery.sap.declare("sap.ui.Global");


/**
 * Root namespace for JavaScript functionality provided by SAP AG.
 *
 * The <code>sap</code> namespace is automatically registered with the
 * OpenAjax hub if it exists.
 *
 * @version 1.5.0-SNAPSHOT
 * @namespace
 * @public
 * @name sap
 */
if ( typeof window.sap !== "object" && typeof window.sap !== "function"  ) {
  window.sap = {};
}

/**
 * The <code>sap.ui</code> namespace is the central OpenAjax compliant entry
 * point for UI related JavaScript functionality provided by SAP.
 *
 * @version 1.5.0-SNAPSHOT
 * @namespace
 * @name sap.ui
 * @public
 */
if ( typeof window.sap.ui !== "object") {
	window.sap.ui = {};
}
sap.ui = jQuery.extend(sap.ui, {
		/**
		 * The version of the SAP UI Library
		 * @type string
		 */
		version: "1.5.0-SNAPSHOT",
		buildinfo : { lastchange : "unknown", buildtime : "20120419-0202" }
	});

/**
 * Ensures that a given a namespace or hierarchy of nested namespaces exists in the
 * current <code>window</code>.
 *
 * @return {object} the innermost namespace of the hierarchy
 * @public
 * @static
 * @deprecated Use jQuery.sap.declare or jQuery.sap.getObject(...,0) instead
 */
sap.ui.namespace = function(sNamespace){

	jQuery.sap.assert(false, "sap.ui.namespace is long time deprecated and shouldn't be used");

	return jQuery.sap.getObject(sNamespace, 0);
};

/**
 * Creates a lazy loading stub for a given class <code>sClassName</code>.
 *
 * If the class has been loaded already, nothing is done. Otherwise a stub object
 * or constructor and - optionally - a set of stub methods are created.
 * All created stubs will load the corresponding module on execution
 * and then delegate to their counterpart in the loaded module.
 *
 * When no methods are given or when the list of methods contains the special name
 * "new" (which is an operator can't be used as method name in JavaScript), then a
 * stub <b>constructor</b> for class <code>sClassName</code> is created.
 * Otherwise,  a plain object is created.
 *
 * <b>Note</b>: Accessing any stub as a plain object without executing it (no matter
 * whether it is a function or an object) won't load the module and therefore most like
 * won't work as expected. This is a fundamental restriction of the lazy loader approach.
 * It could only be fixed with JavaScript 1.5 features that are not available in all
 * UI5 target browsers (e.g. not in IE8).
 *
 * <b>Note</b>: As a side effect of this method, the namespace containing the given
 * class is created <b>immediately</b>.
 *
 * @param {string} sClassName Fully qualified name (dot notation) of the class that should be prepared
 * @param {string} [sMethods='new'] space separated list of additional (static) methods that should be created as stubs
 * @param {string} [sModuleName] name of the module to load, defaults to the class name
 * @public
 * @static
 */
sap.ui.lazyRequire = function(sClassName, sMethods, sModuleName) {

	jQuery.sap.assert(typeof sClassName === "string" && sClassName, "lazyRequire: sClassName must be a non-empty string");
	jQuery.sap.assert(!sMethods || typeof sMethods === "string", "lazyRequire: sMethods must be empty or a string");

	var sFullClass = sClassName.replace(/\//gi,"\."),
		iLastDotPos = sFullClass.lastIndexOf("."),
		sPackage = sFullClass.substr(0, iLastDotPos),
		sClass = sFullClass.substr(iLastDotPos + 1),
		oPackage = jQuery.sap.getObject(sPackage, 0),
		oClass = oPackage[sClass],
		aMethods = (sMethods || "new").split(" "),
		iConstructor = jQuery.inArray("new", aMethods);

	sModuleName = sModuleName || sFullClass;

	if (!oClass) {

		if ( iConstructor >= 0 ) {

			// Create dummy constructor which loads the class on demand
			oClass = function() {
				jQuery.sap.log.debug("lazy stub for '" + sFullClass + "' (constructor) called.");
				jQuery.sap.require(sModuleName);
				var oRealClass = oPackage[sClass];
				jQuery.sap.assert(typeof oRealClass === "function", "lazyRequire: oRealClass must be a function after loading");
				if ( oRealClass._sapUiLazyLoader ) {
					throw new Error("lazyRequire: stub '" + sFullClass + "'has not been replaced by module '" + sModuleName + "'");
				}

				// create a new instance and invoke the constructor
				var oInstance = jQuery.sap.newObject(oRealClass.prototype);
				var oResult = oRealClass.apply(oInstance, arguments);
				if (oResult && (typeof oResult === "function" || typeof oResult === "object")) {
					oInstance = oResult;
				}
				return oInstance;
			};
			// mark the stub as lazy loader
			oClass._sapUiLazyLoader = true;

			aMethods.splice(iConstructor,1);

		} else {

			// Create dummy object
			oClass = {};

		}

		// remember the stub
		oPackage[sClass] = oClass;

	}


	// add stub methods to it
	jQuery.each(aMethods, function (i,sMethod) {
		// check whether method is already available
		if (!oClass[sMethod]) {
			oClass[sMethod] = function() {
				jQuery.sap.log.debug("lazy stub for '" + sFullClass + "." + sMethod + "' called.");
				jQuery.sap.require(sModuleName);
				var oRealClass = oPackage[sClass];
				jQuery.sap.assert(typeof oRealClass === "function" || typeof oRealClass === "object", "lazyRequire: oRealClass must be a function or object after loading");
				jQuery.sap.assert(typeof oRealClass[sMethod] === "function", "lazyRequire: method must be a function");
				if (oRealClass[sMethod]._sapUiLazyLoader ) {
					throw new Error("lazyRequire: stub '" + sFullClass + "." + sMethod + "' has not been replaced by loaded module '" + sModuleName + "'");
				}
				return oRealClass[sMethod].apply(oRealClass, arguments);
			};
			oClass[sMethod]._sapUiLazyLoader = true;
		}
	});

};

/**
 * Returns the URL of a resource that belongs to the given library and has the given relative location within the library.
 * This is mainly meant for static resources like images that are inside the library.
 * It is NOT meant for access to JavaScript modules or anything for which a different URL has been registered with jQuery.sap.registerModulePath(). For
 * these cases use jQuery.sap.getModulePath().
 * It DOES work, however, when the given sResourcePath starts with "themes/" (= when it is a theme-dependent resource). Even when for this theme a different
 * location outside the normal library location is configured.
 *
 * @param sLibraryName the name of a library, like "sap.ui.commons"
 * @param sResourcePath the relative path of a resource inside this library, like "img/mypic.png" or "themes/my_theme/img/mypic.png"
 * @returns the URL of the requested resource
 *
 * @static
 * @public
 */
sap.ui.resource = function(sLibraryName, sResourcePath) {
	jQuery.sap.assert(typeof sLibraryName === "string", "sLibraryName must be a string");
	jQuery.sap.assert(typeof sResourcePath === "string", "sResourcePath must be a string");

	// special handling for theme-dependent resources: move theme folder into module name
	var match = sResourcePath.match(/^themes\/([^\/]+)\//);
	if (match) {
		sLibraryName += ".themes." + match[1];
		sResourcePath = sResourcePath.substr(match[0].length);
	}

	return jQuery.sap.getModulePath(sLibraryName, '/') + sResourcePath;
};

/**
 * Redirects access to resources that are part of the given namespace to a location
 * relative to the assumed <b>application root folder</b>.
 *
 * Any UI5 managed resource (view, controller, control, JavaScript module, CSS file, etc.)
 * whose resource name starts with <code>sNamespace</code>, will be loaded from an
 * equally named subfolder of the <b>application root folder</b>.
 * If the resource name consists of multiple segments (separated by a dot), each segment
 * is assumed to represent an individual folder. In other words: when a resource name is
 * converted to an URL, any dots ('.') are converted to slashes ('/').
 *
 * <b>Limitation:</b> For the time being, the <b>application root folder</b> is assumed to be
 * the same as the folder where the current page resides in.
 *
 * Usage sample:
 * <pre>
 *   // Let UI5 know that resources, whose name starts with "com.mycompany.myapp"
 *   // should be loaded from the URL location "./com/mycompany/myapp"
 *   sap.ui.localResources("com.mycompany.myapp");
 *
 *   // The following call implicitly will use the mapping done by the previous line
 *   // It will load a view from ./com/mycompany/myapp/views/Main.view.xml
 *   sap.ui.view({ view : "com.mycompany.myapp.views.Main", type : sap.ui.core.mvc.ViewType.XML});
 * </pre>
 *
 * When applications need a more flexible mapping between resource names and their location,
 * they can use {@link jQuery.sap.registerModulePath}.
 *
 * It is intended to make this configuration obsolete in future releases, but for the time
 * being, applications must call this method when they want to store resources relative to
 * the assumed application root folder.
 *
 * @param {String} sNamespace Namespace prefix for which to load resources relative to the application root folder
 * @public
 * @static
 * @see jQuery.sap.registerModulePath
 */
sap.ui.localResources = function(sNamespace) {
	jQuery.sap.assert(sNamespace, "sNamespace must not be empty");
	jQuery.sap.registerModulePath(sNamespace, "./" + sNamespace.replace(/\./g, "/"));
};

}; // end of sap.ui.Global

if ( !jQuery.sap.isDeclared('sap.ui.base.EventProvider') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides class sap.ui.base.EventProvider
jQuery.sap.declare("sap.ui.base.EventProvider");
if ( !jQuery.sap.isDeclared('sap.ui.base.Object') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/**
 * SAPUI5 base classes
 *
 * @namespace
 * @name sap.ui.base
 * @public
 */

// Provides class sap.ui.base.Object
jQuery.sap.declare("sap.ui.base.Object");
if ( !jQuery.sap.isDeclared('sap.ui.base.Interface') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides class sap.ui.base.Interface
jQuery.sap.declare("sap.ui.base.Interface");

/**
 * Constructs an instance of sap.ui.base.Interface which restricts access to methods marked as public.
 *
 * @class A class that creates an Interface for an existing class. If a class returns the interface in its constructor,
 *        only the defined functions will be visible, no internals of the class can be accessed.
 *
 * @author Malte Wedel, Daniel Brinkmann
 * @version 1.5.0-SNAPSHOT
 * @param {sap.ui.base.Object}
 *            oObject the instance that needs an interface created
 * @param {string[]}
 *            aMethods the names of the methods, that should be available on this interface
 * @constructor
 * @public
 */
sap.ui.base.Interface = function(oObject, aMethods) {

	// if object is null or undefined, return itself
	if (!oObject) {
		return oObject;
	}

	// this function is inline to not appear as a method on the interface

	function fCreateDelegator(oObject, sMethodName) {
		return function() {
//				return oObject[sMethodName].apply(oObject, arguments);
				var tmp = oObject[sMethodName].apply(oObject, arguments);
				return (!(tmp instanceof sap.ui.core.Element)&&(tmp instanceof sap.ui.base.Object))?tmp.getInterface():tmp;
			};
	}

	// if there are no methods return
	if (!aMethods) {
		return {};
	}

	var sMethodName;

	// create functions for all delegated methods
	// PERFOPT: 'cache' length of aMethods to reduce # of resolutions
	for (var i = 0, ml = aMethods.length; i < ml; i++) {
		sMethodName = aMethods[i];
		this[sMethodName] = fCreateDelegator(oObject, sMethodName);
	}

};
}; // end of sap.ui.base.Interface

if ( !jQuery.sap.isDeclared('sap.ui.base.Metadata') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides class sap.ui.base.Metadata
jQuery.sap.declare("sap.ui.base.Metadata");


/**
 * Creates a new metadata object from the given static infos.
 *
 * @param {string} sClassName fully qualified name of the class that is described by this metadata object
 * @param {object} oClassInfo info to construct the class and its metadata from
 *
 * @class Metadata for a class.
 * @author Frank Weigel
 * @version 1.5.0-SNAPSHOT
 * @since 0.8.6
 * @public
 */
sap.ui.base.Metadata = function(sClassName, oClassInfo) {

	jQuery.sap.assert(typeof sClassName === "string" && sClassName, "Metadata: sClassName must be a non-empty string");
	jQuery.sap.assert(typeof oClassInfo === "object", "Metadata: oClassInfo must be empty or an object");

	// support for old usage of Metadata
	if ( !oClassInfo || typeof oClassInfo.metadata !== "object" ) {
		oClassInfo = {
			metadata : oClassInfo || {},
			// retrieve class by its name. Using a lookup costs time but avoids the need for redundant arguments to this function
			constructor : jQuery.sap.getObject(sClassName)
		};
		oClassInfo.metadata.__version = 1.0;
	}
	oClassInfo.metadata.__version = oClassInfo.metadata.__version || 2.0;
	if ( typeof oClassInfo.constructor !== "function" ) {
		throw Error("constructor for class " + sClassName + " must have been declared before creating metadata for it");
	}

	// invariant: oClassInfo exists, oClassInfo.metadata exists, oClassInfo.constructor exists
	this._sClassName = sClassName;
	this._oClass = oClassInfo.constructor;
	this.extend(oClassInfo);
};

/**
 * @private
 * @final
 */
sap.ui.base.Metadata.prototype.extend = function(oClassInfo) {
	this.applySettings(oClassInfo);
	this.afterApplySettings();
};

/**
 * @private
 * @since 1.3.1
 */
sap.ui.base.Metadata.prototype.applySettings = function(oClassInfo) {

	var oStaticInfo = oClassInfo.metadata,
		oPrototype, n;

	if ( oStaticInfo.baseType ) {
		// lookup base class by its name - same reasoning as above
		var oParentClass = jQuery.sap.getObject(oStaticInfo.baseType);
		if ( typeof oParentClass !== "function" ) {
			jQuery.sap.log.fatal("base class '" + oStaticInfo.baseType + "' does not exist");
		}
		// link metadata with base metadata
		if ( oParentClass.getMetadata ) {
			this._oParent = oParentClass.getMetadata();
			jQuery.sap.assert(oParentClass === oParentClass.getMetadata().getClass(), "Metadata: oParentClass must match the class in the parent metadata");
		} else {
			// fallback, if base class has no metadata
			this._oParent = new sap.ui.base.Metadata(oStaticInfo.baseType, {});
		}
	} else {
		this._oParent = undefined;
	}

	this._bAbstract = !!oStaticInfo["abstract"];
	this._bFinal = !!oStaticInfo["final"];

	// handle interfaces
	this._aInterfaces = jQuery.sap.unique(oStaticInfo.interfaces || []);

	// take over metadata from static info
	this._aPublicMethods = jQuery.sap.unique(oStaticInfo.publicMethods || []);

	// enrich prototype
	oPrototype = this._oClass.prototype;
	for(n in oClassInfo) {
		if ( n !== "metadata" && n !== "constructor" ) {
			oPrototype[n] = oClassInfo[n];
			if ( !n.match(/^_|^on|^init$|^exit$/) ) {
				// TODO hard coded knowledge about event handlers ("on") and about init/exit hooks is not nice....
				this._aPublicMethods.push(n);
			}
		}
	}

};

/**
 * Called after new settings have been applied.
 *
 * Typically, this method is used to do some cleanup (e.g. uniqueness)
 * or to calculate an optimized version of some data.
 * @private
 * @since 1.3.1
 */
sap.ui.base.Metadata.prototype.afterApplySettings = function() {
	// create the flattened "all" view
	if ( this._oParent ) {
		//this._aAllInterfaces = jQuery.sap.unique(this._oParent._aAllInterfaces.concat(this._aInterfaces));
		this._aAllPublicMethods = jQuery.sap.unique(this._oParent._aAllPublicMethods.concat(this._aPublicMethods));
	} else {
		//this._aAllInterfaces = this._aInterfaces;
		this._aAllPublicMethods = this._aPublicMethods;
	}

};

/**
 * Returns the fully qualified name of the class that is described by this metadata object
 * @return {string} name of the described class
 * @public
 */
sap.ui.base.Metadata.prototype.getName = function() {
	return this._sClassName;
};

/**
 * Returns the (constructor of the) class described by this metadata object.
 * @return {function} class described by this metadata
 * @public
 */
sap.ui.base.Metadata.prototype.getClass = function() {
	return this._oClass;
};

/**
 * Returns the metadata object of the base class of the class described by this metadata object
 * or null if the class has no (documented) base class.
 *
 * @return {sap.ui.base.Metadata} metadata of the base class
 * @public
 */
sap.ui.base.Metadata.prototype.getParent = function() {
	return this._oParent;
};

/**
 * Returns an array with the names of the public methods declared by this class.
 *
 * @return {string[]} array with names of public methods declared by this class
 * @public
 */
sap.ui.base.Metadata.prototype.getPublicMethods = function() {
	return this._aPublicMethods;
};

/**
 * Returns an array with the names of all public methods declared by this class
 * and its ancestors.
 *
 * @return {string[]} array with names of all public methods provided by this class and its ancestors
 * @public
 */
sap.ui.base.Metadata.prototype.getAllPublicMethods = function() {
	return this._aAllPublicMethods;
};

/**
 * Returns the names of interfaces implemented by this class.
 * As the representation of interfaces is not clear yet, this method is still private.
 *
 * @return {string} array of names of implemented interfaces
 * @private
 */
sap.ui.base.Metadata.prototype.getInterfaces = function() {
	return this._aInterfaces;
};

/**
 * Checks whether the class described by this object or one of its ancestors
 * implements the given interface.
 *
 * @param {string} sInterface name of the interface to test for (in dot notation)
 * @return {boolean} whether this class implements the interface
 * @public
 */
sap.ui.base.Metadata.prototype.isInstanceOf = function(sInterface) {
	if ( this._oParent ) {
		if ( this._oParent.isInstanceOf(sInterface) ) {
			return true;
		}
	};

	var a=this._aInterfaces;
	for(var i=0,l=a.length; i<l; i++) {
		// FIXME doesn't handle interface inheritance (requires object representation for interfaces)
		if ( a[i] === sInterface ) {
			return true;
		}
	}

	return false;
};

sap.ui.base.Metadata.prototype.isFinal = function() {
	return this._bFinal;
};

/**
 * Adds one or more new methods to the list of API methods.
 *
 * Can be used by contributer classes (like the EnabledPropagator) to enrich the declared set of methods.
 * The method can either be called with multiple names (strings) or with one array of strings.
 *
 * <b>Note</b>: the newly added method(s) will only be visible in {@link sap.ui.base.Interface interface}
 * objects that are created <i>after</i> this method has been called.
 *
 * @param {string||string[]} sMethod name(s) of the new method(s)
 */
sap.ui.base.Metadata.prototype.addPublicMethods = function(sMethod /* ... */) {
	var aNames = (sMethod instanceof Array) ? sMethod : arguments;
	function upush(a,v) {
		Array.prototype.push.apply(a, v); // appends "inplace"
		jQuery.sap.unique(a);
	}
	upush(this._aPublicMethods, aNames);
	upush(this._aAllPublicMethods, aNames);
};

/**
 * @since 1.3.1
 * @private
 */
sap.ui.base.Metadata.createClass = function (fnBaseClass, sClassName, oClassInfo, FNMetaImpl) {

	if ( typeof fnBaseClass === "string" ) {
		FNMetaImpl = oClassInfo;
		oClassInfo = sClassName;
		sClassName = fnBaseClass;
		fnBaseClass = null;
	}

	jQuery.sap.assert(!fnBaseClass || typeof fnBaseClass === "function");
	jQuery.sap.assert(typeof sClassName === "string" && !!sClassName);
	jQuery.sap.assert(!oClassInfo || typeof oClassInfo === "object");
	jQuery.sap.assert(!FNMetaImpl || typeof FNMetaImpl === "function");

	// normalize oClassInfo
	oClassInfo = oClassInfo || {};
	oClassInfo.metadata = oClassInfo.metadata || {};
	if ( !oClassInfo.hasOwnProperty('constructor') ) {
		oClassInfo.constructor = undefined;
	}
	FNMetaImpl = FNMetaImpl || sap.ui.base.Metadata;

	var fnClass = oClassInfo.constructor;
	jQuery.sap.assert(!fnClass || typeof fnClass === "function");

	// ensure defaults
	if ( fnBaseClass ) {
		// default constructor just delegates to base class
		fnClass = fnClass || function() { fnBaseClass.apply(this, arguments); };
		// create prototype chain
		fnClass.prototype = jQuery.sap.newObject(fnBaseClass.prototype);
		fnClass.prototype.constructor = fnClass;
		// enforce correct baseType
		oClassInfo.metadata.baseType = fnBaseClass.getMetadata().getName();
	} else {
		// default constructor does nothing
		fnClass = fnClass || function() { };
		// enforce correct baseType
		delete oClassInfo.metadata.baseType;
	}
	oClassInfo.constructor = fnClass;

	// make the class visible as JS Object
	jQuery.sap.setObject(sClassName, fnClass);

	// add metadata
	var oMetadata = new FNMetaImpl(sClassName, oClassInfo);
	fnClass.getMetadata = fnClass.prototype.getMetadata = jQuery.sap.getter(oMetadata);

	// enrich function
	if ( !fnClass.getMetadata().isFinal() ) {
		fnClass.extend = function(sSCName, oSCClassInfo, fnSCMetaImpl) {
			return sap.ui.base.Metadata.createClass(fnClass, sSCName, oSCClassInfo, fnSCMetaImpl || FNMetaImpl);
		};
	}

	return fnClass;
};


}; // end of sap.ui.base.Metadata


/**
 * Constructor for a sap.ui.base.Object.
 *
 * @class Base class for all SAPUI5 Objects
 * @abstract
 * @author Malte Wedel
 * @version 1.5.0-SNAPSHOT
 * @public
 * @name sap.ui.base.Object
 */
sap.ui.base.Metadata.createClass("sap.ui.base.Object", {

	constructor : function() {
		// complain if 'this' is not an instance of a subclass
		if ( !(this instanceof sap.ui.base.Object) ) {
			throw Error("Cannot instantiate object: \"new\" is missing!");
		}
	}

});

/**
 * Destructor method for objects
 * @public
 */
sap.ui.base.Object.prototype.destroy = function() {
};

/**
 * Returns the public interface of the object.
 *
 * @return {sap.ui.base.Interface} the public interface of the object
 * @public
 */
sap.ui.base.Object.prototype.getInterface = function() {
	// New implementation that avoids the overhead of a dedicated member for the interface
	// initially, an Object instance has no associated Interface and the getInterface
	// method is defined only in the prototype. So the code here will be executed.
	// It creates an interface (basically the same code as in the old implementation)
	var oInterface = new sap.ui.base.Interface(this, this.getMetadata().getAllPublicMethods());
	// Now this Object instance gets a new, private implementation of getInterface
	// that returns the newly created oInterface. Future calls of getInterface on the
	// same Object therefore will return the already created interface
	this.getInterface = jQuery.sap.getter(oInterface);
	// as the first caller doesn't benefit from the new method implementation we have to
	// return the created interface as well.
	return oInterface;
};

/**
 * Returns the metadata for the class that this object belongs to.
 * This method is only defined when metadata has been declared by using {@link #defineClass}.
 *
 * @name sap.ui.base.Object.prototype#getMetadata
 * @function
 * @public
 */

/**
 * Creates a subclass of class sap.ui.base.Object with name <code>sClassName</code>
 * and enriches it with the information contained in <code>oClassInfo</code>.
 *
 * <code>oClassInfo</code> might contain three kinds of informations:
 * <ul>
 * <li><code>metadata:</code> an (optional) object literal with metadata about the class.
 * The information in the object literal will be wrapped by an instance of {@link sap.ui.base.Metadata Metadata}
 * and might contain the following information
 * <ul>
 * <li><code>interfaces:</code> {string[]} (optional) set of names of implemented interfaces (defaults to no interfaces)</li>
 * <li><code>publicMethods:</code> {string[]} (optional) list of methods that should be part of the public
 * facade of the class</li>
 * <li><code>abstract:</code> {boolean} (optional) flag that marks the class as abstract (purely informational, defaults to false)</li>
 * <li><code>final:</code> {boolean} (optional) flag that marks the class as final (defaults to false)</li>
 * </ul>
 * Subclasses of sap.ui.base.Object can enrich the set of supported metadata (e.g. see {@link sap.ui.core.Element.extend}).
 * </li>
 *
 * <li><code>constructor:</code> a function that serves as a constructor function for the new class.
 * If no constructor function is given, the framework creates a default implementation that delegates all
 * its arguments to the constructor function of the base class.
 * </li>
 *
 * <li><i>any-other-name:</i> any other property in the <code>oClassInfo</code> is copied into the prototype
 * object of the newly created class. Callers can thereby add methods or properties to all instances of the
 * class. But be aware that the given values are shared between all instances of the class. Usually, it doesn't
 * make sense to use primitive values here other than to declare public constants.
 * </li>
 *
 * </ul>
 *
 * The prototype object of the newly created class uses the same prototype as instances of the base class
 * (prototype chaining).
 *
 * A metadata object is always created, even if there is no <code>metadata</code> entry in the <code>oClassInfo</code>
 * object. A getter for the metadata is always attached to the prototype and to the class (constructor function)
 * itself.
 *
 * Last but not least, with the third argument <code>FNMetaImpl</code> the constructor of a metadata class
 * can be specified. Instances of that class will be used to represent metadata for the newly created class
 * and for any subclass created from it. Typically, only frameworks will use this parameter to enrich the
 * metadata for a new class hierarchy they introduce (e.g. {@link sap.ui.core.Element.extend Element}).
 *
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] structured object with informations about the class
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.base.Metadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.ui.base.Object.extend
 * @function
 * @since 1.3.1
 */

/**
 * Creates metadata for a given class and attaches it to the constructor and prototype of that class.
 *
 * After creation, metadata can be retrieved with getMetadata().
 *
 * The static info can at least contain the following entries:
 * <ul>
 * <li>baseType: {string} fully qualified name of a base class or empty
 * <li>publicMethods: {string} an array of method names that will be visible in the interface proxy returned by {@link #getInterface}
 * </ul>
 *
 * @param {string} sClassName name of an (already declared) constructor function
 * @param {object} oStaticInfo static info used to create the metadata object
 * @param {string} oStaticInfo.baseType qualified name of a base class
 * @param {string[]} oStaticInfo.publicMethods array of names of public methods
 * @param {function} [xMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.base.Metadata.
 *
 * @return {sap.ui.base.Metadata} the created metadata object
 * @public
 * @static
 * @deprecated Since 1.3.1. Use the static <code>extend</code> method of the desired base class (e.g. {@link sap.ui.base.Object.extend})
 */
sap.ui.base.Object.defineClass = function(sClassName, oStaticInfo, FNMetaImpl) {
	// create Metadata object
	var oMetadata = new (FNMetaImpl || sap.ui.base.Metadata)(sClassName, oStaticInfo);
	var fnClass = oMetadata.getClass();
	fnClass.getMetadata = fnClass.prototype.getMetadata = jQuery.sap.getter(oMetadata);
	// enrich function
	if ( !oMetadata.isFinal() ) {
		fnClass.extend = function(sSCName, oSCClassInfo, fnSCMetaImpl) {
			return sap.ui.base.Metadata.createClass(fnClass, sSCName, oSCClassInfo, fnSCMetaImpl || FNMetaImpl);
		};
	}
	jQuery.sap.log.debug("defined class '" + sClassName + "'" + (oMetadata.getParent() ? " as subclass of " + oMetadata.getParent().getName() : "") );
	return oMetadata;
};

}; // end of sap.ui.base.Object

if ( !jQuery.sap.isDeclared('sap.ui.base.Event') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides class sap.ui.base.Event
jQuery.sap.declare("sap.ui.base.Event");


/**
 * Creates an event with the given sId, linked to the provided oSource and enriched with the mParameters.
 *
 * @param {string} sId The id of the event
 * @param {sap.ui.base.EventProvider} oSource The source of the event
 * @param {Object} mParameters A map of parameters for this event
 *
 * @class An Event object consisting of an id, a source and a map of parameters
 * @extends sap.ui.base.Object
 * @implements sap.ui.base.Poolable
 * @author Malte Wedel, Daniel Brinkmann
 * @version 1.5.0-SNAPSHOT
 * @public
 */
// TODO Previous documentation stated that sId is numerical, but this seems not to be true
sap.ui.base.Event = function(sId, oSource, mParameters) {

	sap.ui.base.Object.apply(this);

	if (arguments.length > 0) {
		this.init(sId, oSource, mParameters);
	}

};
sap.ui.base.Event.prototype = jQuery.sap.newObject(sap.ui.base.Object.prototype);

/**
 * Init this event with its data.
 *
 * The <code>init</code> method is called by an object pool when the
 * object is (re-)activated for a new caller.
 *
 * When no <code>mParameters</code> are given, an empty object is used instead.
 *
 * @param {string} sId The id of the event
 * @param {sap.ui.base.EventProvider} oSource The source of the event
 * @param {Object} [mParameters] the event parameters
 *
 * @see sap.ui.base.Poolable.prototype#init
 */
sap.ui.base.Event.prototype.init = function(sId, oSource, mParameters) {
	jQuery.sap.assert(typeof sId === "string", "Event.init: sId must be a string");
	jQuery.sap.assert(oSource instanceof sap.ui.base.EventProvider, "Event.init: oSource must be an EventProvider");

	this.sId = sId;
	this.oSource = oSource;
	this.mParameters = mParameters || {};
	this.bCancelBubble = false;
	this.bPreventDefault = false;
};

/**
 * Reset event data, needed for pooling
 * @see sap.ui.base.Poolable.prototype#reset
 */
sap.ui.base.Event.prototype.reset = function() {
	this.sId = "";
	this.oSource = null;
	this.mParameters = null;
	this.bCancelBubble = false;
	this.bPreventDefault = false;
};

/**
 * Returns the id of the event
 * @return {string} The id of the event
 * @public
 */
sap.ui.base.Event.prototype.getId = function() {

	return this.sId;

};

/**
 * Returns the source of the event
 * @return {sap.ui.base.EventProvider} The source of the event
 * @public
 */
sap.ui.base.Event.prototype.getSource = function() {

	return this.oSource;

};

/**
 * Returns all parameter values of the event keyed by their names.
 * @return {map} All parameters of the event keyed by name
 * @public
 */
sap.ui.base.Event.prototype.getParameters = function() {

	return this.mParameters;

};

/**
 * Returns the value of the parameter with the given sName.
 *
 * @param {string} sName the name of the parameter to return
 * @return {any} the value for the named parameter
 * @public
 */
sap.ui.base.Event.prototype.getParameter = function(sName) {

	jQuery.sap.assert(typeof sName === "string" && sName, "Event.getParameter: sName must be a non-empty string");

	return this.mParameters[sName];

};

/**
 * Cancel bubbling of the event.
 * @public
 */
sap.ui.base.Event.prototype.cancelBubble = function() {

	this.bCancelBubble = true;

};

/**
 * Prevent the default action of this event.
 * @public
 */
sap.ui.base.Event.prototype.preventDefault = function() {

	this.bPreventDefault = true;

};


}; // end of sap.ui.base.Event

if ( !jQuery.sap.isDeclared('sap.ui.base.ObjectPool') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides class sap.ui.base.ObjectPool
jQuery.sap.declare("sap.ui.base.ObjectPool");


/**
 * Creates an ObjectPool instance based on the given oObjectClass.&lt;br/&gt;
 * If there is a free pooled instance, returns that one, otherwise creates a new one.&lt;br/&gt;
 * In order to be maintained by the ObjectPool, oObjectClass must implement
 * methods described in the class description.
 *
 * @param {function} oObjectClass constructor for the class of objects that this pool should manage
 *
 * @class Manages a pool of objects all of the same type;
 * the type has to be specified at pool construction time.
 *
 * Maintains a list of free objects of the given type.
 * If {@link sap.ui.base.ObjectPool.prototype.borrowObject} is called, an existing free object
 * is taken from the pool and the <code>init</code> method is called on this
 * object.
 *
 * When no longer needed, any borrowed object should be returned to
 * the pool by calling {@link #returnObject}. At that point in time,
 * the reset method is called on the object and the object is added to the
 * list of free objects.
 *
 * See {@link sap.ui.base.Poolable} for a description of the contract for poolable objects.
 *
 * Example:
 * <pre>
 *   this.oEventPool = new sap.ui.base.ObjectPool(sap.ui.base.Event);
 *   var oEvent = this.oEventPool.borrowObject(iEventId, mParameters);
 * </pre>
 *
 * @extends sap.ui.base.Object
 * @author Malte Wedel
 * @version 1.5.0-SNAPSHOT
 * @constructor
 * @public
 */
sap.ui.base.ObjectPool = function(oObjectClass) {

	sap.ui.base.Object.apply(this);

	this.oObjectClass = oObjectClass;

	this.aFreeObjects = [];
//	this.aUsedObjects = []; //PERFOPT: Holding those is currently senseless.

};

sap.ui.base.ObjectPool.prototype = jQuery.sap.newObject(sap.ui.base.Object.prototype);

/**
 * Borrows a free object from the pool. Any arguments to this method
 * are forwarded to the init method of the borrowed object.
 *
 * @param {any} [any] optional initialization parameters for the borrowed object
 * @return {object} the borrowed object of the same type that has been specified for this pool
 * @public
 */
sap.ui.base.ObjectPool.prototype.borrowObject = function() {

	// PERFOPT: Reduced callstack
	var oObject = this.aFreeObjects.length == 0 ?
			new this.oObjectClass() :
				this.aFreeObjects.pop();
	oObject.init.apply(oObject, arguments);
//	this.aUsedObjects.push(oObject); //PERFOPT: Holding those is currently senseless.

	return oObject;
};

/**
 * Returns an object to the pool. The object must have been borrowed from this
 * pool beforehand. The reset method is called on the object before it is added
 * to the set of free objects.
 *
 * @param {object} the object to return to the pool
 * @public
 */
sap.ui.base.ObjectPool.prototype.returnObject = function(oObject) {

	oObject.reset();
	// If the next line is ever activated again, ensure not simply the topmost object is poped but the one returned!!
//	this.aUsedObjects.pop(); //PERFOPT: Holding those is currently senseless.
	this.aFreeObjects.push(oObject);

};


/**
 * Poolable objects must provide a no-arg constructor which is used by the pool
 * to construct new, unused objects.
 *
 * To be more convenient to use, poolable objects should implement their constructor
 * in a way that it either can be called with no arguments (used by the pool) or
 * with the same signature as their {@link #init} method (to be used by applications).
 *
 * @name sap.ui.base.Poolable
 * @interface Contract for objects that can be pooled by ObjectPool
 * @constructor
 * @public
 */

/**
 * Called by the object pool when this instance will be actived for a caller.
 * The same method will be called after a new instance has been created by an otherwise
 * exhausted pool.
 *
 * If the caller provided any arguments to {@link sap.ui.base.ObjectPool#borrowObject}
 * all arguments will be propagated to this method.
 *
 * @name sap.ui.base.Poolable.prototype.init
 * @function
 * @public
 */

/**
 * Called by the object pool when an instance is returned to the pool.
 * While no specific implementation is required, poolable objects in general
 * should clean all caller specific state (set to null) in this method to
 * avoid memory leaks and to enforce garbage collection of the caller state.
 *
 * @name sap.ui.base.Poolable.prototype.reset
 * @function
 * @public
 */
}; // end of sap.ui.base.ObjectPool


/**
 * Creates an instance of EventProvider.
 * @class Provides internal eventing facilities for objects, so other objects can attach
 * and detach events, and are notified, when events are fired
 *
 * @abstract
 * @extends sap.ui.base.Object
 * @author Malte Wedel, Daniel Brinkmann
 * @version 1.5.0-SNAPSHOT
 * @constructor
 * @public
 * @name sap.ui.base.EventProvider
 */
sap.ui.base.Object.extend("sap.ui.base.EventProvider", /* @lends sap.ui.base.EventProvider */ {

	constructor : function() {

		sap.ui.base.Object.apply(this);

		/**
		 * A map of arrays of event registrations keyed by the event names
		 * @private
		 */
		this.mEventRegistry = {};

	}

});

/**
 * Map of event names and ids, that are provided by this class
 * @private
 * @static
 */
sap.ui.base.EventProvider.M_EVENTS = {EventHandlerChange:"EventHandlerChange"};

/**
 * Pool is defined on the prototype to be shared among all EventProviders
 * @private
 */
sap.ui.base.EventProvider.prototype.oEventPool = new sap.ui.base.ObjectPool(sap.ui.base.Event);

/**
 * Adds an event registration for the given object and given event name
 *
 * @param {String}
 *            sEventId The identifier of the event to listen for
 * @param {Object}
 *            [oData] The object, that should be passed along with the event-object when firing the event
 * @param {Function}
 *            fnFunction The function to call, when the event occurs. This function will be called on the
 *            oListener-instance (if present) or on the event provider-instance
 * @param {Object}
 *            [oListener] The object, that wants to be notified, when the event occurs
 * @return {sap.ui.base.EventProvider} Returns <code>this</code> to allow method chaining
 * @public
 */
sap.ui.base.EventProvider.prototype.attachEvent = function(sEventId, oData, fnFunction, oListener) {
	jQuery.sap.assert(typeof(sEventId) === "string" && sEventId, "EventProvider.attachEvent: sEventId must be a non-empty string");
	if(typeof(oData) === "function") {
	//one could also increase the check in the line above
	//if(typeof(oData) === "function" && oListener === undefined) {
		oListener = fnFunction;
		fnFunction = oData;
		oData = undefined;
	}
	jQuery.sap.assert(typeof(fnFunction) === "function", "EventProvider.attachEvent: fnFunction must be a function");
	jQuery.sap.assert(!oListener || typeof(oListener) === "object", "EventProvider.attachEvent: oListener must be empty or an object");

	if (!this.mEventRegistry[sEventId]) {
		this.mEventRegistry[sEventId] = [];
	}
	this.mEventRegistry[sEventId].push({oListener:oListener, fFunction:fnFunction, oData: oData});

	// Inform interested parties about changed EventHandlers
	this.fireEvent(sap.ui.base.EventProvider.M_EVENTS.EventHandlerChange, {EventId: sEventId, type: 'listenerAttached'});

	return this;
};

/**
 * Removes an event registration for the given object and given event name.
 *
 * The passed parameters must match those used for registration with {@link #attachEvent } beforehand!
 *
 * @param {String}
 *            sEventId The identifier of the event to detach from
 * @param {Function}
 *            fFunction The function to call, when the event occurs.
 * @param {Object}
 *            [oListener] The object, that wants to be notified, when the event occurs
 * @return {sap.ui.base.EventProvider} Returns <code>this</code> to allow method chaining
 * @public
 */
sap.ui.base.EventProvider.prototype.detachEvent = function(sEventId, fnFunction, oListener) {

	jQuery.sap.assert(typeof(sEventId) === "string" && sEventId, "EventProvider.detachEvent: sEventId must be a non-empty string" );
	jQuery.sap.assert(typeof(fnFunction) === "function", "EventProvider.detachEvent: fnFunction must be a function");
	jQuery.sap.assert(!oListener || typeof(oListener) === "object", "EventProvider.detachEvent: oListener must be empty or an object");

	var aEventListeners = this.mEventRegistry[sEventId];
	if (!aEventListeners) {
		return this;
	}
	//PERFOPT use array. remember length to not re-calculate over and over again
	for (var i = 0, iL = aEventListeners.length; i < iL; i++) {
		//PERFOPT check for identity instead of equality... avoid type conversion
		if (aEventListeners[i].fFunction === fnFunction && aEventListeners[i].oListener === oListener) {
			//delete aEventListeners[i];
			aEventListeners.splice(i,1);
			break;
		}
	}
	// If we just deleted the last registered EventHandler, remove the whole entry from our map.
	if(aEventListeners.length == 0) {
		delete this.mEventRegistry[sEventId];
	}

	// Inform interested parties about changed EventHandlers
	this.fireEvent(sap.ui.base.EventProvider.M_EVENTS.EventHandlerChange, {EventId: sEventId, type: 'listenerDetached' });

	return this;
};

/**
 * Fires the given event and notifies all listeners. Listeners must not change
 * the content of the event.
 *
 * @param {String} sEventId the event id
 * @param {Object} [mParameters] the parameter map
 * @param {boolean} [bAllowPreventDefault] whether prevent default is allowed
 * @param {boolean} [bEnableEventBubbling] whether event bubbling is enabled
 * @return {sap.ui.base.EventProvider|boolean} Returns <code>this</code> to allow method chaining or
 *		   whether the default action should be executed, when bAllowPreventDefault has been set to true
 * @protected
 */
sap.ui.base.EventProvider.prototype.fireEvent = function(sEventId, mParameters, bAllowPreventDefault, bEnableEventBubbling) {

	// at least in BrowserEventManager when firing events of its E_EVENTS enumeration, the type will be an integer... thus avoid this check
//	jQuery.sap.assert(typeof (sEventId) == "string");

	// get optional parameters right
	if (typeof mParameters == "boolean") {
		bEnableEventBubbling = bAllowPreventDefault;
		bAllowPreventDefault = mParameters;
	}

	var aEventListeners = this.mEventRegistry[sEventId],
		bPreventDefault = false,
		oEvent, oParent, oInfo;

	if (aEventListeners && jQuery.isArray(aEventListeners)) {

		// this ensures no 'concurrent modification exception' occurs (e.g. an event listener deregisters itself).
		aEventListeners = aEventListeners.slice();

		oEvent = this.oEventPool.borrowObject(sEventId, this, mParameters);

		//PERFOPT use array. remember length to not re-calculate over and over again
		for (var i = 0, iL = aEventListeners.length; i < iL; i++) {
			oInfo = aEventListeners[i];
			oInfo.fFunction.call(oInfo.oListener || this, oEvent, oInfo.oData);
		}

		// In case this is a bubbling event and object has a getParent method, also fire on parents
		if (bEnableEventBubbling) {
			oParent = this.getEventingParent();
			while (oParent && !oEvent.bCancelBubble) {
				aEventListeners = oParent.mEventRegistry[sEventId];
				if (aEventListeners && aEventListeners instanceof Array) {
					aEventListeners = aEventListeners.slice();
					for (var i = 0, iL = aEventListeners.length; i < iL; i++) {
						oInfo = aEventListeners[i];
						oInfo.fFunction.call(oInfo.oListener || oParent, oEvent, oInfo.oData);
					}
				}
				oParent = oParent.getEventingParent();
			}
		}

		// Store prevent default state, before returning event to the pool
		bPreventDefault = oEvent.bPreventDefault;

		this.oEventPool.returnObject(oEvent);
	}

	// Only return prevent default result in case it has been enabled, for compatibility
	if (bAllowPreventDefault) {
		return !bPreventDefault;
	}
	else {
		return this;
	}
};

/**
 * Returns whether there are any listeners for the given event ID.
 *
 * @param {String} sEventId the ID of the event
 * @return {boolean} whether there are any listeners
 * @private
 */
sap.ui.base.EventProvider.prototype.hasListeners = function(sEventId) {
	return !!this.mEventRegistry[sEventId];
};

/**
 * Returns the list of events currently having listeners attached.
 *
 * Introduced for lightspeed support to ensure that only relevant events are attached to the LS-world.
 *
 * This is a static method to avoid the pollution of the Element/Control namespace.
 * As the callers are limited and known and for performance reasons the internal event registry
 * is returned. It contains more information than necessary, but needs no expensive conversion.
 *
 * @return {object} the list of events currently having listeners attached
 * @private
 * @static
 */
sap.ui.base.EventProvider.getEventList = function(oEventProvider) {
	return oEventProvider.mEventRegistry;
};

/**
 * Returns the parent in the eventing hierarchy of this object.
 *
 * Per default this returns null, but if eventing is used in objects, which are hierarchically
 * structured, this can be overwritten to make the object hierarchy visible to the eventing and
 * enables the use of event bubbling within this object hierarchy.
 *
 * @return {sap.ui.base.EventProvider} the parent event provider
 * @protected
 */
sap.ui.base.EventProvider.prototype.getEventingParent = function() {
	return null;
};

/**
 * Returns a string representation of this object.
 *
 * In case there is no class or id information, a simple static string is returned.
 * Subclasses should override this method.
 *
 * @return {string} a string description of this eventProvider
 * @public
 */
sap.ui.base.EventProvider.prototype.toString = function() {
	if ( this.getMetadata ) {
		return "EventProvider " + this.getMetadata().getName();
	}
	else {
		return "EventProvider";
	}
};

///**
// * Destroy this instance of the EventProvider.
// * @protected
// */
//sap.ui.base.EventProvider.prototype.exit = function() {
//	this.mEventRegistry = null;
//};
}; // end of sap.ui.base.EventProvider

if ( !jQuery.sap.isDeclared('sap.ui.core.Configuration') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides class sap.ui.core.Configuration
jQuery.sap.declare("sap.ui.core.Configuration");


/**
 * Creates a new Configuration object.
 *
 * @class Collects and stores the configuration of the current environment.
 *
 * The Configuration is initialized once when the {@link sap.ui.core.Core} is created.
 * There are different ways to set the environment configuration (in ascending priority):
 * <ol>
 * <li>System defined defaults
 * <li>Server wide defaults, read from /sap-ui-config.json
 * <li>Properties of the global configuration object window["sap-ui-config"]
 * <li>A configuration string in the data-sap-ui-config attribute of the bootstrap tag
 * <li>Individual data-sap-ui-xyz attributes of the bootstrap tag
 * <li>Using URL parameters
 * <li>Setters in this Configuration object (only for some parameters)
 * </ol>
 *
 * That is, attributes of the DOM reference override the system defaults, URL parameters
 * override the DOM attributes (where empty URL parameters set the parameter back to its
 * system default). Calling setters at runtime will override any previous settings
 * calculated during object creation.
 *
 * The naming convention for parameters is:
 * <ul>
 * <li>in the URL : sap-ui-<i>PARAMETER-NAME</i>="value"
 * <li>in the DOM : data-sap-ui-<i>PARAMETER-NAME</i>="value"
 * </ul>
 * where <i>PARAMETER-NAME</i> is the name of the parameter in lower case.
 *
 * Values of boolean parameters are case insensitive where "true" and "x" are interpreted as true.
 *
 * @extends sap.ui.base.Object
 * @author Frank Weigel (Martin Schaus)
 * @constructor
 * @public
 */
sap.ui.core.Configuration = function() {

	// definition of supported settings
	var M_SETTINGS = {
		"theme"           : { type : "string",   defaultValue : "base" },
		"language"        : { type : "string",   defaultValue : navigator.language || navigator.browserLanguage || navigator.userLanguage },
		"formatLocale"    : { type : "string",   defaultValue : null },
		// "timezone"      : "UTC",
		"accessibility"   : { type : "boolean",  defaultValue : true },
		"animation"       : { type : "boolean",  defaultValue : true },
		"rtl"             : { type : "boolean",  defaultValue : false },
		"debug"           : { type : "boolean",  defaultValue : false },
		"inspect"         : { type : "boolean",  defaultValue : false },
		"originInfo"      : { type : "boolean",  defaultValue : false },
		"noConflict"      : { type : "boolean",  defaultValue : false,     noUrl:true },
		"noDuplicateIds"  : { type : "boolean",  defaultValue : true },
		"trace"           : { type : "boolean",  defaultValue : false,     noUrl:true },
		"modules"         : { type : "string[]", defaultValue : [],        noUrl:true },
		"areas"           : { type : "string[]", defaultValue : null,      noUrl:true },
		// "libs"			  : { type : "string[]", defaultValue : [],        noUrl:true }, deprecated, handled below
		"onInit"          : { type : "code",     defaultValue : undefined, noUrl:true },
		"uidPrefix"       : { type : "string",   defaultValue : "__",      noUrl:true },
		"ignoreUrlParams" : { type : "boolean",  defaultValue : false,     noUrl:true },
		"weinreServer"	  : { type : "string",   defaultValue : "",		   noUrl:true },
		"weinreId"		  : { type : "string",   defaultValue : "" },
		"xx-loadAllMode"  : { type : "boolean",  defaultValue : false,     noUrl:true },
		"xx-preload"      : { type : "string",   defaultValue : '',        noUrl:true },
		"xx-test-mobile"   : { type : "boolean",  defaultValue : false }

	};

	this.oFormatSettings = new sap.ui.core.Configuration.FormatSettings(this);
	
	/* Object that carries the real configuration data */
	var config = this;

	function setValue(sName, sValue) {
		if ( typeof sValue === "undefined" || sValue === null ) {
			return;
		}
		switch(M_SETTINGS[sName].type) {
		case "boolean":
			if ( typeof sValue === "string" ) {
				if (M_SETTINGS[sName].defaultValue) {
					config[sName] = sValue.toLowerCase() != "false";
				} else {
					config[sName] = sValue.toLowerCase() === "true" || sValue.toLowerCase() === "x";
				}
			} else {
				// boolean etc.
				config[sName] = !!sValue;
			}
			break;
		case "string":
			config[sName] = "" + sValue; // enforce string
			break;
		case "code":
			config[sName] = typeof sValue === "function" ? sValue : "" + sValue;
			break;
		case "string[]":
			if ( jQuery.isArray(sValue) ) {
				config[sName] = sValue;
			} else if ( typeof sValue === "string" ) {
				config[sName] = jQuery.map(sValue.split(/[ ,;]/), function($) { return jQuery.trim($); });
			} else {
				throw new Error("unsupported value");
			}
			break;
		default:
			throw new Error("illegal state");
		}
	}

	// 1. collect the defaults
	for (var n in M_SETTINGS ) {
		config[n] = M_SETTINGS[n].defaultValue;
	}

	// 2. read server wide sapui5 configuration
	/* TODO: RETHINK server wide sapui5 configuration to make it optional
			 currently it is forcing a request which is annoying cutomers :
			   - Think about an option which enables loading of server wide config!
	var sUrl = "/sap-ui-config.json";
	var oResponse = jQuery.sap.sjax({url:sUrl});
	if (oResponse.success) {
		var oServerCfg = {};
		if (typeof oResponse.data == "string") {
			try {
				oServerCfg = jQuery.parseJSON(oResponse.data);
			} catch(ex) {
				jQuery.sap.log.warning("Error when parsing the JSON configuration content from " + sUrl + " : " + ex);
			}
		} else {
			oServerCfg = oResponse.data;
		}
		for (var n in M_SETTINGS) {
			if (oServerCfg[n]) {
				setValue(n, oServerCfg[n]);
			}
		}
	}
	*/

	// 3.-5. apply settings from global config object (already merged with script tag attributes)
	var oCfg = window["sap-ui-config"] || {};
	oCfg.oninit = oCfg.oninit || oCfg["evt-oninit"];
	for (var n in M_SETTINGS) {
		setValue(n, oCfg[n.toLowerCase()]);
	}
	// if libs are configured, convert them to modules and prepend them to the existing modules list
	if ( oCfg.libs ) {
		config.modules = jQuery.map(oCfg.libs.split(","), function($) { return jQuery.trim($)+".library"; }).concat(config.modules);
	}

	// 6. apply the settings from the url (only if not blocked by app configuration)
	if ( !config.ignoreUrlParams ) {
		var sUrlPrefix = "sap-ui-";
		var oUriParams = jQuery.sap.getUriParameters();
		for (var n in M_SETTINGS) {
			if ( M_SETTINGS[n].noUrl ) {
				continue;
			}
			var sValue = oUriParams.get(sUrlPrefix + n);
			if (sValue === "") {
				//empty URL parameters set the parameter back to its system default
				config[n] = M_SETTINGS[n].defaultValue;
			} else {
				//sets the value (null or empty value ignored)
				setValue(n, sValue);
			}
		}
	}

	for (var n in M_SETTINGS) {
		if ( config[n] !== M_SETTINGS[n].defaultValue ) {
			jQuery.sap.log.info("  " + n + " = " + config[n]);
		}
	}
};

sap.ui.core.Configuration.prototype = jQuery.sap.newObject(sap.ui.base.Object.prototype);

sap.ui.base.Object.defineClass("sap.ui.core.Configuration", {
	baseType : "sap.ui.base.Object",
	publicMethods : ["getTheme", /*"setTheme", */"getLanguage", "getFormatLocale", "getAccessibility", "getAnimation", "getApplication", "getRTL", "getDebug", "getInspect", "getOriginInfo", "getNoDuplicateIds", "getUIDPrefix", "getWeinreServer", "getWeinreId", "getFormatSettings"]
});

/**
 * Returns the theme name
 * @return {string} the theme name
 * @public
 */
sap.ui.core.Configuration.prototype.getTheme = function () {
	return this.theme;
};

/**
 * Allows setting the theme name
 * @param {string} sTheme the theme name
 * @return {sap.ui.core.Configuration} <code>this</code> to allow method chaining
 * @private
 */
sap.ui.core.Configuration.prototype.setTheme = function (sTheme) {
	this.theme = sTheme;
	return this;
};

/**
 * Returns the language string with language and country code
 * @return {string} the language string with language and country code
 * @public
 */
sap.ui.core.Configuration.prototype.getLanguage = function () {
	return this.language;
};

/**
 * Returns the format locale string with language and region code. Falls back to language configuration,
 * in case it has not been explicitly defined.
 * @return {string} the format locale string with language and country code
 * @public
 */
sap.ui.core.Configuration.prototype.getFormatLocale = function () {
	return this.formatLocale || this.language;
};

/**
 * Returns whether the accessibility mode is used or not
 * @return {boolean} whether the accessibility mode is used or not
 * @public
 */
sap.ui.core.Configuration.prototype.getAccessibility = function () {
	return this.accessibility;
};

/**
 * Returns whether the animations are globally used
 * @return {boolean} whether the animations are globally used
 * @public
 */
sap.ui.core.Configuration.prototype.getAnimation = function () {
	return this.animation;
};

/**
 * Returns whether the page uses the RTL text direction
 * @return {boolean} whether the page uses the RTL text direction
 * @public
 */
sap.ui.core.Configuration.prototype.getRTL = function () {
	return this.rtl;
};

/**
 * Returns whether the page runs in debug mode
 * @return {boolean} whether the page runs in debug mode
 * @public
 */
sap.ui.core.Configuration.prototype.getDebug = function () {
	return this.debug;
};

/**
 * Returns whether the UI5 control inspector is displayed
 * Has only an effect when the sap-ui-debug module has been loaded
 * @return {boolean} whether the UI5 control inspector is displayed
 * @public
 */
sap.ui.core.Configuration.prototype.getInspect = function () {
	return this.inspect;
};

/**
 * Returns whether the text origin information is collected
 * @return {boolean} whether the text info is collected
 * @public
 */
sap.ui.core.Configuration.prototype.getOriginInfo = function () {
	return this.originInfo;
};

/**
 * Returns whether there should be an exception on any duplicate element IDs
 * @return {boolean} whether there should be an exception on any duplicate element IDs
 * @public
 */
sap.ui.core.Configuration.prototype.getNoDuplicateIds = function () {
	return this.noDuplicateIds;
};

/**
 * Whether a trace view should be shown or not.
 * Has only an effect when the sap-ui-debug module has been loaded
 * either by explicitly loading it or by setting the 'debug' option to true.
 * @return {boolean} whether a trace view should be shown
 */
sap.ui.core.Configuration.prototype.getTrace = function () {
	return this.trace;
};

/**
 * Prefix to be used for automatically generated control IDs.
 * Default is a double underscore "__".
 *
 * @returns {string} the prefix to be used
 * @public
 */
sap.ui.core.Configuration.prototype.getUIDPrefix = function() {
	return this.uidPrefix;
};

/**
 * WEINRE server URL
 *
 * @returns {string} the base URL of the WEINRE server
 * @public
 */
sap.ui.core.Configuration.prototype.getWeinreServer = function() {
	var sWeinreServer = this.weinreServer;
	if (!sWeinreServer) {
		// if not weinre server is configured - we expect that the weinre server
		// is installed on the same machine with port no of the app + 1
		sWeinreServer = window.location.protocol + "//" + window.location.hostname + ":";
		sWeinreServer += (parseInt(window.location.port, 10) || 8080) + 1;
	}
	return sWeinreServer;
};

/**
 * WEINRE session ID
 *
 * @returns {string} the ID to use for the WEINRE server
 * @public
 */
sap.ui.core.Configuration.prototype.getWeinreId = function() {
	return this.weinreId;
};

(function() {

	var M_ABAP_DATE_FORMAT_PATTERN = {
    	  "" : {pattern: null},
	      "1": {pattern: "dd.MM.yyyy"},
	      "2": {pattern: "MM/dd/yyyy"},
	      "3": {pattern: "MM-dd-yyyy"},
	      "4": {pattern: "yyyy.MM.dd"},
	      "5": {pattern: "yyyy/MM/dd"},
	      "6": {pattern: "yyyy-MM-dd"}
	    },
	    M_ABAP_TIME_FORMAT_PATTERN = {
    	  "" : {pattern: null, dayPeriods: null},
	      "0": {pattern: "HH:mm:ss", dayPeriods : null},
	      "1": {pattern: "hh:mm:ss a", dayPeriods: ["AM", "PM"]},
	      "2": {pattern: "hh:mm:ss a", dayPeriods: ["am", "pm"]},
	      "3": {pattern: "KK:mm:ss a", dayPeriods: ["AM", "PM"]},
	      "4": {pattern: "KK:mm:ss a", dayPeriods: ["am", "pm"]}
	    },
	    M_ABAP_NUMBER_FORMAT_SYMBOLS = {
    	  "" : {groupingSeparator: null, decimalSeparator: null},
  	      " ": {groupingSeparator: ".", decimalSeparator: ","},
  	      "X": {groupingSeparator: ",", decimalSeparator: "."},
  	      "Y": {groupingSeparator: " ", decimalSeparator: ","}
  	    };

	function check(bCondition, sMessage) {
		if ( !bCondition ) {
			throw new Error(sMessage);
		}
	}
	
	/**
	 * @class Encapsulates configuration settings that are related to data formatting/parsing.
	 * 
	 * <b>Note:</b> When format configuration settings are modified through this class, 
	 * UI5 only ensures that formatter objects created after that point in time will honor
	 * the modifications. To be on the safe side, applications should do any modifications 
	 * early in their lifecycle or recreate any model/UI that is locale dependent. 
	 * 
	 * @name sap.ui.core.Configuration.FormatSettings
	 * @extends sap.ui.base.Object
	 * @public
	 */
	sap.ui.base.Object.extend("sap.ui.core.Configuration.FormatSettings", /** @lends sap.ui.core.Configuration.FormatSettings.prototype */ {
		constructor : function(oConfiguration) {
			this.oConfiguration = oConfiguration;
			this.mSettings = {};
			this.sLegacyDateFormat = undefined;
			this.sLegacyTimeFormat = undefined;
			this.sLegacyNumberFormatSymbolSet = undefined;
		},
		
		metadata : {
			publicMethods : []
		},
		
		/**
		 * Returns the locale to be used for formatting. 
		 * 
		 * If no such locale has been defined, this method falls back to the language,
		 * see {@link sap.ui.core.Configuration#getLanguage Configuration.getLanguage()}.
		 * 
		 * If any user preferences for date, time or number formatting have been set,
		 * and if no format locale has been specified, then a special private use subtag
		 * is added to the locale, indicating to the framework that these user preferences 
		 * should be applied. 
		 *  
		 * @return {sap.ui.core.Locale} the format locale 
		 * @public
		 */
		getFormatLocale : function() {
			function fallback(that) {
				var l=that.oConfiguration.language;
				// if any user settings have been defined, add the private use subtag "sapufmt"    
				if ( !jQuery.isEmptyObject(that.mSettings) ) {
					// TODO move to Locale/LocaleData
					if ( l.indexOf("-x-") < 0 ) {
						l = l + "-x-sapufmt";
					} else if ( l.indexOf("-sapufmt") <= l.indexOf("-x-") ) {
						l = l + "-sapufmt";
					}
				}
				return l;
			}
			return new sap.ui.core.Locale(this.oConfiguration.formatLocale || fallback(this));
		},
		
		_set : function(sKey, oValue) {
			if ( oValue != null ) {
				this.mSettings[sKey] = oValue;
			} else {
				delete this.mSettings[sKey];
			} 
		},
		
		/**
		 * Returns the currently set date pattern or undefined if no pattern has been defined. 
		 * @public
		 */
		getDatePattern : function(sStyle) {
			jQuery.sap.assert(sStyle == "short" || sStyle == "medium" || sStyle == "long" || sStyle == "full", "sStyle must be short, medium, long or full");
			return this.mSettings["dateFormat-" + sStyle];
		},
		
		/**
		 * Defines the preferred format pattern for the given date format style. 
         * Calling this method with a null or undefined pattern removes a previously set pattern. 
		 * 
		 * If a pattern is defined, it will be preferred over patterns derived from the current locale.
		 * 
		 * See class {@link sap.ui.core.format.DateFormat} for details about the pattern syntax.
		 *  
		 * @param {string} sStyle must be one of short, medium, long or full.
		 * @param {string} sPattern the format pattern to be used in LDML syntax.
		 * @return {sap.ui.core.Configuration.FormatSettings} Returns <code>this</code> to allow method chaining
		 * @public   
		 */
		setDatePattern : function(sStyle, sPattern) {
			check(sStyle == "short" || sStyle == "medium" || sStyle == "long" || sStyle == "full", "sStyle must be short, medium, long or full");
			this._set("dateFormat-" + sStyle, sPattern);
			return this;
		},
		
		/**
		 * Returns the currently set time pattern or undefined if no pattern has been defined.
		 * @public
		 */
		getTimePattern : function(sStyle) {
			jQuery.sap.assert(sStyle == "short" || sStyle == "medium" || sStyle == "long" || sStyle == "full", "sStyle must be short, medium, long or full");
			return this.mSettings["timeFormat-" + sStyle];
		},

		/**
		 * Defines the preferred format pattern for the given time format style.
         * Calling this method with a null or undefined pattern removes a previously set pattern. 
		 *  
		 * If a pattern is defined, it will be preferred over patterns derived from the current locale.
		 * 
		 * See class {@link sap.ui.core.format.DateFormat} for details about the pattern syntax.
		 *  
		 * @param {string} sStyle must be one of short, medium, long or full.
		 * @param {string} sPattern the format pattern to be used in LDML syntax.
		 * @return {sap.ui.core.Configuration.FormatSettings} Returns <code>this</code> to allow method chaining
		 * @public
		 */
		setTimePattern : function(sStyle, sPattern) {
			check(sStyle == "short" || sStyle == "medium" || sStyle == "long" || sStyle == "full", "sStyle must be short, medium, long or full");
			this._set("timeFormat-" + sStyle, sPattern);
			return this;
		},
		
		/**
		 * Returns the currently set number symbol of the given type or undefined if no symbol has been defined.
		 * @public
		 */
		getNumberSymbol : function(sType) {
			jQuery.sap.assert(sType == "decimal" || sType == "group" || sType == "plusSign" || sType == "minusSign", "sType must be decimal, group, plusSign or minusSign");
			return this.mSettings["symbols-latn-" + sType];
		},

		/**
		 * Defines the string to be used for the given number symbol.
         * Calling this method with a null or undefined symbol removes a previously set symbol string.
         * Note that an empty string is explicitly allowed.  
		 * 
		 * If a symbol is defined, it will be preferred over symbols derived from the current locale.
		 * 
		 * See class {@link sap.ui.core.format.NumberFormat} for details about the symbols.
		 *  
		 * @param {string} sStyle must be one of decimal, group, plusSign, minusSign.
		 * @param {string} sSymbol will be used to represent the given symbol type
		 * @return {sap.ui.core.Configuration.FormatSettings} Returns <code>this</code> to allow method chaining
		 * @public   
		 */
		setNumberSymbol : function(sType, sSymbol) {
			check(sType == "decimal" || sType == "group" || sType == "plusSign" || sType == "minusSign", "sType must be decimal, group, plusSign or minusSign");
			this._set("symbols-latn-" + sType, sSymbol);
			return this;
		},

		_setDayPeriods : function(sWidth, aTexts) {
			jQuery.sap.assert(sWidth == "narrow" || sWidth == "abbreviated" || sWidth == "wide", "sWidth must be narrow, abbreviated or wide");
			this._set("dayPeriods-format-" + sWidth, aTexts);
			return this;
		},
		
		/**
		 * Returns the currently set legacy ABAP date format (its id) or undefined if none has been set.
		 *  
 		 * @public
		 */
		getLegacyDateFormat : function() {
			return this.sLegacyDateFormat || undefined;
		},
		
		/**
		 * Allows to specify one of the legacy ABAP date formats. 
		 * 
		 * This method modifies the date patterns for 'short' and 'medium' style with the corresponding ABAP 
		 * format. When called with a null or undefined format id, any previously applied format will be removed.
		 * 
		 * @param {string} sFormatId id of the ABAP data format (one of '1','2','3','4','5','6')
		 * @return {sap.ui.core.Configuration.FormatSettings} Returns <code>this</code> to allow method chaining
		 * @public
		 */
		setLegacyDateFormat : function(sFormatId) {
			check(!sFormatId || M_ABAP_DATE_FORMAT_PATTERN.hasOwnProperty(sFormatId), "sFormatId must be one of ['1','2','3','4','5','6'] or empty");
			this.sLegacyDateFormat = sFormatId = sFormatId || "";
			this.setDatePattern("short", M_ABAP_DATE_FORMAT_PATTERN[sFormatId].pattern);
			this.setDatePattern("medium", M_ABAP_DATE_FORMAT_PATTERN[sFormatId].pattern);
			return this;
		},
		
		/**
		 * Returns the currently set legacy ABAP time format (its id) or undefined if none has been set.
		 *  
 		 * @public
		 */
		getLegacyTimeFormat : function() {
			return this.sLegacyTimeFormat || undefined;
		},

		/**
		 * Allows to specify one of the legacy ABAP time formats.
		 * 
		 * This method sets the time patterns for 'short' and 'medium' style to the corresponding ABAP 
		 * formats and sets the day period texts to "AM"/"PM" or "am"/"pm" respectively. When called 
		 * with a null or undefined format id, any previously applied format will be removed.
		 * 
		 * @param {string} sFormatId id of the ABAP time format (one of '0','1','2','3','4')
		 * @return {sap.ui.core.Configuration.FormatSettings} Returns <code>this</code> to allow method chaining
		 * @public
		 */
		setLegacyTimeFormat : function(sFormatId) {
			check(!sFormatId || M_ABAP_TIME_FORMAT_PATTERN.hasOwnProperty(sFormatId), "sFormatId must be one of ['0','1','2','3','4'] or empty");
			this.sLegacyTimeFormat = sFormatId = sFormatId || "";
			this.setTimePattern("short", M_ABAP_TIME_FORMAT_PATTERN[sFormatId].pattern);
			this.setTimePattern("medium", M_ABAP_TIME_FORMAT_PATTERN[sFormatId].pattern);
			this._setDayPeriods("abbreviated", M_ABAP_TIME_FORMAT_PATTERN[sFormatId].dayPeriods);
			return this;
		},
		
		/**
		 * Returns the currently set legacy ABAP number format (its id) or undefined if none has been set.
		 *  
 		 * @public
		 */
		getLegacyNumberFormat : function() {
			return this.sLegacyNumberFormat || undefined;
		},

		/**
		 * Allows to specify one of the legacy ABAP number format.
		 * 
		 * This method will modify the 'group' and 'decimal' symbols. When called with a null 
		 * or undefined format id, any previously applied format will be removed.
		 * 
		 * @param {string} sFormatId id of the ABAP number format set (one of ' ','X','Y')
		 * @return {sap.ui.core.Configuration.FormatSettings} Returns <code>this</code> to allow method chaining
		 * @public
		 */
		setLegacyNumberFormat : function(sFormatId) {
			sFormatId = sFormatId ? sFormatId.toUpperCase() : "";
			check(!sFormatId || M_ABAP_NUMBER_FORMAT_SYMBOLS.hasOwnProperty(sFormatId), "sFormatId must be one of [' ','X','Y'] or empty");
			this.sLegacyNumberFormat = sFormatId;
			this.setNumberSymbol("group", M_ABAP_NUMBER_FORMAT_SYMBOLS[sFormatId].groupingSeparator);
			this.setNumberSymbol("decimal", M_ABAP_NUMBER_FORMAT_SYMBOLS[sFormatId].decimalSeparator);
		},
		
		/*
		 * Returns a live object with the current settings
		 * TODO this method is part of the facade to be accessible from LocaleData, but it shouldn't be
		 * @private
		 */
		getCustomLocaleData : function() {
			return this.mSettings;
		}
	});
	
	/**
	 * Returns a configuration object that bundles the format settings of UI5.
	 *
	 * @return {sap.ui.core.Configuration.FormatSettings} A FormatSettings object.
	 * @public
	 */
	sap.ui.core.Configuration.prototype.getFormatSettings = function() {
		return this.oFormatSettings;
	};

}());

}; // end of sap.ui.core.Configuration

if ( !jQuery.sap.isDeclared('sap.ui.core.Control') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides base class sap.ui.core.Control for all controls
jQuery.sap.declare("sap.ui.core.Control");
if ( !jQuery.sap.isDeclared('sap.ui.core.Element') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides the base class for all controls and UI elements.
jQuery.sap.declare("sap.ui.core.Element");


if ( !jQuery.sap.isDeclared('jquery.sap.strings') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides useful string operations not available in pure JavaScript.
jQuery.sap.declare("jquery.sap.strings", false);

(function(){


	/**
	 * Checks whether a given sString ends with sEndString
	 * respecting the case of the strings.
	 *
	 * @param {string} sString The string to be checked
	 * @param {string} sEndString The end string to be searched
	 * @return True if sString ends with sEndString
	 * @type {boolean}
	 * @see jQuery.sap.endsWithIgnoreCase
	 * @public
	 */
	jQuery.sap.endsWith = function endsWith(sString, sEndString) {
		if (typeof(sEndString)!="string" || sEndString=="") {
			return false;
		}
		var iPos = sString.lastIndexOf(sEndString);
		return iPos >= 0 && iPos == sString.length - sEndString.length;
	};

	/**
	 * Checks whether a given sString ends with sEndString
	 * ignoring the case of the strings.
	 *
	 * @param {string} sString the string to be checked
	 * @param {string} sEndString the end string to be searched
	 * @return true if sString ends with sEndString
	 * @type {boolean}
	 * @see jQuery.sap.endsWith
	 * @public
	 */
	jQuery.sap.endsWithIgnoreCase = function endsWithIgnoreCase(sString, sEndString) {
		if (typeof(sEndString)!="string" || sEndString=="") {
			return false;
		}
		sString = sString.toUpperCase();
		sEndString = sEndString.toUpperCase();
		return jQuery.sap.endsWith(sString,sEndString);
	};

	/**
	 * Checks whether a given sString starts with sStartString
	 * respecting the case of the strings.
	 *
	 * @param {string} sString The string to be checked
	 * @param {string} sStartString The start string to be searched
	 * @return True if sString ends with sEndString
	 * @type {boolean}
	 * @see jQuery.sap.startsWithIgnoreCase
	 * @public
	 */
	jQuery.sap.startsWith = function startsWith(sString, sStartString) {
		if (typeof(sStartString)!="string" || sStartString=="") {
			return false;
		}
		if (sString == sStartString) {
			return true;
		}
		return sString.indexOf(sStartString) == 0;
	};

	/**
	 * Checks whether a given sString starts with sStartString
	 * ignoring the case of the strings.
	 *
	 * @param {string} sString The string to be checked
	 * @param {string} sStartString The start string to be searched
	 * @return True if sString ends with sEndString
	 * @type {boolean}
	 * @see jQuery.sap.startsWith
	 * @public
	 */
	jQuery.sap.startsWithIgnoreCase = function startsWithIgnoreCase(sString, sStartString) {
		if (typeof(sStartString)!="string" || sStartString=="") {
			return false;
		}
		sString = sString.toUpperCase();
		sStartString = sStartString.toUpperCase();
		return jQuery.sap.startsWith(sString,sStartString);
	};

	/**
	 * Converts a character of the string to upper case.<br/>
	 * If no pos is defined as second parameter or pos is negative or greater than sString the first character will be
	 * converted into upper case. the first char position is 0.
	 *
	 * @param {string} sString The string to be checked
	 * @param {integer} iPos the position of the character that will be uppercase
	 * @return The string with the firstletter in upper case
	 * @type {string}
	 * @public
	 * @SecPassthrough {0|return}
	 */
	jQuery.sap.charToUpperCase = function charToUpperCase(sString,iPos) {
		if (!sString) {
			return sString;
		}
		if (!iPos || isNaN(iPos) || iPos <= 0 || iPos >= sString.length) {
			iPos = 0;
		}
		var sChar = sString.charAt(iPos).toUpperCase();
		if (iPos>0) {
			return sString.substring(0,iPos) + sChar + sString.substring(iPos+1);
		}
		return sChar + sString.substring(iPos+1);
	};

	/**
	 * Pads a string on the left side until is has the given length.<br/>
	 *
	 * @param {string} sString The string to be padded
	 * @param {string} sPadChar The char to use for the padding
	 * @param {integer} iLength the target length of the string
	 * @return The padded string
	 * @type {string}
	 * @public
	 * @SecPassthrough {0 1|return}
	 */
	jQuery.sap.padLeft = function padLeft(sString, sPadChar, iLength) {
		if (!sString) {
			sString = "";
		}
		while (sString.length < iLength) {
			sString = sPadChar + sString;
		}
		return sString;
	};

	/**
	 * Pads a string on the right side until is has the given length.<br/>
	 *
	 * @param {string} sString The string to be padded
	 * @param {string} sPadChar The char to use for the padding
	 * @param {integer} iLength the target length of the string
	 * @return The padded string
	 * @type {string}
	 * @public
	 * @SecPassthrough {0 1|return}
	 */
	jQuery.sap.padRight = function padRight(sString, sPadChar, iLength) {
		if (!sString) {
			sString = "";
		}
		while (sString.length < iLength) {
			sString = sString + sPadChar;
		}
		return sString;
	};



}());
}; // end of jquery.sap.strings


if ( !jQuery.sap.isDeclared('sap.ui.base.DataType') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides class sap.ui.base.DataType
jQuery.sap.declare("sap.ui.base.DataType");

/**
 * @class Describes the metadata of a data type and provides methods for validation.
 * @author Frank Weigel
 * @since 0.9.0
 */
sap.ui.base.DataType = function() {
	// Avoid construction of a DataType.
	// DataType is only a function to support the "instanceof" operator.
	throw new Error();
};

/**
 * The qualified name of the data type.
 * Note that this name usually equals the design time name of the type.
 * Only for primitive types it differs, namely it omits the package 'sap.ui.core'.
 * @return {string} name of the data type
 * @public
 */
sap.ui.base.DataType.prototype.getName = function() {
	return undefined;
};

/**
 * The base type of this type or undefined if this is a primitive type.
 * @return {sap.ui.base.DataType} base type or undefined
 * @public
 */
sap.ui.base.DataType.prototype.getBaseType = function() {
	return undefined;
};

/**
 * The component type of this type or undefined if this is not an array.
 * @return {sap.ui.base.DataType} component type or undefined
 * @public
 */
sap.ui.base.DataType.prototype.getComponentType = function() {
	return undefined;
};

/**
 * The default value for this type. Each type must define a default value.
 * @return {any} default value of the data type. The type of the returned value
 *    must match the JavaScript type of the data type (a string for string types etc.)
 * @public
 */
sap.ui.base.DataType.prototype.getDefaultValue = function() {
	return undefined;
};

/**
 * Parses the given string value and converts it into the specific data type.
 * @param {string} sValue string representation for a value of this type
 * @return the value in the correct internal format
 * @public
 */
sap.ui.base.DataType.prototype.parseValue = function(sValue) {
	// currently this function considers to handle primitive values
	// - in future may be other values might be also relevant.
	var sType = this.getName();
	if (sType == "string") {
		return sValue;
	} else if (sType == "boolean") {
		return sValue == "true";
	} else if (sType == "int") {
		return parseInt(sValue, 10);
	} else if (sType == "float") {
		return parseFloat(sValue);
	} else {
		// support for other types like e.g.
		// sap.ui.core.CSSSize (just apply)
		return sValue;
	}
};

/**
 * A validation check. To be implemented by concrete types.
 * @param {any} vValue the value to be checked
 * @return {boolean} whether the given value is valid for this data type (without conversion)
 * @public
 */
sap.ui.base.DataType.prototype.isValid = undefined;

(function() {

	function createType(name, s, base) {

		jQuery.sap.assert(typeof name === "string" && !!name, "DataType.<createType>: type name must be a string");
		jQuery.sap.assert(!base || base instanceof sap.ui.base.DataType, "DataType.<createType>: base type must be empty or a DataType");
		s = s || {};
		base = base || sap.ui.base.DataType.prototype;

		// create a new type object with the base type as prototype
		var type = jQuery.sap.newObject(base);

		// getter for the name
		type.getName = function() { return name; };

		// if a default value is specified, create a getter for it
		if ( s.hasOwnProperty("defaultValue") ) {
			var vDefault = s.defaultValue;
			type.getDefaultValue = function() { return vDefault; };
		}

		// if a validator is specified either chain it with the base type validator
		// or set it if no base validator exists
		if ( s.hasOwnProperty("isValid") ) {
			var fnIsValid = s.isValid;
			type.isValid = base.isValid ? function(vValue) {
				if ( !base.isValid(vValue) ) {
					return false;
				}
				return fnIsValid(vValue);
			} : fnIsValid;
		};

		return type;
	}

	function createArrayType(componentType) {
		jQuery.sap.assert(componentType instanceof sap.ui.base.DataType, "DataType.<createArrayType>: compoinentType must be a DataType");

		// create a new type object with the base type as prototype
		var type = jQuery.sap.newObject(sap.ui.base.DataType.prototype);

		// getter for the name
		type.getName = function() { return componentType.getName() + "[]"; };

		// getter for component type
		type.getComponentType = function() { return componentType; };

		// array validator
		type.isValid = function(aValues) {
			if (aValues === null) {
				return true;
			}
			if (jQuery.isArray(aValues)) {
				for (var i = 0; i < aValues.length; i++) {
					if (!componentType.isValid(aValues[i])) {
						return false;
					}
				}
				return true;
			}
			return false;
		};

		// array parser
		type.parseValue = function(sValue) {
			var aValues = sValue.split(",");
			for (var i = 0; i < aValues.length; i++) {
				aValues[i] = componentType.parseValue(aValues[i]);
			}
			return aValues;
		};

		return type;
	}

	var PREDEFINED_TYPES = {

		"any" :
				createType("any", {
					defaultValue : null,
					isValid : function(vValue) {
						return true;
					}
				}),

		"boolean" :
			createType("boolean", {
				defaultValue : false,
				isValid : function(vValue) {
					return typeof vValue === "boolean";
				}
			}),

		"int" :
			createType("int", {
				defaultValue : 0,
				isValid : function(vValue) {
					return typeof vValue === "number" && Math.floor(vValue) == vValue;
				}
			}),

		"float" :
			createType("float", {
				defaultValue : 0.0,
				isValid : function(vValue) {
					return typeof vValue === "number";
				}
			}),

		"string" :
			createType("string", {
				defaultValue : "",
				isValid : function(vValue) {
					return typeof vValue === "string" || vValue instanceof String;
				}
			}),
		"object" :
			createType("object", {
				defaultValue : null,
				isValid : function(vValue) {
					return typeof vValue === "object" || typeof vValue === "function";
				}
			})
	};

	/**
	 * Returns the type object for the type with the given name.
	 * @return the type object or undefined when no such type object exists.
	 * @public
	 */
	sap.ui.base.DataType.getType = function(sTypeName) {
		if (sTypeName.indexOf("[]") > 0) {
			var sComponentTypeName = sTypeName.substr(0, sTypeName.length - 2),
				oComponentType = this.getType(sComponentTypeName);
			return oComponentType && createArrayType(oComponentType);
		} else {
			return PREDEFINED_TYPES[sTypeName] || jQuery.sap.getObject(sTypeName);
		}
	};

	/**
	 * Creates a new type as a subtype of a given type.
	 * @param {string} sName the unique name of the new type
	 * @param {object} [mSettings settings] for the new type
	 * @param {any} [mSettings.defaultValue] the default value for the new type
	 * @param {function} [mSettings.isValid] a validator function for values of the new type
	 * @param {sap.ui.base.DataType} [base] the base type for the new type
	 * @public
	 */
	sap.ui.base.DataType.createType = createType;

}());
}; // end of sap.ui.base.DataType

if ( !jQuery.sap.isDeclared('sap.ui.core.ElementMetadata') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides class sap.ui.core.ElementMetadata
jQuery.sap.declare("sap.ui.core.ElementMetadata");



/**
 * Creates a new metadata object for a UIElement subclass.
 *
 * @param {string} sClassName fully qualified name of the class that is described by this metadata object
 * @param {object} oStaticInfo static info to construct the metadata from
 *
 * @class
 * @author Frank Weigel
 * @version 1.5.0-SNAPSHOT
 * @since 0.8.6
 */
sap.ui.core.ElementMetadata = function(sClassName, oClassInfo) {

	// call super constructor
	sap.ui.base.Metadata.apply(this, arguments);

};

//chain the prototypes
sap.ui.core.ElementMetadata.prototype = jQuery.sap.newObject(sap.ui.base.Metadata.prototype);

/**
 * @private
 */
sap.ui.core.ElementMetadata.prototype.applySettings = function(oClassInfo) {

	var oStaticInfo = oClassInfo.metadata;

	// remove renderer stuff before calling super.
	var vRenderer = oClassInfo.hasOwnProperty("renderer") ? (oClassInfo.renderer || "") : undefined;
	delete oClassInfo.renderer;

	sap.ui.base.Metadata.prototype.applySettings.call(this, oClassInfo);

	var rPlural = /(children|ies|ves|oes|ses|ches|shes|xes|s)$/i;
	var mSingular = {'children' : -3, 'ies' : 'y', 'ves' : 'f', 'oes' : -2, 'ses' : -2, 'ches' : -2, 'shes' : -2, 'xes' : -2, 's' : -1 };

	function normalize(mInfoMap, sDefaultName, oDefaultValues) {
		var sName,oInfo;
		mInfoMap = mInfoMap || {};
		for(sName in mInfoMap) {
			oInfo = mInfoMap[sName];
			// if settings are not an object literal and if there is a default setting, set it
			if ( sDefaultName && typeof oInfo !== "object" ) {
				oInfo = {};
				oInfo[sDefaultName] = mInfoMap[sName];
			}
			oInfo = jQuery.extend({}, oDefaultValues, oInfo);
			oInfo.name = sName;
			// if info contains a multiple flag but no singular name, calculate one
			if ( oInfo.multiple === true && !oInfo.singularName) {
				oInfo.singularName = sName.replace(rPlural, function($,sPlural) {
					var vRepl = mSingular[sPlural.toLowerCase()];
					return typeof vRepl === "string" ? vRepl : sPlural.slice(0,vRepl);
				});
			}
			mInfoMap[sName] = oInfo;
		}
		return mInfoMap;
	}

	// init basic metadata from static infos and fallback to defaults
	this._sLibraryName = oStaticInfo.library;
	this._mProperties = normalize(oStaticInfo.properties, "type", { type : "string", group : "Misc" });
	this._mAggregations = normalize(oStaticInfo.aggregations, "type", { type : "sap.ui.core.Control", multiple : true });
	this._sDefaultAggregation = oStaticInfo.defaultAggregation || null;
	this._mAssociations = normalize(oStaticInfo.associations, "type", { type : "sap.ui.core.Control", multiple : false});
	this._mEvents = normalize(oStaticInfo.events, /* no default setting */ null, { allowPreventDefault : false });
	this._sRendererName = this.getName() + "Renderer";

	this._bEnriched = false;

	if ( oClassInfo.metadata.__version > 1.0 ) {
		this.generateAccessors();
	}

	if ( typeof vRenderer !== "undefined" ) {

		if ( typeof vRenderer === "string" ) {
			this._sRendererName = vRenderer || undefined;
			return;
		}
		if ( typeof vRenderer === "function" ) {
			vRenderer = { render : vRenderer };
		}

		var oParent = this.getParent();
		var oBaseRenderer;
		if ( oParent && oParent instanceof sap.ui.core.ElementMetadata ) {
			oBaseRenderer = oParent.getRenderer();
		}
		if ( !oBaseRenderer ) {
			jQuery.sap.require("sap.ui.core.Renderer");
			oBaseRenderer = sap.ui.core.Renderer;
		}
		var oRenderer = jQuery.sap.newObject(oBaseRenderer);
		jQuery.extend(oRenderer, vRenderer);
		jQuery.sap.setObject(this.getRendererName(), oRenderer);
	}
};

/**
 * @private
 */
sap.ui.core.ElementMetadata.prototype.afterApplySettings = function() {

	sap.ui.base.Metadata.prototype.afterApplySettings.call(this);

	// if there is a parent class, produce the flattened "all" views for the element specific metadata
	// PERFOPT: this could be done lazily
	var oParent = this.getParent();
	if ( oParent && oParent instanceof sap.ui.core.ElementMetadata ) {
		this._mAllEvents = jQuery.extend({},oParent._mAllEvents, this._mEvents);
		this._mAllProperties = jQuery.extend({},oParent._mAllProperties, this._mProperties);
		this._mAllAggregations = jQuery.extend({},oParent._mAllAggregations, this._mAggregations);
		this._mAllAssociations = jQuery.extend({},oParent._mAllAssociations, this._mAssociations);
		this._sDefaultAggregation = this._sDefaultAggregation || oParent._sDefaultAggregation;
	} else {
		this._mAllEvents = this._mEvents;
		this._mAllProperties = this._mProperties;
		this._mAllAggregations = this._mAggregations;
		this._mAllAssociations = this._mAssociations;
	}

};

sap.ui.core.ElementMetadata.Kind = {
  PROPERTY :0, SINGLE_AGGREGATION : 1, MULTIPLE_AGGREGATION : 2, SINGLE_ASSOCIATION : 3, MULTIPLE_ASSOCIATION : 4, EVENT : 5
};

/**
 * By default, the element name is equal to the class name
 * @return {string} the qualified name of the UIElement class
 * @public
 */
sap.ui.core.ElementMetadata.prototype.getElementName = function() {
	return this._sClassName;
};

/**
 * Returns the name of the library that contains the described UIElement.
 * @return {string} the name of the library
 * @public
 */
sap.ui.core.ElementMetadata.prototype.getLibraryName = function() {
	return this._sLibraryName;
};

/**
 * Returns whether the class/control is abstract
 * @return {boolean} whether the class/control is abstract
 * @public
 */
sap.ui.core.ElementMetadata.prototype.isAbstract = function() {
	return this._bAbstract;
};

/**
 * Declares an additional property for the UIElement class described by this metadata.
 *
 * Any property declaration via this method must happen before the described class
 * is subclassed, or the added property will not be visible in the subclass.
 *
 * Typically used to enrich UIElement classes in an aspect oriented manner.
 * @public
 * @see sap.ui.core.EnabledPropagator
 */
sap.ui.core.ElementMetadata.prototype.addProperty = function(sName, oInfo) {
	oInfo.name = sName;
	this._mProperties[sName] = oInfo;
	if(!this._mAllProperties[sName]) {// ensure extended AllProperties meta-data is also enriched
		this._mAllProperties[sName] = oInfo;
	}

	if ( this._bEnriched ) { // does not seem right! this is the 'drop out' condition for _enrichChildInfos() -> senseless
		this._enrichChildInfos();
	}
	// TODO notify listeners (subclasses) about change
};

/**
 * Checks the existance of the given property by its name
 * @param {string} sName name of the property
 * @return {boolean} true, if the property exists
 * @public
 */
sap.ui.core.ElementMetadata.prototype.hasProperty = function(sName) {
	return !!this._mAllProperties[sName];
};

/**
 * Returns infos about the properties declared by the UIElement class
 * described by this metadata object. Properties from ancestor classes
 * are not returned.
 *
 * The returned map contains property info objects keyed by the property name.
 *
 * @return {map} Map of property infos keyed by property names
 * @public
 */
sap.ui.core.ElementMetadata.prototype.getProperties = function() {
	return this._mProperties;
};

/**
 * Returns infos about all properties declared by the UIElement class
 * described by this metadata object as well as properties from base classes.
 *
 * The returned map contains property info objects keyed by the property name.
 *
 * @return {map} Map of property infos keyed by property names
 * @public
 */
sap.ui.core.ElementMetadata.prototype.getAllProperties = function() {
	return this._mAllProperties;
};

/**
 * Returns infos about the aggregations declared by the UIElement class
 * described by this metadata object. Aggregations from ancestor classes
 * are not returned.
 *
 * The returned map contains aggregation info objects keyed by the aggregation name.
 * In case of 0..1 aggregations this is the singular name, otherwise it is the plural
 * name.
 *
 * @return {map} Map of aggregation infos keyed by aggregation names
 * @public
 */
sap.ui.core.ElementMetadata.prototype.getAggregations = function() {
	return this._mAggregations;
};

/**
 * Checks the existance of the given aggregation by its name
 * @param {string} sName name of the aggregation
 * @return {boolean} true, if the aggregation exists
 * @public
 */
sap.ui.core.ElementMetadata.prototype.hasAggregation = function(sName) {
	return !!this._mAllAggregations[sName];
};

/**
 * Returns infos about all aggregations declared by the UIElement class
 * described by this metadata object as well as aggregations from base classes.
 *
 * The returned map contains aggregation info objects keyed by the aggregation name.
 * In case of 0..1 aggregations this is the singular name, otherwise it is the plural
 * name.
 *
 * @return {map} Map of aggregation infos keyed by aggregation names
 * @public
 */
sap.ui.core.ElementMetadata.prototype.getAllAggregations = function() {
	return this._mAllAggregations;
};

/**
 * Returns the name of the default aggregation of this control.
 * If the control itself does not define a default aggregation, then the
 * default aggregation of the parent is returned. If no control in the
 * hierarchy defines a default aggregation, null is returned.
 *
 * @return {string} Name of the default aggregation for this class
 */
sap.ui.core.ElementMetadata.prototype.getDefaultAggregationName = function() {
	return this._sDefaultAggregation;
};

/**
 * Returns the name of the default aggregation of this control.
 * If the control itself does not define a default aggregation, then the
 * default aggregation of the parent is returned.
 *
 * @return {string} Name of the default aggregation for this class
 */
sap.ui.core.ElementMetadata.prototype.getDefaultAggregation = function() {
	return this._sDefaultAggregation && this.getAllAggregations()[this._sDefaultAggregation];
};

/**
 * Returns infos about the associations declared by the UIElement class
 * described by this metadata object. Associations from ancestor classes
 * are not returned.
 *
 * The returned map contains association info objects keyed by the association name.
 * In case of 0..1 associations this is the singular name, otherwise it is the plural
 * name.
 *
 * @return {map} Map of association infos keyed by association names
 * @public
 */
sap.ui.core.ElementMetadata.prototype.getAssociations = function() {
	return this._mAssociations;
};

/**
 * Checks the existance of the given association by its name
 * @param {string} sName name of the association
 * @return {boolean} true, if the association exists
 * @public
 */
sap.ui.core.ElementMetadata.prototype.hasAssociation = function(sName) {
	return !!this._mAllAssociations[sName];
};

/**
 * Returns infos about all associations declared by the UIElement class
 * described by this metadata object as well as associations from base classes.
 *
 * The returned map contains association info objects keyed by the association name.
 * In case of 0..1 associations this is the singular name, otherwise it is the plural
 * name.
 *
 * @return {map} Map of association infos keyed by association names
 * @public
 */
sap.ui.core.ElementMetadata.prototype.getAllAssociations = function() {
	return this._mAllAssociations;
};

/**
 * Returns infos about the events declared by the UIElement class
 * described by this metadata object. Events from ancestor classes
 * are not returned.
 *
 * The returned map contains events info objects keyed by the events name.
 *
 * @return {map} Map of event infos keyed by event names
 * @public
 */
sap.ui.core.ElementMetadata.prototype.getEvents = function() {
	return this._mEvents;
};

/**
 * Checks the existance of the given event by its name
 * @param {string} sName name of the event
 * @return {boolean} true, if the event exists
 * @public
 */
sap.ui.core.ElementMetadata.prototype.hasEvent = function(sName) {
	return !!this._mAllEvents[sName];
};

/**
 * Returns infos about all events declared by the UIElement class
 * described by this metadata object as well as events from base classes.
 *
 * The returned map contains event info objects keyed by the event name.
 *
 * @return {map} Map of event infos keyed by event names
 * @public
 */
sap.ui.core.ElementMetadata.prototype.getAllEvents = function() {
	return this._mAllEvents;
};

/**
 * Returns a map of default values for all properties declared by the
 * described class and its ancestors, keyed by the property name.
 *
 * @return {map} Map of default values keyed by property names
 * @public
 */
sap.ui.core.ElementMetadata.prototype.getPropertyDefaults = function() {

	var mDefaults = this._mDefaults,
		oType;
	if ( mDefaults ) {
		return mDefaults;
	}

	if ( this.getParent() instanceof sap.ui.core.ElementMetadata ) {
		mDefaults = jQuery.sap.newObject(this.getParent().getPropertyDefaults());
	} else {
		mDefaults = {};
	}

	for(var s in this._mProperties) {
		if ( this._mProperties[s].defaultValue !== null ) {
			mDefaults[s] = this._mProperties[s].defaultValue;
		} else {
			oType = sap.ui.base.DataType.getType(this._mProperties[s].type);
			if (oType instanceof sap.ui.base.DataType) {
				mDefaults[s] = oType.getDefaultValue();
			} else { // Enumeration
				for (var i in oType) {
					mDefaults[s] = oType[i];
					break;
				}
			}
		}
	}
	return (this._mDefaults = mDefaults);
};

/**
 * Determines the class name of the renderer for the described control class.
 */
sap.ui.core.ElementMetadata.prototype.getRendererName = function() {
	return this._sRendererName;
};

/**
 * Retrieves the renderer for the described control class
 */
sap.ui.core.ElementMetadata.prototype.getRenderer = function() {

	// determine name via function for those legacy controls that override getRendererName()
	var sRendererName = this.getRendererName();

	if ( !sRendererName ) {
		return;
	}

	// check if renderer class exists already
	var fnRendererClass = jQuery.sap.getObject(sRendererName);
	if(fnRendererClass) {
		return fnRendererClass;
	}

	// if not, try to load a module with the same name
	jQuery.sap.require(sRendererName);
	return jQuery.sap.getObject(sRendererName);
};

sap.ui.core.ElementMetadata.prototype.createPropertyBag = function() {
	if ( !this._fnPropertyBagFactory ) {
		this._fnPropertyBagFactory = jQuery.sap.factory(this.getPropertyDefaults());
	}
	return new (this._fnPropertyBagFactory)();
};

/**
 * Helper method that enriches the (generated) information objects for children
 * (e.g. properties, aggregations, ...) of this Element.
 *
 * Also ensures that the parent metadata is enriched.
 *
 * @private
 */
sap.ui.core.ElementMetadata.prototype._enrichChildInfos = function() {

	if ( this._bEnriched ) {
		return;
	}

	if ( this.getParent() instanceof sap.ui.core.ElementMetadata ) {
		this.getParent()._enrichChildInfos();
	}

	var m,sName,oInfo;
	function method(sPrefix, sName) {
		return sPrefix + sName.substring(0,1).toUpperCase() + sName.substring(1);
	}

	// adapt properties
	m=this._mProperties;
	for(sName in m) {
		oInfo = m[sName];
		oInfo._sName = sName;
		oInfo._sUID = sName;
		oInfo._oParent = this;
		oInfo._iKind = sap.ui.core.ElementMetadata.Kind.PROPERTY;
		oInfo._sMutator = method("set", sName);
		oInfo._sGetter = method("get", sName);
	}

	// adapt aggregations
	m=this._mAggregations;
	for(sName in m) {
		oInfo = m[sName];
		oInfo._sName = sName;
		oInfo._sUID = "aggregation:" + sName;
		oInfo._oParent = this;
		oInfo._sDestructor = method("destroy", sName);
		if ( oInfo.multiple ) {
			oInfo._iKind = sap.ui.core.ElementMetadata.Kind.MULTIPLE_AGGREGATION;
			oInfo._sMutator = method("add", oInfo.singularName);
			oInfo._sRemoveMutator = method("remove", oInfo.singularName);
		} else {
			oInfo._iKind = sap.ui.core.ElementMetadata.Kind.SINGLE_AGGREGATION;
			oInfo._sMutator = method("set", sName);
			oInfo._sGetter = method("get", sName);
		}
	}

	// adapt associations
	m=this._mAssociations;
	for(sName in m) {
		oInfo = m[sName];
		oInfo._sName = sName;
		oInfo._sUID = "association:" + sName;
		oInfo._oParent = this;
		if ( oInfo.multiple ) {
			oInfo._iKind = sap.ui.core.ElementMetadata.Kind.MULTIPLE_ASSOCIATION;
			oInfo._sMutator = method("add", oInfo.singularName);
		} else {
			oInfo._iKind = sap.ui.core.ElementMetadata.Kind.SINGLE_ASSOCIATION;
			oInfo._sMutator = method("set", sName);
			oInfo._sGetter = method("get", sName);
		}
	}

	// adapt events
	m=this._mEvents;
	for(sName in m) {
		oInfo = m[sName];
		oInfo._sName = sName;
		oInfo._sUID = "event:" + sName;
		oInfo._oParent = this;
		oInfo._iKind = sap.ui.core.ElementMetadata.Kind.EVENT;
		oInfo._sMutator = method("attach", sName);
	}

	this._bEnriched = true;
};

/**
 * Builds a "reflection like" map of setters/type infos keyed by the possible JSON names.
 * Mainly used for the {@link sap.ui.core.Element.applySettings} method.
 *
 * @see sap.ui.core.Element.prototype.applySettings
 * @private
 */
sap.ui.core.ElementMetadata.prototype.getJSONKeys = function() {

	if ( this._mJSONKeys ) {
		return this._mJSONKeys;
	}

	this._enrichChildInfos();

	var mJSONKeys = {};
	function addKeys(m) {
		var sName, oInfo;
		for(sName in m) {
			oInfo = m[sName];
			if ( !mJSONKeys[sName] || oInfo._iKind < mJSONKeys[sName]._iKind ) {
				mJSONKeys[sName] = oInfo;
			};
			mJSONKeys[oInfo._sUID] = oInfo;
		};
	}

	addKeys(this.getAllProperties());
	addKeys(this.getAllAggregations());
	addKeys(this.getAllAssociations());
	addKeys(this.getAllEvents());

	return (this._mJSONKeys = mJSONKeys);
};

sap.ui.core.ElementMetadata.prototype.generateAccessors = function() {

	var meta=this;
	var proto = this.getClass().prototype;
	function method(sPrefix, sName, fn) {
		var sName = sPrefix + sName.substring(0,1).toUpperCase() + sName.substring(1);
		if ( !proto[sName] ) {
			proto[sName] = fn;
			meta._aPublicMethods.push(sName);
		}
	}

	jQuery.each(this._mProperties, function(n,info) {
		method("get", n, function() { return this.getProperty(n); });
		method("set", n, function(v) { this.setProperty(n,v); return this; });
		if ( info.bindable ) {
			method("bind", n, function(p,fn,m) { this.bindProperty(n,p,fn,m); return this; });
			method("unbind", n, function(p) { this.unbindProperty(n,p); return this; });
		}
	});
	jQuery.each(this._mAggregations, function(n,info) {
		if ( !info.multiple ) {
			method("get", n, function() { return this.getAggregation(n); });
			method("set", n, function(v) { this.setAggregation(n,v); return this; });
		} else {
			var n1 = info.singularName;
			method("get", n, function() { return this.getAggregation(n,[]); });
			method("add", n1, function(a) { this.addAggregation(n,a); return this; });
			method("insert", n1, function(i,a) { this.insertAggregation(n,i,a); return this; });
			method("remove", n1, function(a) { return this.removeAggregation(n,a); });
			method("removeAll", n, function() { return this.removeAllAggregation(n); });
			method("indexOf", n1, function(a) { return this.indexOfAggregation(n,a); });
			method("destroy", n, function(v) { this.destroyAggregation(n); return this; });
		}
		if ( info.bindable ) {
			method("bind", n, function(p,t,s,f) { this.bindAggregation(n,p,t,s,f); return this; });
			method("unbind", n, function(p) { this.unbindAggregation(n,p); return this; });
		}
	});
	jQuery.each(this._mAssociations, function(n,info) {
		if ( !info.multiple ) {
			method("get", n, function() { return this.getAssociation(n); });
			method("set", n, function(v) { this.setAssociation(n,v); return this; });
		} else {
			var n1 = info.singularName;
			method("get", n, function() { return this.getAssociation(n,[]); });
			method("add", n1, function(a) { this.addAssociation(n,a); return this; });
			method("remove", n1, function(a) { return this.removeAssociation(n,a); });
			method("removeAll", n, function() { return this.removeAllAssociation(n); });
		}
	});
	jQuery.each(this._mEvents, function(n,info) {
		method("attach", n, function(d,f,o) { this.attachEvent(n,d,f,o); return this; });
		method("detach", n, function(f,o) { this.detachEvent(n,f,o); return this; });
		var n1 = !!info.allowPreventDefault;
		method("fire", n, function(p) { return this.fireEvent(n,p, n1); });
	});

};

(function() {

	/**
	 * Usage counters for the different UID tokens
	 */
	var mUIDCounts = {};

	function uid(sId) {
		jQuery.sap.assert(!/[0-9]+$/.exec(sId), "AutoId Prefixes must not end with numbers");

		sId = sap.ui.getCore().getConfiguration().getUIDPrefix() + sId;

		// initialize counter
		mUIDCounts[sId] = mUIDCounts[sId] || 0;

		// combine prefix + counter
		// concatenating sId and a counter is only safe because we don't allow trailing numbers in sId!
		return (sId + mUIDCounts[sId]++);
	}

	/**
	 * Calculates a new id based on a prefix.
	 *
	 * @return {string} A (hopefully unique) control id
	 * @public
	 * @function
	 */
	sap.ui.core.ElementMetadata.uid = uid;

	/**
	 * Calculates a new id for an instance of this class.
	 *
	 * Note that the calculated short name part is usually not unique across
	 * all classes, but doesn't have to be. It might even be empty when the
	 * class name consists of invalid characters only.
	 *
	 * @return {string} A (hopefully unique) control id
	 * @public
	 */
	sap.ui.core.ElementMetadata.prototype.uid = function() {

		var sId = this._sUIDToken;
		if ( typeof sId !== "string" ) {
			// start with qualified class name
			sId  = this.getName();
			// reduce to unqualified name
			sId = sId.slice(sId.lastIndexOf('.')+1);
			// reduce a camel case, multi word name to the last word
			sId = sId.replace(/([a-z])([A-Z])/g, "$1 $2").split(" ").slice(-1)[0];
			// remove unwanted chars (and no trailing digits!) and convert to lower case
			sId = this._sUIDToken = sId.replace(/([^A-Za-z0-9-_.:])|([0-9]$)/g,"").toLowerCase();
		}

		return uid(sId);
	};

}());

}; // end of sap.ui.core.ElementMetadata

if ( !jQuery.sap.isDeclared('sap.ui.model.Model') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides the base implementation for all model implementations
jQuery.sap.declare("sap.ui.model.Model");

if ( !jQuery.sap.isDeclared('sap.ui.model.BindingMode') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides enumeration sap.ui.model.FilterOperator
jQuery.sap.declare("sap.ui.model.BindingMode");

/**
* @class
* Binding type definitions.
*
* @static
* @public
*/
sap.ui.model.BindingMode = {

		/**
		 * BindingMode default means that the binding mode of the model is used
		 * @public
		 */
		Default: "Default",

		/**
		 * BindingMode one time means value is only read from the model once
		 * @public
		 */
		OneTime: "OneTime",

		/**
		 * BindingMode one way means from model to view
		 * @public
		 */
		OneWay: "OneWay",

		/**
		 * BindingMode two way means from model to view and vice versa
		 * @public
		 */
		TwoWay: "TwoWay"

};
}; // end of sap.ui.model.BindingMode


/**
 * The SAPUI5 Data Binding API.
 *
 * The default binding mode for model implementations (if not implemented otherwise) is two way and the supported binding modes by the model
 * are one way, two way and one time. The default binding mode can be changed by the application for each model instance.
 * A model implementation should specify its supported binding modes and set the default binding mode accordingly
 * (e.g. if the model supports only one way binding the default binding mode should also be set to one way).
 *
 * @namespace
 * @name sap.ui.model
 * @public
 */

/**
 * Constructor for a new Model.
 *
 * @class
 * This is an abstract base class for model objects.
 * @abstract
 *
 * @extends sap.ui.base.Object
 *
 * @author SAP AG
 * @version 1.5.0-SNAPSHOT
 *
 * @constructor
 * @public
 */
sap.ui.model.Model = function () {
	sap.ui.base.EventProvider.apply(this, arguments);

	this.oData = {};
	this.aBindings = [];
	this.sDefaultBindingMode = sap.ui.model.BindingMode.TwoWay;
	this.mSupportedBindingModes = {"OneWay": true, "TwoWay": true, "OneTime": true};
};

// chain the prototypes
sap.ui.model.Model.prototype = jQuery.sap.newObject(sap.ui.base.EventProvider.prototype);

/*
 * Describe the sap.ui.model.Model.
 * Resulting metadata can be obtained via sap.ui.model.Model.getMetadata();
 */
sap.ui.base.Object.defineClass("sap.ui.model.Model", {

  // ---- object ----
  baseType : "sap.ui.base.Object",
  publicMethods : [
	// methods
	"bindProperty", "bindList", "bindTree", "createBindingContext", "destroyBindingContext", "getProperty",
	"getDefaultBindingMode", "setDefaultBindingMode", "isBindingModeSupported", "attachParseError", "detachParseError",
	"attachRequestCompleted", "detachRequestCompleted", "attachRequestFailed", "detachRequestFailed", "attachRequestSent",
	"detachRequestSent"
  ]

});

/**
 * Map of event names, that are provided by the model.
 */
sap.ui.model.Model.M_EVENTS = {
	/**
	 * Depending on the model implementation a ParseError should be fired if a parse error occurred.
	 * Contains the parameters:
	 * errorCode, url, reason, srcText, line, linepos, filepos
	 */
	ParseError : "parseError",

	/**
	 * Depending on the model implementation a RequestFailed should be fired if a request to a backend failed.
	 * Contains the parameters:
	 * message, statusCode, statusText and responseText
	 */
	RequestFailed : "requestFailed",

	/**
	 * Depending on the model implementation a RequestSent should be fired when a request to a backend is sent.
	 * Contains Parameters: url, type, async, info
	 */
	RequestSent : "requestSent",

	/**
	 * Depending on the model implementation a RequestCompleted should be fired when a request to a backend is completed regardless if the request failed or succeeded.
	 * Contains Parameters: url, type, async, info
	 */
	RequestCompleted : "requestCompleted"
};

/**
 * The 'requestFailed' event is fired, when data retrieval from a backend failed.
 *
 * @name sap.ui.model.Model#requestFailed
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters

 * @param {string} oControlEvent.getParameters.message A text that describes the failure.
 * @param {string} oControlEvent.getParameters.statusCode HTTP status code returned by the request (if available)
 * @param {string} oControlEvent.getParameters.statusText The status as a text, details not specified, intended only for diagnosis output
 * @param {string} oControlEvent.getParameters.responseText Response that has been received for the request ,as a text string
 * @public
 */

/**
 * Attach event-handler <code>fnFunction</code> to the 'requestFailed' event of this <code>sap.ui.model.Model</code>.<br/>
 *
 *
 * @param {object}
 *            [oData] The object, that should be passed along with the event-object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs. This function will be called on the
 *            oListener-instance (if present) or in a 'static way'.
 * @param {object}
 *            [oListener] Object on which to call the given function. If empty, this Model is used.
 *
 * @return {sap.ui.model.Model} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.model.Model.prototype.attachRequestFailed = function(oData, fnFunction, oListener) {
	this.attachEvent("requestFailed", oData, fnFunction, oListener);
	return this;
};

/**
 * Detach event-handler <code>fnFunction</code> from the 'requestFailed' event of this <code>sap.ui.model.Model</code>.<br/>
 *
 * The passed function and listener object must match the ones previously used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Object on which the given function had to be called.
 * @return {sap.ui.model.Model} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.model.Model.prototype.detachRequestFailed = function(fnFunction, oListener) {
	this.detachEvent("requestFailed", fnFunction, oListener);
	return this;
};

/**
 * Fire event requestFailed to attached listeners.
 *
 * Expects following event parameters:
 * <ul>
 * <li>'message' of type <code>string</code> A text that describes the failure.</li>
 * <li>'statusCode' of type <code>string</code> HTTP status code returned by the request (if available)</li>
 * <li>'statusText' of type <code>string</code> The status as a text, details not specified, intended only for diagnosis output</li>
 * <li>'responseText' of type <code>string</code> Response that has been received for the request ,as a text string</li>
 * </ul>
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.model.Model} <code>this</code> to allow method chaining
 * @protected
 */
sap.ui.model.Model.prototype.fireRequestFailed = function(mArguments) {
	this.fireEvent("requestFailed", mArguments);
	return this;
};


/**
 * The 'parseError' event is fired when parsing of a model document (e.g. XML response) fails.
 *
 * @name sap.ui.model.Model#parseError
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters

 * @param {int} oControlEvent.getParameters.errorCode
 * @param {string} oControlEvent.getParameters.url
 * @param {string} oControlEvent.getParameters.reason
 * @param {string} oControlEvent.getParameters.srcText
 * @param {int} oControlEvent.getParameters.line
 * @param {int} oControlEvent.getParameters.linepos
 * @param {int} oControlEvent.getParameters.filepos
 * @public
 */

/**
 * Attach event-handler <code>fnFunction</code> to the 'parseError' event of this <code>sap.ui.model.Model</code>.<br/>
 *
 *
 * @param {object}
 *            [oData] The object, that should be passed along with the event-object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs. This function will be called on the
 *            oListener-instance (if present) or in a 'static way'.
 * @param {object}
 *            [oListener] Object on which to call the given function. If empty, the global context (window) is used.
 *
 * @return {sap.ui.model.Model} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.model.Model.prototype.attachParseError = function(oData, fnFunction, oListener) {
	this.attachEvent("parseError", oData, fnFunction, oListener);
	return this;
};

/**
 * Detach event-handler <code>fnFunction</code> from the 'parseError' event of this <code>sap.ui.model.Model</code>.<br/>
 *
 * The passed function and listener object must match the ones previously used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Object on which the given function had to be called.
 * @return {sap.ui.model.Model} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.model.Model.prototype.detachParseError = function(fnFunction, oListener) {
	this.detachEvent("parseError", fnFunction, oListener);
	return this;
};

/**
 * Fire event parseError to attached listeners.
 *
 * Expects following event parameters:
 * <ul>
 * <li>'errorCode' of type <code>int</code> </li>
 * <li>'url' of type <code>string</code> </li>
 * <li>'reason' of type <code>string</code> </li>
 * <li>'srcText' of type <code>string</code> </li>
 * <li>'line' of type <code>int</code> </li>
 * <li>'linepos' of type <code>int</code> </li>
 * <li>'filepos' of type <code>int</code> </li>
 * </ul>
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.model.Model} <code>this</code> to allow method chaining
 * @protected
 */
sap.ui.model.Model.prototype.fireParseError = function(mArguments) {
	this.fireEvent("parseError", mArguments);
	return this;
};

/**
 * Attach event-handler <code>fnFunction</code> to the 'requestSent' event of this <code>sap.ui.model.Model</code>.<br/>
 *
 *
 * @param {object}
 *            [oData] The object, that should be passed along with the event-object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs. This function will be called on the
 *            oListener-instance (if present) or in a 'static way'.
 * @param {object}
 *            [oListener] Object on which to call the given function. If empty, the global context (window) is used.
 *
 * @return {sap.ui.model.Model} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.model.Model.prototype.attachRequestSent = function(oData, fnFunction, oListener) {
	this.attachEvent("requestSent", oData, fnFunction, oListener);
	return this;
};

/**
 * Detach event-handler <code>fnFunction</code> from the 'requestSent' event of this <code>sap.ui.model.Model</code>.<br/>
 *
 * The passed function and listener object must match the ones previously used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Object on which the given function had to be called.
 * @return {sap.ui.model.Model} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.model.Model.prototype.detachRequestSent = function(fnFunction, oListener) {
	this.detachEvent("requestSent", fnFunction, oListener);
	return this;
};

/**
 * Fire event requestSent to attached listeners.
 *
 * Expects following event parameters:
 * <ul>
 * <li>'url' of type <code>string</code> The url which is sent to the backend.</li>
 * <li>'type' of type <code>string</code> The type of the request (if available)</li>
 * <li>'async' of type <code>boolean</code> If the request is synchronous or asynchronous (if available)</li>
 * <li>'info' of type <code>string</code> additional information for the request (if available)</li>
 * </ul>
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.model.Model} <code>this</code> to allow method chaining
 * @protected
 */
sap.ui.model.Model.prototype.fireRequestSent = function(mArguments) {
	this.fireEvent("requestSent", mArguments);
	return this;
};

/**
 * Attach event-handler <code>fnFunction</code> to the 'requestCompleted' event of this <code>sap.ui.model.Model</code>.<br/>
 *
 *
 * @param {object}
 *            [oData] The object, that should be passed along with the event-object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs. This function will be called on the
 *            oListener-instance (if present) or in a 'static way'.
 * @param {object}
 *            [oListener] Object on which to call the given function. If empty, the global context (window) is used.
 *
 * @return {sap.ui.model.Model} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.model.Model.prototype.attachRequestCompleted = function(oData, fnFunction, oListener) {
	this.attachEvent("requestCompleted", oData, fnFunction, oListener);
	return this;
};

/**
 * Detach event-handler <code>fnFunction</code> from the 'requestCompleted' event of this <code>sap.ui.model.Model</code>.<br/>
 *
 * The passed function and listener object must match the ones previously used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Object on which the given function had to be called.
 * @return {sap.ui.model.Model} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.model.Model.prototype.detachRequestCompleted = function(fnFunction, oListener) {
	this.detachEvent("requestCompleted", fnFunction, oListener);
	return this;
};

/**
 * Fire event requestCompleted to attached listeners.
 *
 * Expects following event parameters:
 * <ul>
 * <li>'url' of type <code>string</code> The url which was sent to the backend.</li>
 * <li>'type' of type <code>string</code> The type of the request (if available)</li>
 * <li>'async' of type <code>boolean</code> If the request was synchronous or asynchronous (if available)</li>
 * <li>'info' of type <code>string</code> additional information for the request (if available)</li>
 * </ul>
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.model.Model} <code>this</code> to allow method chaining
 * @protected
 */
sap.ui.model.Model.prototype.fireRequestCompleted = function(mArguments) {
	this.fireEvent("requestCompleted", mArguments);
	return this;
};


// the 'abstract methods' to be implemented by child classes

/**
 * Implement in inheriting classes
 * @abstract
 *
 * @name sap.ui.model.Model.prototype.bindProperty
 * @function
 * @param {string}
 *         sPath the path pointing to the property that should be bound
 * @param {object}
 *         [oContext=null] the context object for this databinding (optional)
 * @return {sap.ui.model.PropertyBinding}
 *
 * @public
 */

/**
 * Implement in inheriting classes
 * @abstract
 *
 * @name sap.ui.model.Model.prototype.bindList
 * @function
 * @param {string}
 *         sPath the path pointing to the list / array that should be bound
 * @param {object}
 *         [oContext=null] the context object for this databinding (optional)
 * @param {sap.ui.model.Sorter}
 *         [oSorter=null] initial sort order (optional)
 * @param {array}
 *         [aFilters=null] predefined filter/s contained in an array (optional)
 * @return {sap.ui.model.ListBinding}

 * @public
 */

/**
 * Implement in inheriting classes
 * @abstract
 *
 * @name sap.ui.model.Model.prototype.bindTree
 * @function
 * @param {string}
 *         sPath the path pointing to the tree / array that should be bound
 * @param {object}
 *         [oContext=null] the context object for this databinding (optional)
 * @return {sap.ui.model.TreeBinding}

 * @public
 */

/**
 * Implement in inheriting classes
 * @abstract
 *
 * @name sap.ui.model.Model.prototype.createBindingContext
 * @function
 * @param {string}
 *         sPath the path to create the new context from
 * @param {object}
 *		   [oContext=null] the context which should be used to create the new binding context
 * @param {function}
 *         fCallBack the function which should be called after the binding context has been created

 * @public
 */

/**
 * Implement in inheriting classes
 * @abstract
 *
 * @name sap.ui.model.Model.prototype.destroyBindingContext
 * @function
 * @param {object}
 *         oContext to destroy

 * @public
 */

/**
 * Implement in inheriting classes
 * @abstract
 *
 * @name sap.ui.model.Model.prototype.getProperty
 * @function
 * @param {string}
 *         sPath the path to where to read the attribute value
 * @param {object}
 *		   [oContext=null] the context with which the path should be resolved
 * @public
 */

/**
 * Add a binding to this model
 *
 * @param {sap.ui.model.Binding} oBinding the binding to be added
 */
sap.ui.model.Model.prototype.addBinding = function(oBinding) {
	this.aBindings.push(oBinding);
};

/**
 * Remove a binding from the model
 *
 * @param {sap.ui.model.Binding} oBinding the binding to be removed
 */
sap.ui.model.Model.prototype.removeBinding = function(oBinding) {
	for (var i = 0; i < this.aBindings.length; i++) {
		if (this.aBindings[i] == oBinding) {
			this.aBindings.splice(i, 1);
			break;
		}
	}
};

/**
 * Get the default binding mode for the model
 *
 * @return {sap.ui.model.BindingMode} default binding mode of the model
 *
 * @public
 */
sap.ui.model.Model.prototype.getDefaultBindingMode = function() {
	return this.sDefaultBindingMode;
};

/**
 * Set the default binding mode for the model. If the default binding mode should be changed,
 * this method should be called directly after model instance creation and before any binding creation.
 * Otherwise it is not guaranteed that the existing bindings will be updated with the new binding mode.
 *
 * @param {sap.ui.model.BindingMode} sMode the default binding mode to set for the model
 *
 * @public
 */
sap.ui.model.Model.prototype.setDefaultBindingMode = function(sMode) {
	if (this.isBindingModeSupported(sMode)) {
		this.sDefaultBindingMode = sMode;
	}
	else {
		throw new Error("Binding mode " + sMode + " is not supported by this model.");
	}
};

/**
 * Check if the specified binding mode is supported by the model.
 *
 * @param {sap.ui.model.BindingMode} sMode the binding mode to check
 *
 * @public
 */
sap.ui.model.Model.prototype.isBindingModeSupported = function(sMode) {
	return (sMode in this.mSupportedBindingModes);
};


}; // end of sap.ui.model.Model

if ( !jQuery.sap.isDeclared('sap.ui.model.SimpleType') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides the base implementation for all model implementations
jQuery.sap.declare("sap.ui.model.SimpleType");
if ( !jQuery.sap.isDeclared('sap.ui.model.Type') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides the base implementation for all model implementations
jQuery.sap.declare("sap.ui.model.Type");


/**
 * Constructor for a new Type.
 *
 * @class
 * This is an abstract base class for type objects.
 * @abstract
 *
 * @extends sap.ui.base.Object
 *
 * @author SAP AG
 * @version 1.5.0-SNAPSHOT
 *
 * @constructor
 * @public
 */
sap.ui.model.Type = function () {
	sap.ui.base.Object.apply(this, arguments);
	this.sName = "Type";
};

// chain the prototypes
sap.ui.model.Type.prototype = jQuery.sap.newObject(sap.ui.base.Object.prototype);

/*
 * Describe the sap.ui.model.Type.
 * Resulting metadata can be obtained via sap.ui.model.Type.getMetadata();
 */
sap.ui.base.Object.defineClass("sap.ui.model.Type", {

  // ---- object ----
  baseType : "sap.ui.base.Object",
  publicMethods : [
    // methods
    "getName"
  ]

});


/**
 * Returns the name of this type.
 *
 * @return {String} the name of this type
 * @public
 */
sap.ui.model.Type.prototype.getName = function() {
	return this.sName;
};
}; // end of sap.ui.model.Type

if ( !jQuery.sap.isDeclared('sap.ui.model.ParseException') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides a filter for list bindings
jQuery.sap.declare("sap.ui.model.ParseException");
if ( !jQuery.sap.isDeclared('sap.ui.base.Exception') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides a filter for list bindings
jQuery.sap.declare("sap.ui.base.Exception");

/**
 * Exception class
 *
 * This is the base exception class. In contrary to the Error an Exception
 * should be thrown in cases, where the exception can, and should, be handled
 * within the framework, instead of causing the application to exit.
 *
 * The try/catch statement in JavaScript can not catch specific exceptions, so
 * when catching internal exceptions you should make sure to rethrow other errors:
 *
 * try {
 *     ...
 * }
 * catch (oException) {
 *     if (oException instanceof sap.ui.base.Exception) {
 *         ... handle exception ...
 *     }
 *     else {
 *         throw oException;
 *     }
 * }
 *
 */
sap.ui.base.Exception = function(message) {
	this.name = "Exception";
	this.message = message;
};

}; // end of sap.ui.base.Exception


/**
 * ParseException class
 *
 * This exception is thrown, when a parse error occurs while converting a
 * string value to a specific property type in the model.
 */
sap.ui.model.ParseException = function(message) {
	this.name = "ParseException";
	this.message = message;
};
sap.ui.model.ParseException.prototype = jQuery.sap.newObject(sap.ui.base.Exception.prototype);
}; // end of sap.ui.model.ParseException

if ( !jQuery.sap.isDeclared('sap.ui.model.ValidateException') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides a filter for list bindings
jQuery.sap.declare("sap.ui.model.ValidateException");


/**
 * ValidateException class
 *
 * This exception is thrown, when a validation error occurs while checking the
 * defined constraints for a type.
 */
sap.ui.model.ValidateException = function(message, violatedConstraints) {
	this.name = "ValidateException";
	this.message = message;
	this.violatedConstraints = violatedConstraints;
};
sap.ui.model.ValidateException.prototype = jQuery.sap.newObject(sap.ui.base.Exception.prototype);

}; // end of sap.ui.model.ValidateException

if ( !jQuery.sap.isDeclared('sap.ui.model.FormatException') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides a filter for list bindings
jQuery.sap.declare("sap.ui.model.FormatException");


/**
 * FormatException class
 *
 * This exception is thrown, when an error occurs while trying to convert a value of the model to
 * a specific property value in the UI.
 *
 */
sap.ui.model.FormatException = function(message) {
	this.name = "FormatException";
	this.message = message;
};
sap.ui.model.FormatException.prototype = jQuery.sap.newObject(sap.ui.base.Exception.prototype);
}; // end of sap.ui.model.FormatException



/**
 * Constructor for a new SimpleType.
 *
 * @class
 * This is an abstract base class for simple types.
 * @abstract
 *
 * @extends sap.ui.model.Type
 *
 * @author SAP AG
 * @version 1.5.0-SNAPSHOT
 *
 * @constructor
 * @public
 */
sap.ui.model.SimpleType = function(oFormatOptions, oConstraints) {
	sap.ui.model.Type.apply(this, arguments);
	this.setFormatOptions(oFormatOptions || {});
	this.setConstraints(oConstraints || {});
	this.sName = "SimpleType";
};

// chain the prototypes
sap.ui.model.SimpleType.prototype = jQuery.sap.newObject(sap.ui.model.Type.prototype);

/*
 * Describe the sap.ui.model.SimpleType.
 * Resulting metadata can be obtained via sap.ui.model.SimpleType.getMetadata();
 */
sap.ui.base.Object.defineClass("sap.ui.model.SimpleType", {

  // ---- object ----
  baseType : "sap.ui.model.Type",
  publicMethods : [
    // methods
    "setConstraints", "setFormatOptions", "formatValue", "parseValue", "validateValue"
  ]

});

/**
 * Format the given value in model representation to an output value in the given
 * internal type. This happens according to the format options, if target type is 'string'.
 * If oValue is not defined or null, null will be returned.
 *
 * @function
 * @name sap.ui.model.SimpleType.prototype.formatValue
 * @param {any} oValue the value to be formatted
 * @param {string} sInternalType the target type
 * @return {any} the formatted output value
 *
 * @public
 */

/**
 * Parse a value of an internal type to the expected value of the model type.
 *
 * @function
 * @name sap.ui.model.SimpleType.prototype.parseValue
 * @param {any} oValue the value to be parsed
 * @param {string} sInternalType the source type
 * @return {any} the parse result
 *
 * @public
 */

/**
 * Validate whether a given value in model representation is valid and meets the
 * defined constraints (if any).
 *
 * @function
 * @name sap.ui.model.SimpleType.prototype.validateValue
 * @param {any} oValue the value to be validated
 *
 * @public
 */

/**
 * Sets constraints for this type. This is meta information used when validating the
 * value, to ensure it meets certain criteria, e.g. maximum length, minimal amount
 *
 * @param {object} oConstraints the constraints to set for this type
 */
sap.ui.model.SimpleType.prototype.setConstraints = function(oConstraints) {
	this.oConstraints = oConstraints;
};

/**
 * Set format options for this type. This is meta information used when formatting and
 * parsing values, such as patterns for number and date formatting or maximum length
 *
 * @param {object} oFormatOptions the options to set for this type
 */
sap.ui.model.SimpleType.prototype.setFormatOptions = function(oFormatOptions) {
	this.oFormatOptions = oFormatOptions;
};
}; // end of sap.ui.model.SimpleType


/**
 * Constructs and initializes an UI Element with the given <code>sId</code> and settings.
 *
 * If the optional <code>mSettings</code> are given, they must be a JSON-like object (object literal)
 * that defines values for properties, aggregations, associations or events keyed by their name.
 *
 * <b>Valid Names:</b>
 *
 * The property (key) names supported in the object literal are exactly the (case sensitive)
 * names documented in the JSDoc for the properties, aggregations, associations and events
 * of the control and its base classes. Note that for  0..n aggregations and associations this
 * usually is the plural name, whereas it is the singular name in case of 0..1 relations.
 *
 * If a key name is ambiguous for a specific control class (e.g. a property has the same
 * name as an event), then this method prefers property, aggregation, association and
 * event in that order. To resolve such ambiguities, the keys can be prefixed with
 * <code>aggregation:</code>, <code>association:</code> or <code>event:</code>.
 * In that case the keys must be quoted due to the ':'.
 *
 * Each subclass should document the set of supported names in its constructor documentation.
 *
 * <b>Valid Values:</b>
 *
 * <ul>
 * <li>for normal properties, the value has to be of the correct simple type (no type conversion occurs)
 * <li>for 0..1 aggregations, the value has to be an instance of the aggregated control or element type
 * <li>for 0..n aggregations, the value has to be an array of instances of the aggregated type
 * <li>for 0..1 associations, an instance of the associated type or an id (string) is accepted
 * <li>0..n associations are not supported yet
 * <li>for events either a function (event handler) is accepted or an array of length 2
 *     where the first element is a function and the 2nd element is an object to invoke the method on.
 * </ul>
 *
 * @param {string} [sId] id for the new control; generated automatically if no non-empty id is given
 *      Note: this can be omitted, no matter whether <code>mSettings</code> will be given or not!
 * @param {object} [mSettings] optional map/JSON-object with initial property values, aggregated objects etc. for the new element
 *
 * @class Base Class for Elements.
 * @extends sap.ui.base.EventProvider
 * @author Martin Schaus, Daniel Brinkmann
 * @version 1.5.0-SNAPSHOT
 * @public
 * @name sap.ui.core.Element
 */
sap.ui.base.EventProvider.extend("sap.ui.core.Element", {

	metadata : {
	  "abstract" : true,
	  publicMethods : [ "getId", "getMetadata", "getTooltip", "setTooltip", "getTooltip_AsString", "getTooltip_Text", "getModel", "setModel", "hasModel", "bindProperty", "unbindProperty", "bindAggregation", "unbindAggregation", "prop", "getCustomData", "insertCustomData", "addCustomData", "removeCustomData", "removeAllCustomData", "indexOfCustomData", "destroyCustomData" ],
	  library : "sap.ui.core",
	  properties : {
		// TODO can't yet declare id as a property: would show up in ControlTree and applySettings would allow to modify id
		// id : {name : "id", type : "string", group : "Identification", defaultValue : '', readOnly : true}
	  },
	  aggregations : {
		tooltip : {name : "tooltip", type : "sap.ui.core.TooltipBase", altTypes : ["string"], multiple : false},
		customData : {name : "customData", type : "sap.ui.core.CustomData", multiple : true, singularName : "customData"}
	  },
	  associations : {},
	  events : {}
	},

	constructor : function(sId, mSettings) {

		sap.ui.base.EventProvider.apply(this); // no use to pass our arguments
		if (typeof(sId) != "string" && arguments.length>0) {
			// shift arguments in case sId was missing, but mSettings was given
			mSettings = sId;
			if (mSettings && mSettings.id) {
				sId = mSettings["id"];
			} else {
				sId = null;
			}
		}

		if (!sId) {
			sId = this.getMetadata().uid() || jQuery.sap.uid();
		} else {
			var preprocessor = sap.ui.core.Element._fnIdPreprocessor;
			sId = (preprocessor ? preprocessor.call(this, sId) : sId);
			var oType = sap.ui.base.DataType.getType("sap.ui.core.ID");
			if (!oType.isValid(sId)) {
				throw new Error("\"" + sId + "\" is not a valid ID.");
			}
		}
		this.sId = sId;

		// control interface
		// create an empty property bag that uses a map of defaultValues as its prototype
		this.mProperties = this.getMetadata().createPropertyBag();
		this.mAggregations = {};
		this.mAssociations = {};
		this.mMethods = {};

		// private properties
		this.oParent = null;
		this.bPrerendered = this.getDomRef() != null;
		this.aDelegates = [];
		this.aBeforeDelegates = [];
		this.iSuppressInvalidate = 0;

		// data binding
		this.oModels = {};
		this.mBindingInfos = {};

		// TODO: generic concept for init hooks?
		if ( this._initCompositeSupport ) {
			this._initCompositeSupport(mSettings);
		}

		// Call init method here instead of specific Controls constructor.
		if (this.init) {
			this.init();
		}

		// apply the settings
		this.applySettings(mSettings);

		// registers the element in the Core
		this.register();

	},

	renderer : null // Element has no renderer

}, /* Metadata constructor */ sap.ui.core.ElementMetadata);

/**
 * Creates a new subclass of class sap.ui.core.Element with name <code>sClassName</code>
 * and enriches it with the information contained in <code>oClassInfo</code>.
 *
 * <code>oClassInfo</code> might contain the following:
 * <ul>
 * <li><code>metadata:</code> an (optional) object literal containing meta information about the class.
 * The information in the object literal will be wrapped by an instance of {@link sap.ui.core.ElementMetadata ElementMetadata}
 * and might contain the following information:
 * <ul>
 * <li>all values accepted for metadata as documented for the {@link sap.ui.base.Object.extend Object.extend} method</li>
 * <li>library: {string} (optional) name of the library that contains the element/control
 * <li>properties: a map of property info objects, mapped by the property name
 *     Each info object should be a simple object literal and may contain the following information
 *     <ul>
 *     <li>type {string} optional type of the property, defaults to type "string"
 *     <li>[defaultValue] {any} default value of the property. When omitted, defaults to the default value for the type
 *     <li>group {string} optional semantic group of the property. Defaults to "Misc"
 *     </ul>
 *     If the property info object is not an object literal, it is assumed to be a string and
 *     interpreted as the type of the property. All other informations use their default values.
 * <li>aggregations: a map of aggregation info objects, mapped by the aggregation name
 *     By convention, the name should be a singular name for aggregations of cardinality 0..1 and
 *     should be a plural name for aggregations of cardinality 0..n.
 *
 *     The info object should contain the following information
 *     <ul>
 *     <li>type {string} (optional) type of the aggregated controls/elements, defaults to sap.ui.core.Control
 *     <li>altTypes {string[]} (optional) alternative primitive types that the aggregation can have (like string etc.). Defaults to no alternative types.
 *     <li>multiple {boolean} (optional) information about the cardinality, defaults to true (multiple aggregation)
 *     <li>singularName {string} (optional) singular name for 0..n aggregations. If not specified, a singular name is guessed from the plural name.
 *     </ul>
 *     If the aggregation info object is not an object literal, it is assumed to be a string and
 *     interpreted as the type of the aggregation. All other informations use their default values.
 * <li>associations: a map of association info objects, mapped by the association name
 *     By convention, the name should be a singular name for aggregations of cardinality 0..1 and
 *     should be a plural name for aggregations of cardinality 0..n.
 *
 *     The info object should contain the following information
 *     <ul>
 *     <li>type {string} type of the associated controls/elements, defaults to sap.ui.core.Control
 *     <li>multiple {boolean} (optional) information about the cardinality, defaults to false (single aggregation)
 *     <li>singularName {string} (optional) singular name for 0..n aggregations. If not specified, a singular name is guessed from the plural name.
 *     </ul>
 *     If the association info object is not an object literal, it is assumed to be a string and
 *     interpreted as the type of the aggregation. All other informations then use their default values.
 * <li>events: a map of event info objects, mapped by the event name
 *     The info object can contain the following information
 *     <ul>
 *     <li><code>allowPreventDefault:</code> {boolean} whether the control allows to prevent its default behavior for this event (defaults to false) </li>
 *     </ul>
 * </ul>
 * For all properties, aggregations, associations and events, the usual access methods are created and added to the public facade.
 * They don't need to be listed in the publicMethods array.
 * </li>
 *
 * <li><code>constructor:</code> a function that serves as a constructor function for the new element class.
 * If no constructor function is given, the framework creates a default implementation that delegates all
 * its arguments to the constructor function of the base class.
 * <b>Note:</b> most of the time, subclasses of Element don't need to specify their own constructor function.
 * They should use the symmetric {@link #init} and {@link #exit} hooks instead.
 * </li>
 *
 * <li><code>renderer:</code> definition of a renderer. This can be any of the following
 * <ul>
 * <li>the class name of a renderer class (a string)</li>
 * <li>a render function with signature <code>function(oRenderManager, oControl)</code> that implements the rendering for the new class</li>
 * <li>an object literal that contains functions/properties that should be mixed into a new render class which is
 * created as a subclass of the renderer of the current class.</li>
 * </ul>
 * <b>Note:</b> usually only controls have a renderer. But to keep the control creation APIs simple and to honor future
 * extensions of the current policy, the definition of a renderer is supported for direct subclasses of Element as well.
 * </li>
 *
 * <li><i>any-other-name:</i> any other property in the <code>oClassInfo</code> is copied into the prototype
 * object of the newly created class. Callers can thereby add methods or properties to all instances of the
 * class. But be aware that the given values are shared between all instances of the class. Usually, it doesn't
 * make sense to use primitive values here other than to declare public constants.
 *
 * All methods added this way and whose name is not 'init' nor 'exit' nor does it start with an underscore ('_')
 * nor with the prefix 'on' are assumed to be public methods and are automatically added to the list of public facade methods.
 * </ul>
 *
 * The prototype object of the newly created class uses the same prototype as instances of the base class
 * (prototype chaining).
 *
 * A metadata object is always created, even if there is no <code>metadata</code> entry in the <code>oClassInfo</code>
 * object. A getter for the metadata is always attached to the prototype and to the class (constructor function)
 * itself.
 *
 * Last but not least, with the third argument <code>FNMetaImpl</code> the constructor of a metadata class
 * can be specified. Instances of that class will be used to represent metadata for the newly created class
 * and for any subclass created from it. Typically, only frameworks will use this parameter to enrich the
 * metadata for a new class hierarchy they introduce (as done by  {@link sap.ui.core.Element Element}).
 *
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] structured object with informations about the class
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.core.ElementMetadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.ui.core.Element.extend
 * @function
 * @since 1.3.1
 */

/**
 * Creates metadata for an UI Element by extending the Object Metadata.
 *
 * In addition to the entries defined by {@link sap.ui.base.Object.defineClass}, the following
 * entries can be specified in the static info object:
 *
 * <ul>
 * <li>library: {string} name of the library that contains the element/control
 * <li>properties: a map of property info objects, mapped by the property name
 *     Info object should contain the following information
 *     <ul>
 *     <li>name {string} name of the property (redundant to map key)
 *     <li>type {string} type of the property
 *     <li>[defaultValue] {any} default value of the property. Can be omitted
 *     </ul>
 * <li>aggregations: a map of aggregation info objects, mapped by the aggregation name
 *     Info object should contain the following information
 *     <ul>
 *     <li>name {string} name of the aggregation, singular for 0..1, plural for 0..n
 *     <li>type {string} type of the aggregated controls/elements
 *     <li>multiple {boolean}
 *     <li>singularName {string} singular name for 0..n aggregations
 *     </ul>
 * <li>associations: a map of association info objects, mapped by the association name
 *     Info object should contain the following information
 *     <ul>
 *     <li>name {string} name of the association, singular for 0..1, plural for 0..n
 *     <li>type {string} type of the associated controls/elements
 *     <li>multiple {boolean}
 *     <li>singularName {string} singular name for 0..n associations
 *     </ul>
 * <li>events: map from event names to event names
 * </ul>
 *
 * @see sap.ui.core.Object.defineClass
 *
 * @param {string} sClassName name of the class to build the metadata for
 * @param {object} oStaticInfo static information used to build the metadata
 * @param {function} [fnMetaImpl] constructor to be used for the metadata
 * @return {sap.ui.core.ElementMetadata} the created metadata
 * @static
 * @public
 * @deprecated Since 1.3.1. Use the static <code>extend</code> method of the desired base class (e.g. {@link sap.ui.core.Element.extend})
 */
sap.ui.core.Element.defineClass = function(sClassName, oStaticInfo, fnMetaImpl) {
	// create and attach metadata but with an Element specific implementation
	return sap.ui.base.Object.defineClass(sClassName, oStaticInfo, fnMetaImpl || sap.ui.core.ElementMetadata);
};

/**
 * Handles the given browser event.
 * @private
 */
sap.ui.core.Element.prototype._handleEvent = function (oEvent) {
	var sHandlerName = "on" + oEvent.type;
	this._callEventHandles(this.aBeforeDelegates, sHandlerName, oEvent);
	this._callEventHandles([this], sHandlerName, oEvent);
	this._callEventHandles(this.aDelegates, sHandlerName, oEvent);
};

/**
 * Calls event handler of the given event handles with the given browser event.
 * @private
 */
sap.ui.core.Element.prototype._callEventHandles = function (aHandles, sHandlerName, oEvent) {
	if (aHandles.length > 0) {
		for (var i = 0; i < aHandles.length; i++) {
			var oHandle = aHandles[i];
			if (oHandle[sHandlerName]) {
				oHandle[sHandlerName](oEvent);
			}
		}
	}
};


// Element is granted "friend" access by Core for (de-)registration
/**
 * Registers this instance of sap.ui.core.Element with the Core.
 *
 * The implementation of this method is provided with "friend" access by Core.
 * @see sap.ui.core.Core.constructor
 *
 * @function
 * @name sap.ui.core.Element.prototype.register
 * @private
 */
//sap.ui.core.Element.prototype.register = function() {...}

/**
 * Deregisters this instance of sap.ui.core.Element from the Core.
 *
 * The implementation of this method is provided with "friend" access by Core.
 * @see sap.ui.core.Core.constructor
 *
 * @function
 * @name sap.ui.core.Element.prototype.deregister
 * @private
 */
//sap.ui.core.Element.prototype.deregister = function() {...}

/**
 * Initializes the element instance after creation.
 *
 * Applications must not call this hook method directly, it is called by the framework
 * while the constructor of an element is executed.
 *
 * Subclasses of Element should override this hook to implement any necessary initialization.
 *
 * @function
 * @name sap.ui.core.Element.prototype.init
 * @protected
 */
//sap.ui.core.Element.prototype.init = function() {};

/**
 * Cleans up the element instance before destruction.
 *
 * Applications must not call this hook method directly, it is called by the framework
 * when the element is {@link #destroy destroyed}.
 *
 * Subclasses of Element should override this hook to implement any necessary cleanup.
 *
 * @function
 * @name sap.ui.core.Element.prototype.exit
 * @protected
 */
//sap.ui.core.Element.prototype.exit = function() {};

/**
 * Creates a new Element from the given data.
 *
 * If vData is an element already, that element is returned.
 * If vData is an object (literal), then a new element is created with vData as settings.
 * The type of the element is either determined by a "Type" entry in the vData or
 * by a type information in the oKeyInfo object
 * @param {sap.ui.core.Element|object} vData the data to create the element from
 * @param {object} oKeyInfo
 * @public
 * @static
 */
sap.ui.core.Element.create = function(vData, oKeyInfo) {
	if ( !vData || vData instanceof sap.ui.core.Element || typeof vData !== "object" || vData instanceof String) {
		return vData;
	}

	function getClass(vType) {
		if ( typeof vType === "function" ) {
			return vType;
		} 
		if (typeof vType === "string" ) {
			return jQuery.sap.getObject(vType);
		}
	}

	var fnClass = getClass(vData.Type) || getClass(oKeyInfo && oKeyInfo.type);
	if ( typeof fnClass === "function" ) {
		return new fnClass(vData);
	}

	// we don't know how to create the Element from vData, so fail
	// extension points could be integrated here
	var message = "Don't know how to create an Element from " + vData + " (" + (typeof vData) + ")";
	jQuery.sap.log.fatal(message);
	throw new Error(message);
};

/**
 * A global preprocessor for the ID of an Element (used internally).
 * If set, this function will be called before the ID is applied to any Element.
 * If the original ID was empty, the hook will not be called (to be discussed).
 *
 * The expected signature is <code>function(sId)</code>, and <code>this</code> will
 * be the current Element.
 *
 * @return new ID of the Element
 * @type function
 * @private
 */
sap.ui.core.Element._fnIdPreprocessor = null;

/**
 * A global preprocessor for the settings of an Element (used internally).
 * If set, this function will be called before the settings are applied to any Element.
 * If the original settings are empty, the hook will not be called (to be discussed).
 *
 * The expected signature is <code>function(mSettings)</code>, and <code>this</code> will
 * be the current Element.
 *
 * @type function
 * @private
 */
sap.ui.core.Element._fnSettingsPreprocessor = null;

sap.ui.core.Element.runWithPreprocessors = function(fn, oPreprocessors) {
	jQuery.sap.assert(typeof fn === "function", "fn must be a function");
	jQuery.sap.assert(!oPreprocessors || typeof oPreprocessors === "object", "oPreprocessors must be an object");
	
	var oOldPreprocessors = { id : this._fnIdPreprocessor, settings : this._fnSettingsPreprocessor };
	oPreprocessors = oPreprocessors || {};

	this._fnIdPreprocessor = oPreprocessors.id; 
	this._fnSettingsPreprocessor = oPreprocessors.settings;
	
	try {
		var result = fn.call();
		this._fnIdPreprocessor = oOldPreprocessors.id; 
		this._fnSettingsPreprocessor = oOldPreprocessors.settings;
		return result;
	} catch (e) {
		this._fnIdPreprocessor = oOldPreprocessors.id; 
		this._fnSettingsPreprocessor = oOldPreprocessors.settings;
		throw e;
	}
	
};

/**
 * Sets all the properties, aggregations, associations and event handlers as given in
 * the object literal <code>mSettings</code>. If a property, aggregation, etc.
 * is not listed in <code>mSettings</code>, then its value is not changed by this method.
 *
 * For properties and 0..1 aggregations/associations, any given setting overwrites
 * the current value. For 0..n aggregations, the given values are appended; event
 * listeners are registered in addition to existing ones.
 *
 * For the possible keys and values in <code>mSettings</code> see the general
 * documentation in {@link sap.ui.core.Element} or the specific documentation
 * of the constructor of the concrete UI element class.
 *
 * @param {object} mSettings the settings to apply to this element
 * @return {sap.ui.core.Element} Returns <code>this</code> to allow method chaining
 * @public
 */
sap.ui.core.Element.prototype.applySettings = function(mSettings) {

	// PERFOPT: don't retrieve (expensive) JSONKeys if no settings are given
	if ( !mSettings || jQuery.isEmptyObject(mSettings) ) {
		return this;
	}

	var oMetadata = this.getMetadata(),
		mValidKeys = oMetadata.getJSONKeys(),
		makeControl = sap.ui.core.Element.create,
		preprocessor = sap.ui.core.Element._fnSettingsPreprocessor,
		sKey, oValue, oKeyInfo;

	// call the preprocessor if it has been defined
	preprocessor && preprocessor.call(this, mSettings); // TODO: decide whether to call for empty settings as well?

	// process all settings
	// process settings
	for(sKey in mSettings) {
		// get info object for the key
		if ( oKeyInfo = mValidKeys[sKey] ) {
			oValue = mSettings[sKey];
			switch(oKeyInfo._iKind) {
			case 0: // PROPERTY
				if (this.isBinding(oValue, oKeyInfo)) {
					var oBindingInfo = this.getBindingInfo(oValue);
					this.bindProperty(sKey, oBindingInfo.path, oBindingInfo.type || oBindingInfo.formatter);
				} else {
					this[oKeyInfo._sMutator](oValue);
				}
				break;
			case 1: // SINGLE_AGGREGATION
				if ( oKeyInfo.altTypes && this.isBinding(oValue, oKeyInfo) ) {
					var oBindingInfo = this.getBindingInfo(oValue);
					this.bindProperty(sKey, oBindingInfo.path, oBindingInfo.type || oBindingInfo.formatter);
				} else {
					this[oKeyInfo._sMutator](makeControl(oValue, oKeyInfo));
				}
				break;
			case 2: // MULTIPLE_AGGREGATION
				if (this.isBinding(oValue, oKeyInfo)) {
					var oBindingInfo = this.getBindingInfo(oValue);
					this.bindAggregation(sKey, oBindingInfo.path, oBindingInfo.template, oBindingInfo.sorter, oBindingInfo.filters);
				} else {
					if ( oValue && !jQuery.isArray(oValue) ) {
						oValue = [oValue];
					}
					if ( oValue ) {
						for(var i=0,l=oValue.length; i<l; i++) {
							this[oKeyInfo._sMutator](makeControl(oValue[i], oKeyInfo));
						}
					}
				}
				break;
			case 3: // SINGLE_ASSOCIATION
				this[oKeyInfo._sMutator](oValue);
				break;
			case 4: // MULTIPLE_ASSOCIATION
				if ( oValue && !jQuery.isArray(oValue) ) {
					oValue = [oValue];
				}
				if ( oValue ) {
					for(var i=0,l=oValue.length; i<l; i++) {
						this[oKeyInfo._sMutator](oValue[i]);
					}
				}
				break;
			case 5: // EVENT
				if ( typeof oValue == "function" ) {
					this[oKeyInfo._sMutator](oValue);
				}
				else {
					this[oKeyInfo._sMutator](oValue[0], oValue[1], oValue[2]);
				}
					//this[oKeyInfo._sMutator].apply(this, oValue); // could be replacement for line before
				break;
			default:
				break;
			}
		}
	}

	return this;
};

/**
 * Returns a simple string representation of this element.
 *
 * Mainly useful for tracing purposes.
 * @public
 * @return {string} a string descripition of this element
 */
sap.ui.core.Element.prototype.toString = function() {
	if ( this.getMetadata ) {
		return "Element " + this.getMetadata().getName() + "#" + this.sId;
	}
	else {
		return "Element {unknown class}#" + this.sId;
	}
};

/**
 * Returns the element's Id.
 *
 * @return {string} the element's Id.
 * @public
 */
sap.ui.core.Element.prototype.getId = function() {
	return this.sId;
};

/**
 * Returns the best suitable DOM node that represents this Element.
 * By default the DOM node with the same ID as this Element is returned.
 * Subclasses should override this method if the lookup via id is not sufficient.
 *
 * Note that such a DOM node does not necessarily exist in all cases.
 * Some elements or controls might not have a DOM representation at all (e.g.
 * a naive FlowLayout) while others might not have one due to their current
 * state (e.g. an initial, not yet rendered control).
 *
 * @return {DOMNode} The element's DOM reference or null
 * @protected
 */
sap.ui.core.Element.prototype.getDomRef = function() {
	return jQuery.sap.domById(this.getId());
};

/**
 * Returns the best suitable DOM node that represents this Element wrapped as jQuery object.
 * I.e. the element returned by {@link sap.ui.core.Element#getDomRef} is wrapped and returned.
 *
 * @return {jQuery} The jQuery wrapped element's DOM reference
 * @protected
 */

sap.ui.core.Element.prototype.$ = function() {
	return jQuery(this.getDomRef());
};

/**
 * Checks whether this element has an active parent.
 *
 * @type boolean
 * @return true if this element has an active parent
 * @private
 */
sap.ui.core.Element.prototype.isActive = function() {
	return this.oParent && this.oParent.isActive();
};

/**
 * This function either calls set[sPropertyName] or get[sPropertyName] with the specified property name
 * depending if an <code>oValue</code> is provided or not.
 *
 * @param {string}  sPropertyName name of the property to set
 * @param {any}     [oValue] value to set the property to
 * @return {any|sap.ui.core.Element} Returns <code>this</code> to allow method chaining in case of setter and the property value in case of getter
 * @public
 */
sap.ui.core.Element.prototype.prop = function(sPropertyName, oValue) {

	var oPropertyInfo = this.getMetadata().getJSONKeys()[sPropertyName];
	if (oPropertyInfo) {
		if (arguments.length == 1) {
			// getter
			return this[oPropertyInfo._sGetter]();
		} else {
			// setter
			this[oPropertyInfo._sMutator](oValue);
			return this;
		}
	}
};

/**
 * Sets a new value for the given property <code>sPropertyName</code> and marks
 * this UI element for redraw. If the given <code>oValue</code> equals the
 * current value, nothing happens.
 *
 * @param {string}  sPropertyName name of the property to set
 * @param {any}     oValue value to set the property to
 * @param {boolean} [bSuppressInvalidate] if true, the UI element is not marked for redraw
 * @return {sap.ui.core.Element} Returns <code>this</code> to allow method chaining
 * TODO better name bSuppressInvalidate positive, e.g. "bStayValid"
 * @protected
 */
sap.ui.core.Element.prototype.setProperty = function(sPropertyName, oValue, bSuppressInvalidate) {

	// check for a value change
	var oOldValue = this.mProperties[sPropertyName];

	if (oOldValue === oValue) {
		return this;
	} // no change

	// set suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate++;
	}



	// value validation
	oValue = this.validateProperty(sPropertyName, oValue);

	// change the property (and invalidate if the rendering should be updated)
	this.mProperties[sPropertyName] = oValue;
	if (!this.isInvalidateSuppressed()) {
		this.invalidate();
	}

	// check whether property is bound and update model in case of two way binding
	this.updateModelProperty(sPropertyName, oValue, oOldValue);

	// prototype for generic property change events
	// TODO: THINK ABOUT CONFIGURATION TO ENABLE THIS
	sap.ui.base.EventProvider.prototype.fireEvent.apply(this, ["_change", {
		"id": this.getId(),
		"name": sPropertyName,
		"oldValue": oOldValue,
		"newValue": oValue
	}]);

	// reset suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate--;
	}

	return this;
};

/**
 * Returns the value for the property with the given <code>sPropertyName</code>
 *
 * @param {string} sPropertyName the name of the property
 * @type any
 * @return the value of the property
 * @protected
 */
sap.ui.core.Element.prototype.getProperty = function(sPropertyName) {
	var oValue = this.mProperties[sPropertyName];
	return (oValue instanceof String) ? oValue.valueOf() : oValue;
};

/**
 * Checks whether the given value is of the proper type for the given property name. In case null or undefined is
 * passed, the default value for this property is returned.
 *
 * @param {string} sPropertyName the name of the property
 * @param {any} oValue the value
 * @return {any} the passed value or the property's default value if null or undefined was passed
 * @throws Error if no property with the given name is found or the given value does not fit to the property type
 * @protected
 */
sap.ui.core.Element.prototype.validateProperty = function(sPropertyName, oValue) {
	var oMetadata = this.getMetadata(),
		oProperty = oMetadata.getAllProperties()[sPropertyName],
		oType;

	if (!oProperty) {
		throw new Error("Property \"" + sPropertyName + "\" does not exist in " + this);
	}

	oType = sap.ui.base.DataType.getType(oProperty.type);

	// In case null is passed as the value return the default value, either from the property or from the type
	if (oValue === null || oValue === undefined) {
		if (oProperty.defaultValue !== null) {
			return oProperty.defaultValue;
		} else {
			return oType.getDefaultValue();
		}
	}

	// Implicit casting for string only, other types are causing errors
	if (oType instanceof sap.ui.base.DataType) {
		if (oType.getName() == "string") {
			if (!(typeof oValue == "string" || oValue instanceof String)) {
				oValue = "" + oValue;
			}
		} else if (oType.getName() == "string[]") {
			for (var i = 0; i < oValue.length; i++) {
				if (!typeof oValue[i] == "string") {
					oValue[i] = "" + oValue[i];
				}
			}
		} else if (!oType.isValid(oValue)) {
			throw new Error("\"" + oValue + "\" is of type " + typeof oValue + ", expected " +
					oType.getName() + " for property \"" + sPropertyName + "\" of " + this);
		}
	} else if (!(oValue in oType)){ // Enumeration
		throw new Error("\"" + oValue + "\" is not a valid entry of the enumeration for property \"" + sPropertyName + "\" of " + this);
	}

	return oValue;
};

/**
 * Checks whether the given value is of the proper type for the given aggregation name. 
 *
 * @param {string} sAggregationName the name of the aggregation
 * @param {sap.ui.core.Element|any} oElement the aggregated element or a primitive value
 * @param {boolean} bMultiple whether the aggregation must have cardinality 0..n
 * @return {sap.ui.core.Element|any} the passed object
 * @throws Error if no aggregation with the given name is found or the given value does not fit to the aggregation type
 * @protected
 */
sap.ui.core.Element.prototype.validateAggregation = function(sAggregationName, oElement, bMultiple) {
	var oMetadata = this.getMetadata(),
		oAggregation = oMetadata.getAllAggregations()[sAggregationName],
		aAltTypes,
		oType,
		i;

	// undeclared aggregation 
	if (!oAggregation) {
		if(sAggregationName && oMetadata._mHiddenAggregations && oMetadata._mHiddenAggregations[sAggregationName]){
			oAggregation = oMetadata._mHiddenAggregations[sAggregationName];
		}else{
			throw new Error("Aggregation \"" + sAggregationName + "\" does not exist in " + this);
		}
	}

	// TODO should this be part of the validation (raise an error) or not?
	jQuery.sap.assert(oAggregation.multiple === bMultiple, "Aggregation '" + sAggregationName + "' of " + this + " used with wrong cardinality (declared as " + (oAggregation.multiple ? "0..n" : "0..1") + ")");
	
	oType = jQuery.sap.getObject(oAggregation.type);
	// class types
	if ( typeof oType === "function" && oElement instanceof oType ) {
		return oElement;
	}
	// interfaces 
	if ( oElement && oElement.getMetadata && oElement.getMetadata().isInstanceOf(oAggregation.type) ) {
		return oElement;
	}
	// alternative types
	aAltTypes = oAggregation.altTypes;
	if ( aAltTypes && aAltTypes.length ) {
		// for primitive types, null or undefined is valid as well 
		if ( oElement == null ) {
			return oElement;
		}
		for (i=0; i<aAltTypes.length; i++) {
			oType = sap.ui.base.DataType.getType(aAltTypes[i]);
			if (oType instanceof sap.ui.base.DataType) {
				if (oType.isValid(oElement)) {
					return oElement;
				}
			} else if (oElement in oType) { // Enumeration
				return oElement;
			}
		}
	}
	throw new Error("\"" + oElement + "\" is not valid for aggregation \"" + sAggregationName + "\" of " + this);
}

/**
 * Returns the origin info on the property value of the given property name
 *
 * @param {string} sPropertyName the name of the property
 * @return {object} a map of properties describing the origin of this property value or null
 * @public
 */
sap.ui.core.Element.prototype.getOriginInfo = function(sPropertyName) {
	var oValue = this.mProperties[sPropertyName];
	if (!(oValue instanceof String && oValue.originInfo)) {
		return null;
	}
	return oValue.originInfo;
};


// ######################################################################################################
// Associations
// ######################################################################################################

/**
 * Sets an association for the control
 *
 * @param {string}
 *            sAssociationName name of the association
 * @param {string | sap.ui.core.Element}
 *            sId the ID of the control that is set as an association, or the control itself
 * @param {boolean}
 *            [bSuppressInvalidate] if true, the UI element is not marked for redraw
 * @return {sap.ui.core.Element} Returns <code>this</code> to allow method chaining
 * @protected
 */
sap.ui.core.Element.prototype.setAssociation = function(sAssociationName, sId, bSuppressInvalidate) {
	if (sId != null && typeof(sId) != "string") {
		sId = sId.getId();
	} // oElement -> sId
	if (this.mAssociations[sAssociationName] == sId) {
		return this;
	} // no change

	// set suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate++;
	}

	this.mAssociations[sAssociationName] = sId;
	if (!this.isInvalidateSuppressed()) {
		this.invalidate();
	}

	// reset suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate--;
	}

	return this;
};

/**
 * Returns an association of the control with a given sAssociationName
 *
 * @param {string} sAssociationName the name of the association
 * @param {sap.ui.core.Element | Array}
 *			  oDefaultForCreation the object that is used in case the current aggregation is empty
 * @type sap.ui.core.Element
 * @return {string | string[]} the ID of the associated control or an array of such IDs; may be null if the association has not been populated
 * @protected
 */
sap.ui.core.Element.prototype.getAssociation = function(sAssociationName, oDefaultForCreation) {
	var result = this.mAssociations[sAssociationName];

	if (!result) {
		result = this.mAssociations[sAssociationName] = oDefaultForCreation || null;
	} else {
		if (typeof result.length === 'number' && !(result.propertyIsEnumerable('length')) ) {
			// Return a copy of the array instead of the array itself as reference!!
			return result.slice();
		}
		// simple type or Element
		return result;
	}

	return result;
};

/**
 * Adds some entity with the ID <code>sId</code> to the association identified by <code>sAssociationName</code>.
 *
 * @param {string}
 *            sAssociationName the string identifying the association the element should be added to.
 * @param {string | sap.ui.core.Element}
 *            sId the ID of the element to add; if empty, nothing is added; if a <code>sap.ui.core.Element</code> is given, its ID is added
 * @param {boolean}
 *            [bSuppressInvalidate] if true, the UI element as well as the newly associated element is not marked for redraw
 * @return {sap.ui.core.Element} Returns <code>this</code> to allow method chaining
 * @protected
 */
sap.ui.core.Element.prototype.addAssociation = function(sAssociationName, sId, bSuppressInvalidate) {
	if (!sId) {
		return this;
	}

	if (sId !== null && typeof(sId) != "string") {
		sId = sId.getId();
	} // oElement -> sId

	// set suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate++;
	}

	var aIds = this.mAssociations[sAssociationName];
	if (!aIds) {
		aIds = this.mAssociations[sAssociationName] = [sId];
	} else {
		aIds.push(sId);
	}

	if (!this.isInvalidateSuppressed()) {
		this.invalidate();
	}

	// reset suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate--;
	}

	return this;
};

/**
 * Removes an Element from the association named <code>sAssociationName</code>.
 *
 * @param {string}
 *            sAssociationName the string identifying the association the Element should be removed from.
 * @param {int | string | sap.ui.core.Element}
 *            vElement the position or ID of the Element to remove or the Element itself; if <code>vElement</code> is invalid input,
 *            a negative value or a value greater or equal than the current size of the association, nothing is removed
 * @param {boolean}
 *            [bSuppressInvalidate] if true, the UI element is not marked for redraw
 * @return the ID of the removed Element or null
 * @protected
 */
sap.ui.core.Element.prototype.removeAssociation = function(sAssociationName, vElement, bSuppressInvalidate) {
	var aIds = this.mAssociations[sAssociationName];
	var sId = null;

	// set suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate++;
	}

	if (typeof(vElement) == "object" && vElement.getId) { // element itself is given
		vElement = vElement.getId();
	}

	if (typeof(vElement) == "string") { // ID of the element is given or has just been retrieved
		for (var i = 0; i < aIds.length; i++) {
			if (aIds[i] == vElement) {
				vElement = i;
				break;
			}
		}
	}

	if (typeof(vElement) == "number") { // "element" is the index now
		if (vElement < 0 || vElement >= aIds.length) {
			jQuery.sap.log.warning("Element.removeAssociation called with invalid index: " + sAssociationName + ", " + vElement);
		} else {
			sId = aIds[vElement];
			aIds.splice(vElement, 1);
			if (!this.isInvalidateSuppressed()) {
				this.invalidate();
			}
		}
	}

	// reset suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate--;
	}

	return sId;
};

/**
 * Removes all the controls in the 0..n-association named <code>sAssociationName</code> (and returns them in an array).<br/>
 *
 * @param {string}
 *            sAssociationName the name of the association
 * @param {boolean}
 *            [bSuppressInvalidate] if true, the UI element is not marked for redraw
 * @type Array
 * @return an array with the IDs of the removed elements (might be empty)
 * @protected
 */
sap.ui.core.Element.prototype.removeAllAssociation = function(sAssociationName, bSuppressInvalidate){
	var aIds = this.mAssociations[sAssociationName];
	if (!aIds)	{
		return [];
	}

	// set suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate++;
	}

	delete this.mAssociations[sAssociationName];
	if (!this.isInvalidateSuppressed()) {
		this.invalidate();
	}

	// reset suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate--;
	}

	return aIds;
};

// ######################################################################################################
// End of Associations
// ######################################################################################################


// ######################################################################################################
// Aggregations
// ######################################################################################################
/**
 * Sets an aggregation for the control
 *
 * @param {string}
 *            sAggregationName name of the aggregation
 * @param {object}
 *            oElement the control that is set as an aggregation
 * @param {boolean}
 *            [bSuppressInvalidate] if true, the UI element is not marked for redraw
 * @return {sap.ui.core.Element} Returns <code>this</code> to allow method chaining
 * @protected
 */
sap.ui.core.Element.prototype.setAggregation = function(sAggregationName, oElement, bSuppressInvalidate) {
	var oOldChild = this.mAggregations[sAggregationName];
	if (oOldChild === oElement) {
		return this;
	} // no change
	// starting with 1.6: oelement = this.validateAggregation(sAggregationName, oElement, /* multiple */ true)
	jQuery.sap.assert.apply(jQuery.sap, (function(that) { 
		try { 
			that.validateAggregation(sAggregationName, oElement, /* multiple */ false); 
			return [true]; 
		} catch (e) { 
			return [false, e.message]; 
		}
	}(this)));

	// set suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate++;
	}

	if (oOldChild instanceof sap.ui.core.Element) { // remove old child
		oOldChild.setParent(null);
	}
	this.mAggregations[sAggregationName] = oElement;
	if (oElement instanceof sap.ui.core.Element) { // adopt new child
		oElement.setParent(this, sAggregationName, bSuppressInvalidate);
	} else {
		if (!this.isInvalidateSuppressed()) {
			this.invalidate();
		}
	}

	// reset suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate--;
	}

	return this;
};

/**
 * Returns an aggregation of the control with a given sAggregationName
 *
 * @param {string}
 *            sAggregationName the name of the aggregation
 * @param {sap.ui.core.Element | Array}
 *			  oDefaultForCreation the object that is used in case the current aggregation is empty
 * @type sap.ui.core.Element|Array
 * @return the aggregation array in case of 0..n-aggregations or the control or null in case of 0..1-aggregations
 * @protected
 */
sap.ui.core.Element.prototype.getAggregation = function(sAggregationName, oDefaultForCreation) {
	var aChildren = this.mAggregations[sAggregationName];
	if (!aChildren) {
		aChildren = this.mAggregations[sAggregationName] = oDefaultForCreation || null;
	}
	if (aChildren) {
		if (typeof aChildren.length === 'number' && !(aChildren.propertyIsEnumerable('length')) ) {
			// Return a copy of the array instead of the array itself as reference!!
			return aChildren.slice();
		}
		// simple type or Element
		return aChildren;
	} else {
		return null;
	}
};

/**
 * Checks for the provided control <code>oElement</code> in the aggregation
 * named <code>sAggregationName</code> and returns its index if found, or -1
 * otherwise. Returns -2 if the given named aggregation is not a multiple one
 * (and does not contain the given child).
 *
 * @param {string}
 *            sAggregationName the name of the aggregation
 * @param {sap.ui.core.Element}
 *            oElement the Control whose index is looked for.
 * @return {int} the index of the provided control in the aggregation.
 * @protected
 */
sap.ui.core.Element.prototype.indexOfAggregation = function(sAggregationName, oElement) {
	var aChildren = this.mAggregations[sAggregationName];
	if (aChildren) {
		if (aChildren.length == undefined) {
			return -2;
		} // not a multiple aggregation

		for (var i = 0; i < aChildren.length; i++) {
			if (aChildren[i] == oElement) {
				return i;
			}
		}
	}
	return -1;
};

/**
 * Inserts control <code>oElement</code> to the aggregation named <code>sAggregationName</code> at
 * position <code>iIndex</code>.
 *
 * @param {string}
 *            sAggregationName the string identifying the aggregation the control <code>oElement</code>
 *            should be inserted into.
 * @param {sap.ui.core.Element}
 *            oElement the element to add; if empty, nothing is inserted.
 * @param {int}
 *            iIndex the <code>0</code>-based index the control should be inserted at; for a negative
 *            value <code>iIndex</code>, <code>oElement</code> is inserted at position 0; for a value
 *            greater than the current size of the aggregation, <code>oElement</code> is inserted at
 *            the last position
 * @param {boolean}
 *            [bSuppressInvalidate] if true, the UI element as well as the added child is not marked for redraw
 * @return {sap.ui.core.Element} Returns <code>this</code> to allow method chaining
 * @protected
 */
sap.ui.core.Element.prototype.insertAggregation = function(sAggregationName, oElement, iIndex, bSuppressInvalidate) {
	if (!oElement) {
		return this;
	}
	// starting with 1.6: oElement = this.validateAggregation(sAggregationName, oElement, /* multiple */ true)
	jQuery.sap.assert.apply(jQuery.sap, (function(that) { 
		try { 
			that.validateAggregation(sAggregationName, oElement, /* multiple */ true); 
			return [true]; 
		} catch (e) { 
			return [false, e.message]; 
		}
	}(this)));

	var aChildren = this.mAggregations[sAggregationName] || (this.mAggregations[sAggregationName] = []);
	// force index into valid range 
	var i = iIndex < 0 ? 0 : (iIndex > aChildren.length ? aChildren.length : iIndex);
	if (i !== iIndex) {
		jQuery.sap.log.warning("Element.insertAggregation: index '" + iIndex + "' out of range [0," + aChildren.length + "], forced to " + i);
	}
	aChildren.splice(i, 0, oElement);
	oElement.setParent(this, sAggregationName, bSuppressInvalidate);

	return this;
};

/**
 * Adds some entity <code>oElement</code> to the aggregation identified by <code>sAggregationName</code>.
 *
 * @param {string}
 *            sAggregationName the string identifying the aggregation the element <code>oElement</code> should be added to.
 * @param {sap.ui.core.Element}
 *            oElement the element to add; if empty, nothing is added
 * @param {boolean}
 *            [bSuppressInvalidate] if true, the UI element as well as the added child is not marked for redraw
 * @return {sap.ui.core.Element} Returns <code>this</code> to allow method chaining
 * @protected
 */
sap.ui.core.Element.prototype.addAggregation = function(sAggregationName, oElement, bSuppressInvalidate) {
	if (!oElement) {
		return this;
	}
	// starting with 1.6: oElement = this.validateAggregation(sAggregationName, oElement, /* multiple */ true)
	jQuery.sap.assert.apply(jQuery.sap, (function(that) { 
		try { 
			that.validateAggregation(sAggregationName, oElement, /* multiple */ true); 
			return [true]; 
		} catch (e) { 
			return [false, e.message]; 
		}
	}(this)));

	var aChildren = this.mAggregations[sAggregationName];
	if (!aChildren) {
		aChildren = this.mAggregations[sAggregationName] = [oElement];
	} else {
		aChildren.push(oElement);
	}
	oElement.setParent(this, sAggregationName, bSuppressInvalidate);

	return this;
};

/**
 * Removes an element from the aggregation named <code>sAggregationName</code>.
 *
 * @param {string}
 *            sAggregationName the string identifying the aggregation the Element should be removed from
 * @param {int | string | sap.ui.core.Element}
 *            vElement the position or ID of the Element to remove or the Element itself; if <code>vElement</code> is invalid,
 *            a negative value or a value greater or equal than the current size of the aggregation, nothing is removed
 * @param {boolean}
 *            [bSuppressInvalidate] if true, the UI element is not marked for redraw
 * @type sap.ui.core.Element
 * @return the removed element or null
 * @protected
 */
sap.ui.core.Element.prototype.removeAggregation = function(sAggregationName, vElement, bSuppressInvalidate) {
	var aChildren = this.mAggregations[sAggregationName];
	var oChildControl = null;

	// set suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate++;
	}

	if (typeof(vElement) == "string") { // ID of the element is given
		vElement = sap.ui.getCore().byId(vElement);
	}

	if (typeof(vElement) == "object") { // the element itself is given or has just been retrieved
		for (var i = 0; i < aChildren.length; i++) {
			if (aChildren[i] == vElement) {
				vElement = i;
				break;
			}
		}
	}

	if (typeof(vElement) == "number") { // "vElement" is the index now
		if (vElement < 0 || vElement >= aChildren.length) {
			jQuery.sap.log.warning("Element.removeAggregation called with invalid index: " + sAggregationName + ", " + vElement);

		} else {
			oChildControl = aChildren[vElement];
			aChildren.splice(vElement, 1);
			oChildControl.setParent(null);
			if (!this.isInvalidateSuppressed()) {
				this.invalidate();
			}
		}
	}

	// reset suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate--;
	}

	return oChildControl;
};

/**
 * Removes all the controls in the 0..n-aggregation named <code>sAggregationName</code> (and returns them in an array).<br/>
 * Additionally unregisters them from the hosting UIArea.
 *
 * @param {string}
 *            sAggregationName the name of the aggregation
 * @param {boolean}
 *            [bSuppressInvalidate] if true, the UI element is not marked for redraw
 * @type Array
 * @return an array of the removed elements (might be empty)
 * @protected
 */
sap.ui.core.Element.prototype.removeAllAggregation = function(sAggregationName, bSuppressInvalidate){
	var aChildren = this.mAggregations[sAggregationName];
	if (!aChildren)	{
		return [];
	}

	// set suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate++;
	}

	delete this.mAggregations[sAggregationName];
	for (var i = 0; i < aChildren.length; i++) {
		aChildren[i].setParent(null);
	}
	if (!this.isInvalidateSuppressed()) {
		this.invalidate();
	}

	// reset suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate--;
	}

	return aChildren;
};

/**
 * Destroys (all) the control(s) in the aggregation named <code>sAggregationName</code> and afterwards empties the
 * aggregation.
 *
 * @param {string}
 *            sAggregationName the name of the aggregation
 * @param {boolean}
 *            [bSuppressInvalidate] if true, the UI element is not marked for redraw
 * @return {sap.ui.core.Element} Returns <code>this</code> to allow method chaining
 * @protected
 */
sap.ui.core.Element.prototype.destroyAggregation = function(sAggregationName, bSuppressInvalidate){
	var aChildren = this.mAggregations[sAggregationName];
	if (!aChildren) {
		return this;
	}

	// set suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate++;
	}

	delete this.mAggregations[sAggregationName];
	if (aChildren instanceof sap.ui.core.Element) {
		aChildren.destroy(bSuppressInvalidate);
	} else if (aChildren && jQuery.isArray(aChildren)) {
		for (var i = 0; i < aChildren.length; i++) {
			if (aChildren[i]) {
				aChildren[i].destroy(bSuppressInvalidate);
			}
		}
	}
	if (!this.isInvalidateSuppressed()) {
		this.invalidate();
	}

	// reset suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate--;
	}

	return this;
};

// ######################################################################################################
// End of Aggregations
// ######################################################################################################



/**
 * Getter for aggregation <code>customData</code>.<br/>
 *
 * @return {sap.ui.core.CustomData[]}
 * @public
 */
sap.ui.core.Element.prototype.getCustomData = function() {
	return this.getAggregation("customData", []);
};

/**
 * Inserts a CustomData element into the aggregation named <code>customData</code>.
 *
 * @param {sap.ui.core.CustomData}
 *          oCustomData the customData to insert; if empty, nothing is inserted
 * @param {int}
 *             iIndex the <code>0</code>-based index the customData should be inserted at; for
 *             a negative value of <code>iIndex</code>, the customData is inserted at position 0; for a value
 *             greater than the current size of the aggregation, the customData is inserted at
 *             the last position
 * @return {sap.ui.core.Element} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.core.Element.prototype.insertCustomData = function(oCustomData, iIndex) {
	this.insertAggregation("customData", oCustomData, iIndex);
	return this;
};

/**
 * Adds some customData element <code>oCustomData</code>
 * to the aggregation named <code>customData</code>.
 *
 * @param {sap.ui.core.CustomData}
 *            oCustomData the customData to add; if empty, nothing is inserted
 * @return {sap.ui.core.Element} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.core.Element.prototype.addCustomData = function(oCustomData) {
	this.addAggregation("customData", oCustomData);
	return this;
};

/**
 * Removes a CustomData element from the aggregation named <code>customData</code>.
 *
 * @param {int | string | sap.ui.core.CustomData} vCustomData the customData to remove or its index or id
 * @return {sap.ui.core.CustomData} the removed customData element or null
 * @public
 */
sap.ui.core.Element.prototype.removeCustomData = function(vCustomData) {
	return this.removeAggregation("customData", vCustomData);
};

/**
 * Removes all the data elements in the aggregation named <code>customData</code>.<br/>
 *
 * @return {sap.ui.core.CustomData[]} an array of the removed data elements (might be empty)
 * @public
 */
sap.ui.core.Element.prototype.removeAllCustomData = function() {
	return this.removeAllAggregation("customData");
};

/**
 * Checks for the provided <code>sap.ui.core.CustomData</code> in the aggregation named <code>customData</code>
 * and returns its index if found or -1 otherwise.
 *
 * @param {sap.ui.core.CustomData}
 *            oCustomData the customData whose index is looked for.
 * @return {int} the index of the provided customData element in the aggregation if found, or -1 otherwise
 * @public
 */
sap.ui.core.Element.prototype.indexOfCustomData = function(oCustomData) {
	return this.indexOfAggregation("customData", oCustomData);
};


/**
 * Destroys all the customData elements in the aggregation
 * named <code>customData</code>.
 * @return {sap.ui.core.Element} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.core.Element.prototype.destroyCustomData = function() {
	this.destroyAggregation("customData");
	return this;
};



/// cyclic dependency
//jQuery.sap.require("sap.ui.core.TooltipBase"); /// cyclic dependency

/**
 * This triggers rerendering of itself and its children.<br/> As <code>sap.ui.core.Element</code> "bubbles up" the
 * invalidate, changes to child-<code>Elements</code> will also result in rerendering of the whole sub tree.
 * @protected
 */
sap.ui.core.Element.prototype.invalidate = function() {
	var oParent = this.getParent();
	if (oParent) {
		oParent.invalidate(this);
	}
};

/**
 * This triggers immediate rerendering of its parent and thus of itself and its children.<br/> As <code>sap.ui.core.Element</code> "bubbles up" the
 * rerender, changes to child-<code>Elements</code> will also result in immediate rerendering of the whole sub tree.
 * @protected
 */
sap.ui.core.Element.prototype.rerender = function() {
	var oParent = this.getParent();
	if (oParent) {
		oParent.rerender();
	}
};

/**
 * Returns whether rerendering is currently suppressed on this Element
 * @return boolean
 * @protected
 */
sap.ui.core.Element.prototype.isInvalidateSuppressed = function() {
	var oParent = this.getParent(),
		bInvalidateSuppressed = this.iSuppressInvalidate > 0;
	if (oParent && oParent instanceof sap.ui.core.Element) {
		bInvalidateSuppressed = bInvalidateSuppressed || oParent.isInvalidateSuppressed();
	}
	return bInvalidateSuppressed;
};


/**
 * Removes the given child from this element's named aggregation.
 * @see sap.ui.core.UIArea#_removeChild
 * @see sap.ui.core.Element#setParent
 *
 * @param {sap.ui.core.Element}
 *            oChild the child element to be removed
 * @param {string}
 *            sAggregationName the name of this element's aggregation
 * @param {boolean}
 *            [bSuppressInvalidate] if true, the UI element is not marked for redraw
 * @protected
 */
sap.ui.core.Element.prototype._removeChild = function(oChild, sAggregationName, bSuppressInvalidate) {
	if (!sAggregationName) {
		// an aggregation name has to be specified!
		jQuery.sap.log.error("Cannot remove aggregated child without aggregation name.", null, this);
	} else {
		// set suppress invalidate flag
		if (bSuppressInvalidate) {
			this.iSuppressInvalidate++;
		}

		var iIndex = this.indexOfAggregation(sAggregationName, oChild);
		var oAggregationInfo = this.getMetadata().getJSONKeys()[sAggregationName];
		// Note: we assume that this is the given child's parent, i.e. -1 not expected!
		if (iIndex == -2) { // 0..1
			if(this[oAggregationInfo._sMutator]) {
				this[oAggregationInfo._sMutator](null);
			}
			else {
				this.setAggregation(sAggregationName, null, bSuppressInvalidate);
			}
		} else if(iIndex > -1 ) { // 0..n
			if(this[oAggregationInfo._sRemoveMutator]) {
				this[oAggregationInfo._sRemoveMutator](iIndex);
			}
			else {
				this.removeAggregation(sAggregationName, iIndex, bSuppressInvalidate);
			}
		} else {
			// already removed!?
			// this is the unexpected -1
			// TODO: What would be better? Explicit removeCompositeChild callback on subclass?
		}
		if (!this.isInvalidateSuppressed()) {
			this.invalidate();
		}

		// reset suppress invalidate flag
		if (bSuppressInvalidate) {
			this.iSuppressInvalidate--;
		}
	}
};

/**
 * Defines this element's new parent. If no new parent is given, the parent is
 * just reset and we assume that the old parent has removed this child from its
 * aggregation. But if a new parent is given, this child is first removed from
 * its old parent.
 *
 * @param {sap.ui.core.Element}
 *            oParent the element that becomes this element's parent
 * @param {string}
 *            sAggregationName the name of the parent element's aggregation
 * @param {boolean}
 *            [bSuppressInvalidate] if true, the UI element is not marked for redraw. The old parent, however, is marked for redraw.
 * @return {sap.ui.core.Element}
 *            Returns <code>this</code> to allow method chaining
 * @private
 */
sap.ui.core.Element.prototype.setParent = function(oParent, sAggregationName, bSuppressInvalidate) {
	if ( !oParent ) {
		this.oParent = null;
		this.sParentAggregationName = null;
		// Note: no need (and no way how) to invalidate
		return;
	}

	// set suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate++;
	}

	var oOldParent = this.getParent();
	if (oOldParent) { // remove this element from its old parent
		oOldParent._removeChild(this, this.sParentAggregationName);
	}
	// adopt new parent
	this.oParent = oParent;
	this.sParentAggregationName = sAggregationName;

	// update bindings
	if (this.hasModel()) {
		this.updateBindingContext();
		this.updateBindings(true);
	}

	// Only invalidate if the control already is in the HTML and has been initialized (i.e. has a parent)
	if((!this.bPrerendered || this.bPrerendered && oOldParent)) {
		if (!this.isInvalidateSuppressed()) {
			this.invalidate();
		}
	}

	// reset suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate--;
	}

	return this;
};

/**
 * Returns the parent control or <code>null</code> if this element hasn't been added to a parent yet.
 *
 * @return {sap.ui.core.Element} The parent control or <code>null</code>
 * @public
 */
sap.ui.core.Element.prototype.getParent = function() {
	return this.oParent;
};

/**
 * Returns the UI area of this element, if any.
 *
 * @return {sap.ui.core.UIArea} The UI area of this element or null
 * @private
 */
sap.ui.core.Element.prototype.getUIArea = function() {
	var oParent = this.getParent();
	return oParent ? oParent.getUIArea() : null;
};

/**
 * Cleans up the resources associated with this element and all its children.
 *
 * After an element has been destroyed, it can no longer be used in the UI!
 *
 * Applications should call this method if they don't need the element any longer.
 *
 * @param {boolean}
 *            [bSuppressInvalidate] if true, the UI element is not marked for redraw
 * @public
 */
sap.ui.core.Element.prototype.destroy = function(bSuppressInvalidate) {
	var that = this;

	// set suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate++;
	}

	if (this.exit) {
		this.exit();
	}

	// TODO: generic concept for exit hooks?
	if ( this._exitCompositeSupport ) {
		this._exitCompositeSupport();
	}

	// ensure that also our children are destroyed!!
	for(var oAggr in this.mAggregations){
		this.destroyAggregation(oAggr, bSuppressInvalidate);
	}
	this.deregister();

	// remove this child from parent aggregation
	if (this.getParent() && this.sParentAggregationName) {
		this.getParent()._removeChild(this, this.sParentAggregationName, bSuppressInvalidate);
	}

	// Data Binding
	jQuery.each(this.mBindingInfos, function(sName, oBindingInfo) {
		if (oBindingInfo.template) {
			that.unbindAggregation(sName);
		} else {
			that.unbindProperty(sName);
		}
	});

	// reset suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate--;
	}

	// remove this control from DOM, e.g. if there is no parent (e.g. Dialog or already removed control) or this.sParentAggregationName is not properly set
	this.$().remove();
	
	// finally make the element unusable
	this.setParent = function(){
		throw Error("The control with ID "+that.getId()+" was destroyed and cannot be used anymore.");
	};
};

/**
 * Fires the given event and notifies all listeners. Listeners must not change
 * the content of the event.
 *
 * @param {string} sEventId the event id
 * @param {object} mParameters the parameter map
 * @return {sap.ui.core.Element} Returns <code>this</code> to allow method chaining
 * @protected
 */
sap.ui.core.Element.prototype.fireEvent = function(sEventId, mParameters) {
	// TODO 'id' is somewhat redundant to getSource(), but it is commonly used - fade out with next major release?
	mParameters = mParameters || {};
	mParameters.id = mParameters.id || this.getId();
	// 'arguments' is necessary, as the EventProvider.fireEvent signature has more parameters
	return sap.ui.base.EventProvider.prototype.fireEvent.apply(this, arguments);
};

/**
 * Adds a delegate that listens to the events of this element.
 *
 * To avoid double registrations, all registrations of the given delegate are first
 * removed and then the delegate is added.
 * @param {sap.ui.base.EventProvider} oDelegate the delegate object
 * @param {boolean} [bCallBefore] if true, the delegator event listeners are called before the event listeners of the element
 * @return {sap.ui.core.Element} Returns <code>this</code> to allow method chaining
 * @private
 */
sap.ui.core.Element.prototype.addDelegate = function (oDelegate, bCallBefore) {
	this.removeDelegate(oDelegate);
	(bCallBefore ? this.aBeforeDelegates : this.aDelegates).push(oDelegate);
	return this;
};

/**
 * Removes the given delegate from this element.
 *
 * This method will remove all registrations of the given delegate, not only one.
 * @param {sap.ui.base.EventProvider} oDelegate the delegate object
 * @return {sap.ui.core.Element} Returns <code>this</code> to allow method chaining
 * @private
 */
sap.ui.core.Element.prototype.removeDelegate = function (oDelegate) {
	for (var i=0;i<this.aDelegates.length;i++) {
		if (this.aDelegates[i]==oDelegate) {
			this.aDelegates.splice(i,1);
		}
	}
	for (var i=0;i<this.aBeforeDelegates.length;i++) {
		if (this.aBeforeDelegates[i]==oDelegate) {
			this.aBeforeDelegates.splice(i,1);
		}
	}
	return this;
};

/**
 * Returns the dom reference that should get the focus
 * To be overwritten by the specific control method
 * @type DOMNode
 * @return Returns the dom reference that should get the focus
 */
sap.ui.core.Element.prototype.getFocusDomRef = function () {
	return this.getDomRef() || null;
};

/**
 * Sets the focus to the stored focus dom reference
 * @private
 */
sap.ui.core.Element.prototype.focus = function () {
	var oFocusDomRef = this.getFocusDomRef();

	if(oFocusDomRef) {
		try {
			oFocusDomRef.focus();
		} catch (ex) { // IE8 fails on focusing certain elements; IE9+10 and all other current browsers don't fail
			// the element does not exist or is not focusable; there is no information what to focus instead
			var id = oFocusDomRef.id ? " (id: " + oFocusDomRef.id + ")" : " ";
			jQuery.sap.log.warning("DOM element" + id + " in " + this.toString() + " which should be focused cannot be focused: " + ex.message);
		}
	}
};

/**
 * Returns an object representing the serialized focus information
 * To be overwritten by the specific control method
 * @type object
 * @return an object representing the serialized focus information
 * @protected
 */
sap.ui.core.Element.prototype.getFocusInfo = function () {
	return {id:this.getId()};
};

/**
 * Applies the focus info
 * To be overwritten by the specific control method
 * @param {object} oFocusInfo
 * @protected
 */
sap.ui.core.Element.prototype.applyFocusInfo = function (oFocusInfo) {
	this.focus();
	return this;
};


/**
 * Sets a new tooltip for this object. The tooltip can either be a simple string
 * (which in most cases will be rendered as the <code>title</code> attribute of this
 * Element) or an instance of {@link sap.ui.core.TooltipBase}.
 *
 * If a new tooltip is set, any previously set tooltip is deactivated.
 *
 * @param {string|sap.ui.core.TooltipBase} oTooltip.
 * @public
 */
sap.ui.core.Element.prototype.setTooltip = function(oTooltip) {

	var oOldTooltip = this.getTooltip();
	// if the old tooltip was a Tooltip object, remove it as a delegate
	if (oOldTooltip instanceof sap.ui.core.TooltipBase){
		this.removeDelegate(oOldTooltip);
	}
	// if the new tooltip is a Tooltip object, add it as a delegate
	if (oTooltip instanceof sap.ui.core.TooltipBase){
		oTooltip._currentControl = this;
		this.addDelegate(oTooltip);
	}
	this.setAggregation("tooltip", oTooltip);

	return this;
};

/**
 * Returns the tooltip for this element if any or an undefined value.
 * The tooltip can either be a simple string or a subclass of
 * {@link sap.ui.core.TooltipBase}.
 *
 * Callers that are only interested in tooltips of type string (e.g. to render
 * them as a <code>title</code> attribute), should call the convenience method
 * {@link #getTooltip_AsString} instead. If they want to get a tooltip text no
 * matter where it comes from (be it a string tooltip or the text from a TooltipBase
 * instance) then they could call {@link #getTooltip_Text} instead.
 *
 * @return {string|sap.ui.core.TooltipBase} The tooltip for this Element.
 * @public
 */
sap.ui.core.Element.prototype.getTooltip = function() {
	return this.getAggregation("tooltip");
};

/**
 * Returns the tooltip for this element but only if it is a simple string.
 * Otherwise an undefined value is returned.
 *
 * @return {string} string tooltip or undefined
 * @public
 */
sap.ui.core.Element.prototype.getTooltip_AsString = function() {
	var oTooltip = this.getTooltip();
	if (typeof oTooltip === "string" || oTooltip instanceof String ) {
		return oTooltip;
	}
	return undefined;
};

/**
 * Returns the main text for the current tooltip or undefined if there is no such text.
 * If the tooltip is an object derived from sap.ui.core.Tooltip, then the text property
 * of that object is returned. Otherwise the object itself is returned (either a string
 * or undefined or null).
 *
 * @return {string} text of the current tooltip or undefined
 * @public
 */
sap.ui.core.Element.prototype.getTooltip_Text = function() {
	var oTooltip = this.getTooltip();
	if (oTooltip && typeof oTooltip.getText === "function" ) {
		return oTooltip.getText();
	}
	return oTooltip;
};

/**
 * Returns the runtime metadata for this UI element.
 *
 * When using the defineClass method, this function is automatically created and returns
 * a runtime representation of the design time metadata.
 *
 * @function
 * @name sap.ui.core.Element.prototype.getMetadata
 * @return {sap.ui.core.ElementMetadata} runtime metadata
 * @public
 */
// sap.ui.core.Element.prototype.getMetadata = sap.ui.base.Object.ABSTRACT_METHOD;

//data container

(function(){

	/**
	 * Returns the data object with the given key
	 */
	var getDataObject = function(element, key) {
		var aData = element.getAggregation("customData");
		if (aData) {
			for (var i = 0; i < aData.length; i++) {
				if (aData[i].getKey() == key) {
					return aData[i];
				}
			}
		}
		return null;
	};

	/**
	 * Contains the data modification logic
	 */
	var setData = function(element, key, value) {

		// DELETE
		if (value === null) { // delete this property
			var dataObject = getDataObject(element, key);
			if (!dataObject) {
				return;
			}

			var dataCount = element.getAggregation("customData").length;
			if (dataCount == 1) {
				element.destroyAggregation("customData", true); // destroy if there is no other data
			} else {
				element.removeAggregation("customData", dataObject, true);
				dataObject.destroy();
			}

			// ADD or CHANGE
		} else {
			var dataObject = getDataObject(element, key);
			if (dataObject) {
				dataObject.setValue(value);
			} else {
				var dataObject = new sap.ui.core.CustomData({key:key,value:value});
				element.addAggregation("customData", dataObject, true);
			}
		}
	};

	/**
	 * Attaches custom data to an Element or retrieves attached data.
	 *
	 * Usage:
	 *    data("myKey", myData)
	 * attaches myData (which can be any JS data type, e.g. a number, a string, an object, or a function) to this element, under the given key "myKey"
	 *
	 *    data("myKey")
	 * retrieves whatever data has been attached to this Element (using the key "myKey") before
	 *
	 *    data("myKey", null)
	 * removes whatever data has been attached to this Element (using the key "myKey") before
	 *
	 *    data(null)
	 * removes all data
	 *
	 *    data()
	 * returns all data, as a map
	 *
	 * @public
	 */
	sap.ui.core.Element.prototype.data = function() {
		var argLength = arguments.length;

		if (argLength == 0) {                    // return ALL data as a map
			var aData = this.getAggregation("customData"),
				result = {};
			if (aData) {
				for (var i = 0; i < aData.length; i++) {
					result[aData[i].getKey()] = aData[i].getValue();
				}
			}
			return result;

		} else if (argLength == 1) {
			var arg0 = arguments[0];

			if (arg0 === null) {                  // delete ALL data
				this.destroyAggregation("customData", true); // delete whole map
				return this;

			} else if (typeof arg0 == "string") { // return requested data element
				var dataObject = getDataObject(this, arg0);
				return dataObject ? dataObject.getValue() : null;

			} else if (typeof arg0 == "object") { // should be a map - set multiple data elements
				for (var key in arg0) { // TODO: improve performance and avoid executing setData multiple times
					setData(this, key, arg0[key]);
				}
				return this;

			} else {
				// error, illegal argument
				throw new Error("When data() is called with one argument, this argument must be set or null, but is " + arg0 + " (on UI Element with ID '" + this.getId() + "')");
			}

		} else if (argLength == 2) {            // set or remove one data element
			setData(this, arguments[0], arguments[1]);
			return this;

		} else {
			// error, illegal arguments
			throw new Error("data() may only be called with 0-2 arguments (on UI Element with ID '" + this.getId() + "')");
		}
	};

})();


// DataBinding
/**
 * Determines whether a given object contains binding information instead of a
 * value or aggregated controls. The method is used in applySettings for processing
 * the JSON notation of properties/aggregations in the constructor.
 *
 * @param {object} oValue the value
 * @param {object} oKeyInfo the metadata of the property
 *
 * @returns {boolean} whether the value contains binding information
 *
 * @private
 */
sap.ui.core.Element.prototype.isBinding = function(oValue, oKeyInfo) {
	if (oValue && typeof oValue == "object" && oValue.path && oKeyInfo.type != "object") {
		return true;
	}
	if (typeof oValue == "string" && jQuery.sap.startsWith(oValue, "{") && jQuery.sap.endsWith(oValue, "}")) {
		return true;
	}
	return false;
};

/**
 * Extracts the binding info from the given value. There are two possible notations
 * for binding information in the JSON notation of the control constructor:
 * - property: "{path}"
 *   This is used for property binding and can only contain the path.
 * - property:{path:"path", template:oTemplate}
 *   This is used for aggregation binding, where a template is required or can
 *   be used for property binding when additional data is required (e.g. formatter).
 *
 * @param {object} oValue
 *
 * @returns {object} the binding info object, containing at least a path property
 *                   and, dependant of the binding type, additional properties
 *
 * @private
 */
sap.ui.core.Element.prototype.getBindingInfo = function(oValue) {
	var oBindingInfo;
	// property:{path:"path", template:oTemplate}
	if (oValue && typeof oValue == "object") {
		oBindingInfo = oValue;
	}
	// property:"{path}"
	if (typeof oValue == "string") {
		oBindingInfo = {};
		oBindingInfo.path = oValue.substr(1, oValue.length - 2);
	}
	return oBindingInfo;
};

/**
 * Create a new binding context for an element, which is used to resolve bound properties or
 * aggregations relatively to the given path.
 * This method is useful if the binding path changes or wasn't provided in the first place
 * (e.g. master detail scenarios).
 * @param {string} sPath the binding path
 *
 * @return {sap.ui.core.Element} reference to the instance itself
 * @public
 */
sap.ui.core.Element.prototype.bindContext = function(sPath) {
	this.sBindingPath = sPath;
	this.updateBindingContext();
	return this;
};

/**
 * Removes the defined binding context of this element, all bindings will now resolve
 * relative to the parent context again.
 *
 * @return {sap.ui.core.Element} reference to the instance itself
 * @public
 */
sap.ui.core.Element.prototype.unbindContext = function() {
	this.sBindingPath = null;
	this.oBindingContext = null;
	this.updateBindingContext();
	return this;
};


/**
 * Bind a property to the model.
 * The Setter for the given property will be called with the value retrieved
 * from the data model.
 * This is a generic method which can be used to bind any property to the
 * model. A control may flag properties in the metamodel with
 * bindable="bindable" to get typed bind methods for a property.
 *
 * @param {string} sName the name of the property
 * @param {string} sPath the binding path
 * @param {object} [oFormat=null] the formatter function or sap.ui.model.Type
 * @param {sap.ui.model.BindingMode} [sMode=Default] the binding mode to be used for this property binding (e.g. one way)
 *
 * @return {sap.ui.core.Element} reference to the instance itself
 * @public
 */
sap.ui.core.Element.prototype.bindProperty = function(sName, sPath, oFormat, sMode) {
	var sModelName,
		oBindingInfo,
		iSeparatorPos = sPath.indexOf(">"),
		fnFormatter,
		oType;
	// find out whether formatter or type has been provided
	if (typeof oFormat == "function") {
		fnFormatter = oFormat;
	}
	else if (oFormat instanceof sap.ui.model.SimpleType) {
		oType = oFormat;
	}
	// if property is already bound, unbind it first
	if (this.isBound(sName)){
		this.unbindProperty(sName);
	}
	// if a model separator is found in the path, extract model name and path
	if (iSeparatorPos > 0) {
		sModelName = sPath.substr(0, iSeparatorPos);
		sPath = sPath.substr(iSeparatorPos + 1);
	}
	// create a binding info object with all necessary information to create the binding, as soon
	// as the model is available, or when the model is changed
	oBindingInfo = {path: sPath, formatter: fnFormatter, type: oType, model: sModelName, mode: sMode || sap.ui.model.BindingMode.Default};
	this.mBindingInfos[sName] = oBindingInfo;

	// if the model is already available, create the binding
	if (this.getModel(sModelName)) {
		this._bindProperty(sName, oBindingInfo);
	}
	return this;
};

sap.ui.core.Element.prototype._bindProperty = function(sName, oBindingInfo) {
	var oModel = this.getModel(oBindingInfo.model),
		oContext,
		oBinding,
		oPropertyInfo = this.getMetadata().getJSONKeys()[sName],
		fnFormatter = oBindingInfo.formatter,
		oType = oBindingInfo.type,
		sInternalType = oPropertyInfo.type,
		that = this,
		fModelChangeHandler = function() {
			var oValue = oBinding.getValue();
			if (fnFormatter) {
				oValue = fnFormatter.apply(that, [oValue]);
			}
			if (oType) {
				try {
					oValue = oType.formatValue(oValue, sInternalType);
					oBindingInfo.skipModelUpdate = true;
					that[oPropertyInfo._sMutator](oValue);
					oBindingInfo.skipModelUpdate = false;
				}catch (oException) {
					if (oException instanceof sap.ui.model.FormatException) {
						sap.ui.getCore().fireFormatError({element : that, property : sName, type : oType, newValue : oValue, oldValue : that.getProperty(sName), exception: oException});
					}else {
						throw oException;
					}
				}
			}else {
				oBindingInfo.skipModelUpdate = true;
				that[oPropertyInfo._sMutator](oValue);
				oBindingInfo.skipModelUpdate = false;
			}
		};

	// Only use context for bindings on the primary model
	oContext = oBindingInfo.sModelName ? null : this.getBindingContext();

	// Create binding object
	oBinding = oModel.bindProperty(oBindingInfo.path, oContext);

	// Set additional information on the binding info
	oBindingInfo.skipModelUpdate = false;
	oBindingInfo.binding = oBinding;
	oBindingInfo.modelChangeHandler = fModelChangeHandler;

	if (!oModel.isBindingModeSupported(oBindingInfo.mode)) {
		oBindingInfo.mode = oModel.getDefaultBindingMode();
	}

	// Attach to the change event of the binding and initialize value
	if (oBindingInfo.mode != sap.ui.model.BindingMode.OneTime) {
		oBinding.attachChange(fModelChangeHandler);
	}
	fModelChangeHandler();
};

/**
 * Unbind the property from the model
 *
 * @param {String} sName the name of the property
 * @return {sap.ui.core.Element} reference to the instance itself
 * @public
 */
sap.ui.core.Element.prototype.unbindProperty = function(sName){
	var oBindingInfo = this.mBindingInfos[sName];
	if(oBindingInfo) {
		if (oBindingInfo.binding) {
			oBindingInfo.binding.detachChange(oBindingInfo.modelChangeHandler);
		}
		delete this.mBindingInfos[sName];
	}
	return this;
};

/**
 * Update the property in the model if two way data binding mode is enabled
 *
 * @param sName the name of the property to update
 * @param oValue the new value to set for the property in the model
 * @private
 */
sap.ui.core.Element.prototype.updateModelProperty = function(sName, oValue, oOldValue){
	if (this.isBound(sName)){
		var oBindingInfo = this.mBindingInfos[sName],
			oBinding = oBindingInfo.binding,
			oPropertyInfo = this.getMetadata().getJSONKeys()[sName],
			oType = oBindingInfo.type,
			sInternalType = oPropertyInfo.type;
		if (oBindingInfo.mode == sap.ui.model.BindingMode.TwoWay
				&& oBinding
				&& !oBindingInfo.skipModelUpdate
				&& !oBindingInfo.formatter) {
			if (oType) {
				try {
					oValue = oType.parseValue(oValue, sInternalType);
					oType.validateValue(oValue);
					oBindingInfo.binding.setValue(oValue);
					sap.ui.getCore().fireValidationSuccess({element : this, property : sName, type : oType, newValue : oValue, oldValue : oOldValue});
				}
				catch (oException) {
					if (oException instanceof sap.ui.model.ParseException) {
						sap.ui.getCore().fireParseError({element : this, property : sName, type : oType, newValue : oValue, oldValue : oOldValue, exception: oException});
					}else if (oException instanceof sap.ui.model.ValidateException) {
						sap.ui.getCore().fireValidationError({element : this, property : sName, type : oType, newValue : oValue, oldValue : oOldValue, exception: oException});
					}
					else {
						throw oException;
					}
				}
			}else {
				oBindingInfo.binding.setValue(oValue);
			}
		}
	}
};

/**
 * Bind an aggregation to the model.
 * The bound aggregation will use the given template, clone it for each element
 * which exists in the bound list and set the appropriate binding context.
 * This is a generic method which can be used to bind any aggregation to the
 * model. A control may flag aggregations in the metamodel with
 * bindable="bindable" to get typed bind methods for an aggregation.
 *
 * @param {string} sName the aggregation to bind
 * @param {string} sPath the binding path
 * @param {sap.ui.core.Element} oTemplate the template
 * @param {sap.ui.model.Sorter} oSorter the initial sort order (optional)
 * @param {array} aFilters the predefined filters (sap.ui.model.Filter) for this aggregation (optional)
 *
 * @return {sap.ui.core.Element} reference to the instance itself
 * @public
 */
sap.ui.core.Element.prototype.bindAggregation = function(sName, sPath, oTemplate, oSorter, aFilters) {
	var oBindingInfo,
		iSeparatorPos = sPath.indexOf(">");
	// if aggregation is already bound, unbind it first
	if (this.isBound(sName)){
		this.unbindAggregation(sName);
	}
	// if a model separator is found, throw an error: aggregation binding is only allowed on the primary model
	if (iSeparatorPos > 0) {
		throw new Error("Tried to bind aggregation " + sName + " of control id " + this.getId() + " to a named model!");
	}
	// check whether a template has been provided, which is required for proper processing of the binding
	if (!oTemplate) {
		throw new Error("Missing template for aggregation " + sName + " of control id " + this.getId() + " !");
	}
	// create a binding info object with all necessary information to create the binding as soon as
	// the model is available, or when the model is changed
	var oBindingInfo = {path: sPath, template: oTemplate, sorter: oSorter, filters: aFilters};
	this.mBindingInfos[sName] = oBindingInfo;

	// if the model is already available create the binding
	if (this.getModel()) {
		this._bindAggregation(sName, oBindingInfo);
	}
	return this;
};

sap.ui.core.Element.prototype._bindAggregation = function(sName, oBindingInfo) {
	var sBindMethod = this.isTreeBinding(sName) ? "bindTree" : "bindList",
		oBinding = this.getModel()[sBindMethod](oBindingInfo.path, this.getBindingContext(), oBindingInfo.sorter, oBindingInfo.filters),
		that = this,
		fModelChangeHandler = function(oEvent){
			that.updateAggregation(sName);
		};

	oBindingInfo.binding =  oBinding;
	oBindingInfo.modelChangeHandler =  fModelChangeHandler;

	oBinding.attachChange(fModelChangeHandler);
	fModelChangeHandler();
};

/**
 * Unbind the aggregation from the model
 *
 * @param {String} sName the name of the aggregation
 * @return {sap.ui.core.Element} reference to the instance itself
 * @public
 */
sap.ui.core.Element.prototype.unbindAggregation = function(sName){
	var oBindingInfo = this.mBindingInfos[sName];
	if(oBindingInfo) {
		if (oBindingInfo.binding) {
			oBindingInfo.binding.detachChange(oBindingInfo.modelChangeHandler);
		}
		delete this.mBindingInfos[sName];
	}
	return this;
};

/**
 *  This method is used internally and should only be overridden by a tree control which utilizes the tree binding.
 *  In this case and if the aggregation is a tree node the overridden method should then return true.
 *  If true is returned the tree binding will be used instead of the list binding.
 *
 *  @param {string} sName the aggregation to bind (e.g. nodes for a tree control)
 *  @return {boolean} whether tree binding should be used or list binding. Default is false. Override method to change this behavior.
 *
 *  @protected
 */
sap.ui.core.Element.prototype.isTreeBinding = function(sName) {
	return false;
};

/**
 * Create bindings in case the model was not available at the time
 * bindProperty or bindAggregation was called
 *
 * @private
 */
sap.ui.core.Element.prototype.updateBindings = function(bUpdateAll, sModelName, bRecreate) {
	var that = this;

	// create property and aggregation bindings if they don't exist yet
	jQuery.each(this.mBindingInfos, function(sName, oBindingInfo) {
		if (that.getModel(oBindingInfo.model) && (bUpdateAll || oBindingInfo.model == sModelName)) {
			if ( bRecreate && oBindingInfo.binding ) {
				oBindingInfo.binding.detachChange(oBindingInfo.modelChangeHandler);
				delete oBindingInfo.binding;
			}
			if (!oBindingInfo.binding) {
				if (oBindingInfo.template) {
					that._bindAggregation(sName, oBindingInfo);
				} else {
					that._bindProperty(sName, oBindingInfo);
				}
			}
		}
	});

	// also update bindings in all child elements
	jQuery.each(this.mAggregations, function(sName, oAggregation) {
		if (oAggregation instanceof sap.ui.core.Element) {
			oAggregation.updateBindings(bUpdateAll, sModelName, bRecreate);
		} else if (oAggregation instanceof Array) {
			for (var i = 0; i < oAggregation.length; i++) {
				oAggregation[i].updateBindings(bUpdateAll, sModelName, bRecreate);
			}
		}
	});

};

/**
 * Generic method which is called, whenever an aggregation binding is changed.
 * This method deletes all elements in this aggregation and recreates them
 * according to the data model.
 * In case a control needs special handling for a aggregation binding, it can create
 * a typed update-method (e.g. "updateRows") which will be used instead of the
 * default behaviour.
 *
 * @private
 */
sap.ui.core.Element.prototype.updateAggregation = function(sName, iStartIndex, iLength) {
	var oBindingInfo = this.mBindingInfos[sName],
		sUpdater = "update" + sName.substr(0,1).toUpperCase() + sName.substr(1);
	if (this[sUpdater]) {
		this[sUpdater](oBindingInfo, iStartIndex, iLength);
		return;
	}
	var oBinding = oBindingInfo.binding,
		oTemplate = oBindingInfo.template,
		aContexts = oBinding.getContexts(iStartIndex, iLength),
		oAggregationInfo = this.getMetadata().getJSONKeys()[sName],
		oClone,
		that = this;
	this[oAggregationInfo._sDestructor]();
	if (iStartIndex) {
		this.mAggregations[sName] = new Array(iStartIndex);
	}
	jQuery.each(aContexts, function(iIndex, oContext) {
		oClone = oTemplate.clone(that.getId() + "-" + iIndex);
		oClone.setBindingContext(oContext);
		that[oAggregationInfo._sMutator](oClone);
	});
};

/**
 * Find out whether a property or aggregation is bound
 *
 * @param {String} sName the name of the property or aggregation
 * @return {boolean} whether a binding exists for the given name
 * @public
 */
sap.ui.core.Element.prototype.isBound = function(sName){
	return (sName in this.mBindingInfos);
};

/**
 * Get the binding object for a specific aggregation/property
 *
 * @param {String} sName the name of the property or aggregation
 * @return {Binding} the binding for the given name
 * @public
 */
sap.ui.core.Element.prototype.getBinding = function(sName){
	return this.mBindingInfos[sName] && this.mBindingInfos[sName].binding;
};

/**
 * Get the binding path for a specific aggregation/property
 *
 * @param {String} sName the name of the property or aggregation
 * @return {String} the binding path for the given name
 * @protected
 */
sap.ui.core.Element.prototype.getBindingPath = function(sName){
	return this.mBindingInfos[sName] && this.mBindingInfos[sName].path;
};

/**
 * Set the binding context for this element.
 *
 * @param {Object} oContext the new binding context for this element
 *
 * @return {sap.ui.core.Element} reference to the instance itself
 * @public
 */
sap.ui.core.Element.prototype.setBindingContext = function(oContext){
	this.oBindingContext = oContext;
	this.updateBindingContext();
	return this;
};

/**
 * Update the binding context in this element and all children
 * @private
 */
sap.ui.core.Element.prototype.updateBindingContext = function(bSkipLocal){

	var oModel = this.getModel(),
		oParent = this.getParent(),
		that = this;

	if (this.sBindingPath && !bSkipLocal) {
		if (oParent && oModel) {
			oModel.createBindingContext(this.sBindingPath, oParent.getBindingContext(), function(oContext) {
				that.oBindingContext = oContext;
				that.updateBindingContext(true);
			});
		}
		return;
	}

	var oContext = this.getBindingContext();

	// update context in existing bindings, but only for the primary model
	jQuery.each(this.mBindingInfos, function(sName, oBindingInfo) {
		var oBinding = oBindingInfo.binding;
		if (oBinding && oBinding.getModel() == oModel) {
			oBinding.setContext(oContext);
		}
	});

	// also update context in all child elements
	jQuery.each(this.mAggregations, function(sName, oAggregation) {
		if (oAggregation instanceof sap.ui.core.Element) {
			oAggregation.updateBindingContext();
		} else if (oAggregation instanceof Array) {
			for (var i = 0; i < oAggregation.length; i++) {
				oAggregation[i].updateBindingContext();
			}
		}
	});

};


/**
 * Get the binding context of this element
 * If the element does not have a binding context set on itself, it will ask
 * the parent element for its binding context
 *
 * @return {Object} the binding context of this element
 * @public
 */
sap.ui.core.Element.prototype.getBindingContext = function(){
	if (this.oBindingContext) {
		return this.oBindingContext;
	}
	return this.getParent() && this.getParent().getBindingContext();
};

/**
 * Set the model for databinding
 * @param {sap.ui.model.Model} oModel
 * @param {string} [sName]
 * @return {sap.ui.core.Element} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.core.Element.prototype.setModel = function(oModel, sName) {
	if ( oModel !== this.oModels[sName] ) {
		this.oModels[sName] = oModel;
		// update binding context, for primary model only
		if (!sName){this.updateBindingContext();}
		// if the model changes, all bindings have to be recreated (at least those to the previous model)
		this.updateBindings(false, sName, true);
	}
	return this;
};

/**
 * Get the model for databinding
 * If the element does not have a model set on itself, it will ask
 * the parent element for the model to use
 * @param {string} [sName]
 * @return {sap.ui.model.Model} oModel
 * @public
 */
sap.ui.core.Element.prototype.getModel = function(sName) {
	return this.oModels[sName] || (this.getParent() && this.getParent().getModel(sName));
};

/**
 * Check if a Model is set to the Element or to one of its Parents (including UIArea and Core)
 * @return {boolean} true or false
 * @public
 */
sap.ui.core.Element.prototype.hasModel = function() {
	if (!jQuery.isEmptyObject(this.oModels) || (this.getParent() && this.getParent().hasModel())) {
		return true;
	} else {
		return false;
	}
};

/**
 * Clone an element
 *
 * @param {String} [sIdSuffix] a suffix to be appended to the cloned element id
 * @param {Array} [aLocalIds] an array of local IDs within the cloned hierarchy
 * @return {sap.ui.core.Element} reference to the newly created clone
 * @protected
 */
sap.ui.core.Element.prototype.clone = function(sIdSuffix, aLocalIds){
	// if no id suffix has been provided use a generated UID
	if (!sIdSuffix) {
		sIdSuffix = jQuery.sap.uid();
	}
	// if no local ID array has been passed, collect IDs of all contained elements to
	// be able to properly adapt associations, which are within the cloned element hierarchy
	if (!aLocalIds) {
		aLocalIds = jQuery.map(this.findElements(true), function(oElement) {return oElement.getId();});
	}

	var oMetadata = this.getMetadata(),
		oClass = oMetadata._oClass,
		sId = this.getId() + "-" + sIdSuffix,
		mSettings = jQuery.extend({},this.mProperties),
		oClone;

	// Clone aggregations
	jQuery.each(this.mAggregations, function(sName, oAggregation) {
		if (oMetadata.hasAggregation(sName)) {
			if (oAggregation instanceof sap.ui.core.Element) {
				mSettings[sName] = oAggregation.clone(sIdSuffix, aLocalIds);
			} else if (jQuery.isArray(oAggregation)) {
				mSettings[sName] = [];
				for (var i = 0; i < oAggregation.length; i++) {
					mSettings[sName].push(oAggregation[i].clone(sIdSuffix, aLocalIds));
				}
			} else {
				// must be an alt type
				mSettings[sName] = oAggregation;
			}
		}
	});

	// Clone associations
	jQuery.each(this.mAssociations, function(sName, oAssociation) {
		// Check every associated ID against the ID array, to make sure associations within
		// the template are properly converted to associations within the clone
		if (jQuery.isArray(oAssociation)) {
			oAssociation = oAssociation.slice(0);
			for (var i = 0; i < oAssociation.length; i++) {
				if (jQuery.inArray(oAssociation[i], aLocalIds) >= 0) {
					oAssociation[i] += "-" + sIdSuffix;
				}
			}
		} else if (jQuery.inArray(oAssociation, aLocalIds) >= 0) {
			oAssociation += "-" + sIdSuffix;
		}
		mSettings[sName] = oAssociation;
	});

	// Create clone instance
	oClone = new oClass(sId, mSettings);

	// Clone events
	jQuery.each(this.mEventRegistry, function(sName, aListeners) {
		oClone.mEventRegistry[sName] = aListeners.slice();
	});

	// Clone models
	jQuery.each(this.oModels, function(sName, oModel) {
		oClone.setModel(oModel, sName);
	});

	// Clone bindings
	jQuery.each(this.mBindingInfos, function(sName, oBindingInfo) {
		if (oBindingInfo.template) {
			oClone.bindAggregation(sName, oBindingInfo.path, oBindingInfo.template, oBindingInfo.sorter, oBindingInfo.filters);
		} else {
			oClone.bindProperty(sName, oBindingInfo.model ? oBindingInfo.model + ">" + oBindingInfo.path : oBindingInfo.path, oBindingInfo.type || oBindingInfo.formatter, oBindingInfo.mode);
		}
	});

	return oClone;
};

/**
 * Maps the given aggregation with name <code>sOldAggrName</code>
 * on aggregation <code>sNewAggrName</code> (When calling an accessor function
 * of the old aggregation the call is forwarded to the corresponding accessor
 * function of the new aggregation).
 *
 * This function should help to perform a smooth transition for users of a control
 * when an aggregation must be renamed.
 *
 * Both aggregations must have a mutiple cardinality (0..n) and must have the same
 * aggregated type!
 *
 * @param {object}
 *			oPrototype Control/Element prototype for which a mapping should be defined
 * @param {string}
 *			sOldAggrName Name of the old deprecated aggregation
 * @param {string}
 *			sNewAggrName Name of the new aggregation
 * @deprecated
 */
sap.ui.core.Element._mapAggregation = function(oPrototype, sOldAggrName, sNewAggrName){
	var mKeys = oPrototype.getMetadata().getJSONKeys();
	var oOldAggrInfo = mKeys[sOldAggrName];
	var oNewAggrInfo = mKeys[sNewAggrName];

	//Check whether aggregations exist and are multiple.
	if(!oOldAggrInfo || !oNewAggrInfo || oOldAggrInfo._iKind != 2 || oNewAggrInfo._iKind != 2) {
		return;
	}

	var mFunc = {"insert" : true, "add" : true, "remove" : true, "removeAll" : false, "indexOf" : true, "destroy" : false, "get" : false};

	function method(sPrefix, sName) {
		return sPrefix + sName.substring(0,1).toUpperCase() + sName.substring(1);
	}

	function fAggrDelegator(sFuncName){
		return function() {
			return this[sFuncName].apply(this, arguments);
		};
	}

	for(var sPrefix in mFunc){
		var sOldFuncName = method(sPrefix, mFunc[sPrefix] ? oOldAggrInfo.singularName : oOldAggrInfo._sName);
		var sNewFuncName = method(sPrefix, mFunc[sPrefix] ? oNewAggrInfo.singularName : oNewAggrInfo._sName);
		oPrototype[sOldFuncName] = fAggrDelegator(sNewFuncName);
	}
};

/**
 * Searches and returns an array of child elements and controls which are
 * referenced within an aggregation or aggregations of child elements/controls.
 * This can be either done recursive or not.
 * <br>
 * <b>Take care: this operation might be expensive.</b>
 * @param {boolean}
 *          bRecursive true, if all nested children should be returned.
 * @return {sap.ui.core.Element[]} array of child elements and controls
 * @public
 */
sap.ui.core.Element.prototype.findElements = function(bRecursive) {

	var aControls = [];
	function fFindElements(oControl) {
		for (var n in oControl.mAggregations) {
			var a = oControl.mAggregations[n];
			if (jQuery.isArray(a)) {
				for (var i = 0; i < a.length; i++) {
					aControls.push(a[i]);
					if (bRecursive) {
						fFindElements(a[i]);
					}
				}
			} else if (a instanceof sap.ui.core.Element) {
				aControls.push(a);
				if (bRecursive) {
					fFindElements(a);
				}
			}
		}
	}
	fFindElements(this);
	return aControls;

};

}; // end of sap.ui.core.Element

//jQuery.sap.require("sap.ui.core.RenderManager"); // cyclic

/**
 * Creates and initializes a new control with the given <code>sId</code> and settings.
 *
 * The set of allowed entries in the <code>mSettings</code> object depends on the concrete
 * subclass and is described there. See {@link sap.ui.core.Element} for a general description of this
 * argument.
 *
 * @param {string} [sId] optional id for the new control; generated automatically if no non-empty id is given
 *      Note: this can be omitted, no matter whether <code>mSettings</code> will be given or not!
 * @param {object} [mSettings] optional map/JSON-object with initial settings for the new control
 * @public
 *
 * @class Base Class for Controls.
 * @extends sap.ui.core.Element
 * @abstract
 * @author Martin Schaus, Daniel Brinkmann
 * @version 1.5.0-SNAPSHOT
 * @name sap.ui.core.Control
 */
sap.ui.core.Element.extend("sap.ui.core.Control", /* @lends sap.ui.core.Control */ {

	metadata : {
		"abstract" : true,
		publicMethods: ["placeAt", "attachBrowserEvent", "detachBrowserEvent"],
		library: "sap.ui.core",
		properties : {},
		aggregations : {},
		associations : {},
		events : {}
	},

	constructor : function(sId, mSettings) {

		// TODO initialization should happen in init
		// but many of the existing controls don't call super.init()
		// As a workaround I moved the initialization of bAllowTextSelection here
		// so that it doesn't overwrite settings in init() (e.g. ListBox)
		this.bAllowTextSelection = true;

		sap.ui.core.Element.apply(this,arguments);
		this.bOutput = this.getDomRef() != null; // whether this control has already produced output
	},

	renderer : null // Control has no renderer

});

/*
 * Override clone() to be able to clone additional internal state
 * which is not stored in properties or aggregations.
 */
sap.ui.core.Control.prototype.clone = function() {
	var oClone = sap.ui.core.Element.prototype.clone.apply(this, arguments);

	if ( this.aBindParameters ) {
		for(var i=0, l=this.aBindParameters.length; i<l; i++) {
			var aParams = this.aBindParameters[i];
			oClone.attachBrowserEvent(aParams.sEventType, aParams.fnHandler, aParams.oListener !== this ? aParams.oListener : undefined);
		}
	}
	oClone.bAllowTextSelection = this.bAllowTextSelection;
	return oClone;
};

// must appear after clone() method and metamodel definition
if ( !jQuery.sap.isDeclared('sap.ui.core.CustomStyleClassSupport') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

jQuery.sap.declare("sap.ui.core.CustomStyleClassSupport");

/**
 * If called on the prototype of a sap.ui.core.Element, the Element (and its prototype) is extended
 * to support custom style classes.
 *
 * WARNING: only to be used WITHIN a control implementation. An application cannot add style class support by calling this method!
 *
 * The methods "addStyleClass", "removeStyleClass" and "hasStyleClass" are added to the Element and the clone() method
 * is extended to also clone the custom classes.
 *
 * Usage example:
 * jQuery.sap.require("sap.ui.core.CustomStyleClassSupport");
 * sap.ui.core.CustomStyleClassSupport.apply(sap.ui.commons.layout.MatrixLayoutCell.prototype);
 *
 * Each renderer handling the given Element MUST then call
 * renderManager.writeClasses(oElement);
 * when writing the root tag of the Element. This makes sure the classes are written to the HTML.
 *
 * @public
 */
sap.ui.core.CustomStyleClassSupport = function () {
	// "this" is the protoype now when called with apply()

	// Ensure only Elements are enhanced
	if(!(this instanceof sap.ui.core.Element)) {
		return;
	}

	// enrich original clone function
	var fOriginalClone = this.clone;
	this.clone = function() {
		// call original clone function
		var oClone = fOriginalClone.apply(this, arguments);

		// add the style classes of "this" to the clone
		if (this.aCustomStyleClasses) {
			oClone.aCustomStyleClasses = this.aCustomStyleClasses.slice();
		}
		return oClone;
	};


	this.addStyleClass = function(sStyleClass, bSuppressRerendering) {
		jQuery.sap.assert(sStyleClass && typeof sStyleClass === "string", "sStyleClass must be a string");

		if (!this.aCustomStyleClasses) {
			this.aCustomStyleClasses = [];
		}
		if (sStyleClass) {
			// ensure the "class" attribute is not closed
			if (sStyleClass.indexOf("\"") > -1) {
				return this;
			}
			if (sStyleClass.indexOf("'") > -1) {
				return this;
			} // TODO: maybe check for quotes in different charsets or encodings

			// multiple calls should not add the class multiple times
			for (var i = this.aCustomStyleClasses.length-1; i >= 0; i--) {
				if (this.aCustomStyleClasses[i] == sStyleClass) {
					return this;
				}
			}

			this.aCustomStyleClasses.push(sStyleClass);
			var oRoot = this.getDomRef();
			if (oRoot) { // non-rerendering shortcut
				jQuery(oRoot).addClass(sStyleClass);
			} else if (!bSuppressRerendering) {
				this.invalidate();
			}
		}

		return this;
	};


	this.removeStyleClass = function(sStyleClass, bSuppressRerendering) { // bSuppressRerendering is experimental and hence undocumented
		jQuery.sap.assert(sStyleClass && typeof sStyleClass === "string", "sStyleClass must be a string");

		if (sStyleClass && this.aCustomStyleClasses) {
			for (var i = this.aCustomStyleClasses.length-1; i >= 0; i--) {
				if (this.aCustomStyleClasses[i] == sStyleClass) {
					this.aCustomStyleClasses.splice(i, 1);
					var oRoot = this.getDomRef();
					if (oRoot) { // non-rerendering shortcut
						jQuery(oRoot).removeClass(sStyleClass);
					} else if (!bSuppressRerendering) {
						this.invalidate();
					}
				}
			}
		}

		return this;
	};


	this.hasStyleClass = function(sStyleClass) {
		jQuery.sap.assert(sStyleClass && typeof sStyleClass === "string", "sStyleClass must be a string");

		if (sStyleClass && this.aCustomStyleClasses) {
			for (var i = this.aCustomStyleClasses.length-1; i >= 0; i--) {
				if (this.aCustomStyleClasses[i] == sStyleClass) {
					return true;
				}
			}
		}
		return false;
	};

	this.getMetadata().addPublicMethods(["addStyleClass", "removeStyleClass", "hasStyleClass"]);

};

// moved here to fix the cyclic dependency CustomStyleClassSupport, Element, Core, Control


}; // end of sap.ui.core.CustomStyleClassSupport

sap.ui.core.CustomStyleClassSupport.apply(sap.ui.core.Control.prototype);


/**
 * Checks whether the control is still active (part of the active DOM)
 *
 * @return {boolean} whether the control is still in the active DOM
 * @private
 */
sap.ui.core.Control.prototype.isActive = function() {
	return jQuery.sap.domById(this.sId) != null;
};

/**
 * Triggers rerendering of this element and its children.
 *
 * As <code>sap.ui.core.Element</code> "bubbles up" the invalidate, changes to children
 * potentially result in rerendering of the whole sub tree.
 * @protected
 */
sap.ui.core.Control.prototype.invalidate = function(oOrigin) {
	var oUIArea;
	if ( this.bOutput && (oUIArea = this.getUIArea()) ) {
		// if this control has been rendered before (bOutput)
		// and if it is contained in an UIArea (!!oUIArea)
		// then control re-rendering can be used (see UIArea.rerender() for details)
		//
		// The check for bOutput is necessary as the control
		// re-rendering needs to identify the previous rendering results.
		// Otherwise it wouldn't be able to replace them.
		oUIArea.addInvalidatedControl(this);
	} else {
		// else we bubble up the hierarchy
		var oParent = this.getParent();
		if (oParent && (
				this.bOutput /* && !this.getUIArea() */ ||
				/* !this.bOutput && */ !(this.getVisible && this.getVisible() === false))) {

			// Note: the two comments in the condition above show additional conditions
			//       that help to understand the logic. As they are always fulfilled,
			//       they have been omitted for better performance.
			//
			// If this control has a parent but either
			//  - has produced output before ('this.bOutput') but is not part of an UIArea (!this.getUIArea())
			//  - or if it didn't produce output (!this.bOutput') before and is/became visible
			// then invalidate the parent to request re-rendering
			//
			// The first commented condition is always true, otherwise the initial if condition
			// in this method would have been met. The second one must be true as well because of the
			// short evaluation logic of JavaScript. When bOutput is true the second half of the Or won't be processed.

			oParent.invalidate(this);
		}
	}
};

/**
 * Tries to replace its DOM reference by re-rendering.
 * @protected
 */
sap.ui.core.Control.prototype.rerender = function() {
	sap.ui.core.UIArea.rerenderControl(this);
};

/**
 * Defines whether the user can select text inside this control.
 * Defaults to <code>true</code> as long as this method has not been called.
 *
 * <b>Note:</b>This only works in IE and Safari; for Firefox the element's style must
 * be set to:
 * <pre>
 *   -moz-user-select: none;
 * </pre>
 * in order to prevent text selection.
 *
 * @param {boolean} whether to allow text selection or not
 * @return {sap.ui.core.Control} Returns <code>this</code> to allow method chaining
 * @public
 */
sap.ui.core.Control.prototype.allowTextSelection = function(bAllow) {
	this.bAllowTextSelection = bAllow;
	return this;
};

/**
 * The string given as "sStyleClass" will be added to the "class" attribute of this control's root HTML element.
 *
 * This method is intended to be used to mark controls as being of a special type for which
 * special styling can be provided using CSS selectors that reference this style class name.
 *
 * <pre>
 * Example:
 *    myButton.addStyleClass("myRedTextButton"); // add a CSS class to one button instance
 *
 * ...and in CSS:
 *    .myRedTextButton {
 *       color: red;
 *    }
 * </pre>
 *
 * This will add the CSS class "myRedTextButton" to the Button HTML and the CSS code above will then
 * make the text in this particular button red.
 *
 * Only characters allowed inside HTML attributes are allowed.
 * Quotes are not allowed and this method will ignore any strings containing quotes.
 * Strings containing spaces are interpreted as ONE custom style class (even though CSS selectors interpret them
 * as different classes) and can only removed later by calling removeStyleClass() with exactly the
 * same (space-containing) string as parameter.
 * Multiple calls with the same sStyleClass will have no different effect than calling once.
 * If sStyleClass is null, the call is ignored.
 *
 * @name sap.ui.core.Control.prototype.addStyleClass
 * @function
 *
 * @param {string} sStyleClass the CSS class name to be added
 * @return {sap.ui.core.Control} Returns <code>this</code> to allow method chaining
 * @public
 */

/**
 * Removes the given string from the list of custom style classes that have been set previously.
 * Regular style classes like "sapUiBtn" cannot be removed.
 *
 * @name sap.ui.core.Control.prototype.removeStyleClass
 * @function
 *
 * @param {string} sStyleClass the style to be removed
 * @return {sap.ui.core.Control} Returns <code>this</code> to allow method chaining
 * @public
 */

/**
 * Returns true if the given style class string is valid and if this control has this style class set
 * via a previous call to addStyleClass().
 *
 * @name sap.ui.core.Control.prototype.hasStyleClass
 * @function
 *
 * @param {string} sStyleClass the style to check for
 * @type boolean
 * @return whether the given style has been set before
 * @public
 */


/**
 * Allows binding handlers for any native browser event to the root HTML element of this Control. This internally handles
 * DOM element replacements caused by re-rendering.
 *
 * IMPORTANT:
 * This should be only used as FALLBACK when the Control events do not cover a specific use-case! Always try using
 * SAPUI5 control events, as e.g. accessibility-related functionality is then provided automatically.
 * E.g. when working with a sap.ui.commons.Button, always use the Button's "press" event, not the native "click" event, because
 * "press" is also guaranteed to be fired when certain keyboard activity is supposed to trigger the Button.
 *
 * In the event handler, "this" refers to the Control - not to the root DOM element like in jQuery. While the DOM element can
 * be used and modified, the general caveats for working with SAPUI5 control DOM elements apply. In particular the DOM element
 * may be destroyed and replaced by a new one at any time, so modifications that are required to have permanent effect may not
 * be done. E.g. use Control.addStyleClass() instead if the modification is of visual nature.
 *
 * Use detachBrowserEvent() to remove the event handler(s) again.
 *
 * @param {string} [sEventType] A string containing one or more JavaScript event types, such as "click" or "blur".
 * @param {function} [fnHandler] A function to execute each time the event is triggered.
 * @param {Object} [oListener] The object, that wants to be notified, when the event occurs
 * @return {sap.ui.core.Control} Returns <code>this</code> to allow method chaining
 * @public
 */
sap.ui.core.Control.prototype.attachBrowserEvent = function(sEventType, fnHandler, oListener) {
	if (sEventType && (typeof(sEventType) === "string")) { // do nothing if the first parameter is empty or not a string
		if (fnHandler && typeof(fnHandler) === "function") {   // also do nothing if the second parameter is not a function
			// store the parameters for bind()
			if (!this.aBindParameters) {
				this.aBindParameters = [];
			}
			oListener = oListener || this;

			// FWE jQuery.proxy can't be used as it breaks our contract when used with same function but different listeners
			var fnProxy=function() { fnHandler.apply(oListener, arguments); };

			this.aBindParameters.push({
				sEventType: sEventType,
				fnHandler: fnHandler,
				oListener: oListener,
				fnProxy : fnProxy
			});

			// if control is rendered, directly call bind()
			this.$().bind(sEventType, fnProxy);
		}
	}

	return this;
};


/**
 * This method is used to remove event handlers which have been previously attached using sap.ui.core.Control.attachBrowserEvent().
 *
 * @param {string} [sEventType] A string containing one or more JavaScript event types, such as "click" or "blur".
 * @param {function} [fnHandler] The function that is to be no longer executed.
 * @public
 */
sap.ui.core.Control.prototype.detachBrowserEvent = function(sEventType, fnHandler, oListener) {
	if (sEventType && (typeof(sEventType) === "string")) { // do nothing if the first parameter is empty or not a string
		if (fnHandler && typeof(fnHandler) === "function") {   // also do nothing if the second parameter is not a function
			var $ = this.$(),i,oParamSet;
			oListener=oListener || this;

			// remove the bind parameters from the stored array
			if (this.aBindParameters) {
				for (i = this.aBindParameters.length - 1; i >= 0; i--) {
					oParamSet = this.aBindParameters[i];
					if ( oParamSet.sEventType === sEventType  && oParamSet.fnHandler === fnHandler  &&  oParamSet.oListener === oListener ) {
						this.aBindParameters.splice(i, 1);
						// if control is rendered, directly call unbind()
						$.unbind(sEventType, oParamSet.fnProxy);
					}
				}
			}

		}
	}

	return this;
};



/**
 * Returns a renderer for this control instance.
 *
 * It is retrieved using the RenderManager as done during rendering.
 *
 * @return {object} a Renderer suitable for this Control instance.
 * @protected
 */
sap.ui.core.Control.prototype.getRenderer = function () {
	//TODO introduce caching?
	return sap.ui.core.RenderManager.getRenderer(this);
};

/**
 * Puts <code>this</code> control into the specified container (<code>oRef</code>) at the given
 * position (<code>oPosition</code>).
 *
 * First it is checked whether <code>oRef</code> is a container element / control (has a
 * multiple aggregation with type <code>sap.ui.core.Control</code> and name 'content') or is an Id String
 * of such an container.
 * If this is not the case <code>oRef</code> can either be a Dom Reference or Id String of the UIArea
 * (if it does not yet exist implicitly a new UIArea is created),
 *
 * The <code>oPosition</code> can be one of the following:
 *
 *  - "first": The control is added as the first element to the container.
 *  - "last": The control is added as the last element to the container (default).
 *  - "only": All existing children of the container are removed (not destroyed!) and the control is added as new child.
 *  - index: The control is added at the specified index to the container.
 *
 * @param {String|DomRef|sap.ui.core.Control} oRef container into which the control should be put
 * @param {String|int} oPosition Describes the position where the control should be put into the container
 * @return {sap.ui.core.Control} Returns <code>this</code> to allow method chaining
 * @public
 */
sap.ui.core.Control.prototype.placeAt = function(oRef, oPosition) {
	var oCore = sap.ui.getCore();
	if(oCore.isInitialized()){
		// core already initialized, do it now

		// 1st try to resolve the oRef as a Container control
		var oContainer = oRef;
		if(typeof oContainer === "string"){
			oContainer = oCore.byId(oRef);
		}
		// if no container control is found use the corresponding UIArea
		var bIsUIArea = false;
		if(!(oContainer instanceof sap.ui.core.Element)) {
			oContainer = oCore.createUIArea(oRef);
			bIsUIArea = true;
		}

		if(!oContainer) {
			return;
		}

		if(!bIsUIArea){
			var oContentAggInfo = oContainer.getMetadata().getAllAggregations()["content"];
			var bContainerSupportsPlaceAt = true;
			if(oContentAggInfo){
				if(!oContentAggInfo.multiple || oContentAggInfo.type != "sap.ui.core.Control"){
					bContainerSupportsPlaceAt = false;
				}
			}else{
				//Temporary workaround for sap.ui.commons.AbsoluteLayout to enable placeAt even when no content aggregation is available. TODO: Find a proper solution
				if(!oContainer.addContent || !oContainer.insertContent || !oContainer.removeAllContent) {
					bContainerSupportsPlaceAt = false;
				}
			}
			if(!bContainerSupportsPlaceAt) {
				jQuery.sap.log.warning("placeAt cannot be processed because container "+oContainer+" does not have an aggregation 'content'.");
				return;
			}
		}

		if(typeof oPosition === "number"){
			oContainer.insertContent(this, oPosition);
		}else{
			oPosition = oPosition || "last"; //"last" is default
			switch(oPosition){
				case "last":
					oContainer.addContent(this);
					break;
				case "first":
					oContainer.insertContent(this, 0);
					break;
				case "only":
					oContainer.removeAllContent();
					oContainer.addContent(this);
					break;
				default:
					jQuery.sap.log.warning("Position "+oPosition+" is not supported for function placeAt.");
			}
		}
	}else{
		// core not yet initialized, defer execution
		var that = this;
		oCore.attachInitEvent(function () {
			that.placeAt(oRef, oPosition);
		});
	}
	return this;
};

/*
 * Event handling
 */

/**
 * Cancels user text selection if text selection is disabled for this control.
 * See the {@link #allowTextSelection} method.
 * @private
 */
sap.ui.core.Control.prototype.onselectstart = function (oBrowserEvent) {
	if(!this.bAllowTextSelection) {
		oBrowserEvent.preventDefault();
		oBrowserEvent.stopPropagation();
	}
};

/*
 * Rendering
 */

/**
 * Function is called before the rendering of the control is started.<br/>
 * Override this hook as you please.
 *
 * @function
 * @name sap.ui.core.Control.prototype.onBeforeRendering
 * @public
 */
//sap.ui.core.Control.prototype.onBeforeRendering = function() {};

/**
 * Function is called when the rendering of the control is completed. <br/>
 * Override this hook as you please.
 *
 * @function
 * @name sap.ui.core.Control.prototype.onAfterRendering
 * @public
 */
//sap.ui.core.Control.prototype.onAfterRendering = function() {};

/**
 * Gets the ID used for the "labelFor" attribute of the label
 * By default its the control ID
 * @public
 */
sap.ui.core.Control.prototype.getIdForLabel = function () {
	return this.getId();
};

}; // end of sap.ui.core.Control

if ( !jQuery.sap.isDeclared('sap.ui.core.FocusHandler') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides class sap.ui.core.FocusHandler
jQuery.sap.declare("sap.ui.core.FocusHandler");




(function(){

	/**
	 * Constructs an instance of a sap.ui.core.FocusHandler.
	 * Keeps track of the focused element.
	 *
	 * @class sap.ui.core.FocusHandler
	 * @param oRootRef e.g. document.body
	 */
	sap.ui.core.FocusHandler = function(oRootRef, oCore) {
		sap.ui.base.Object.apply(this);

		this.oCore = oCore;

		// keep track of element currently in focus
		this.oCurrent = null;
		// keep track of the element previously had the focus
		this.oLast = null;
		// buffer the focus/blur events for correct order
		this.aEventQueue = [];

		this.fEventHandler = jQuery.proxy(this.onEvent, this);
		this.fDestroyHandler = jQuery.proxy(this.destroy, this);

		// initialize event handling
		if(oRootRef.addEventListener && !jQuery.browser.msie){ //FF, Safari
			oRootRef.addEventListener("focus", this.fEventHandler, true);
			oRootRef.addEventListener("blur", this.fEventHandler, true);
		}else{ //IE
			jQuery(oRootRef).bind("activate", this.fEventHandler);
			jQuery(oRootRef).bind("deactivate", this.fEventHandler);
		}
		jQuery.sap.log.debug("FocusHandler setup on Root " + oRootRef.type + (oRootRef.id?": " + oRootRef.id:""), null, "sap.ui.core.FocusHandler");

		// TODO: Or should we be destroyed by the Core?
		jQuery(window).bind("unload", {"oRootRef": oRootRef}, this.fDestroyHandler);
	};

	sap.ui.core.FocusHandler.prototype = jQuery.sap.newObject(sap.ui.base.Object.prototype);
	sap.ui.base.Object.defineClass("sap.ui.core.FocusHandler", {
		baseType : "sap.ui.base.Object"
	});

	/**
	 * Returns the Id of the control/element currently in focus.
	 * @return {string} the Id of the control/element currently in focus.
	 * @public
	 */
	sap.ui.core.FocusHandler.prototype.getCurrentFocusedControlId = function(){
		return this.oCurrent;
	};

	/**
	 * Destroy method of the Focus Handler.
	 * It unregisters the event handlers.
	 *
	 * @param {jQuery.Event} event the event that initiated the destruction of the FocusHandler
	 * @private
	 */
	sap.ui.core.FocusHandler.prototype.destroy = function(event) {
		var oRootRef = event.data.oRootRef;
		if(oRootRef){
			if(oRootRef.removeEventListener && !jQuery.browser.msie){ //FF, Safari
				oRootRef.removeEventListener("focus", this.fEventHandler, true);
				oRootRef.removeEventListener("blur", this.fEventHandler, true);
			}else{ //IE
				jQuery(oRootRef).unbind("activate", this.fEventHandler);
				jQuery(oRootRef).unbind("deactivate", this.fEventHandler);
			}
		}
		jQuery(window).unbind("unload", this.fDestroyHandler);
		this.oCore = null;
	};

	/**
	 * Handles the focus/blur events.
	 *
	 * @param oRootRef e.g. document.body
	 * @private
	 */
	sap.ui.core.FocusHandler.prototype.onEvent = function(oBrowserEvent){
		var oEvent = jQuery.event.fix(oBrowserEvent);

		jQuery.sap.log.debug("Event "+oEvent.type+" reached Focus Handler (target: "+oEvent.target+(oEvent.target ? oEvent.target.id : "")+")", null, "sap.ui.core.FocusHandler");

		var type = (oEvent.type == "focus" || oEvent.type == "focusin" || oEvent.type == "activate") ? "focus" : "blur";
		this.aEventQueue.push({type:type, controlId: getControlIdForDOM(oEvent.target)});
		if(this.aEventQueue.length == 1) {
			this.processEvent();
		}
	};

	/**
	 * Processes the focus/blur events in the event queue.
	 *
	 * @private
	 */
	sap.ui.core.FocusHandler.prototype.processEvent = function(){
		var oEvent = this.aEventQueue[0];
		if(!oEvent) {
			return;
		}
		if(oEvent.type == "focus"){
			this.onfocusEvent(oEvent.controlId);
		}else if(oEvent.type == "blur"){
			this.onblurEvent(oEvent.controlId);
		}
		this.aEventQueue.shift();
		if(this.aEventQueue.length > 0) {
			this.processEvent();
		}
	};

	/**
	 * Processes the focus event taken from the event queue.
	 *
	 * @param sControlId Id of the event related control
	 * @private
	 */
	sap.ui.core.FocusHandler.prototype.onfocusEvent = function(sControlId){
		this.oCurrent = sControlId;
		triggerFocusleave(this.oLast, sControlId, this.oCore);
		this.oLast = null;
	};

	/**
	 * Processes the blur event taken from the event queue.
	 *
	 * @param sControlId Id of the event related control
	 * @private
	 */
	sap.ui.core.FocusHandler.prototype.onblurEvent = function(sControlId){
		this.oLast = sControlId;
		this.oCurrent = null;
		jQuery.sap.delayedCall(0, this, "checkForLostFocus");
	};

	/**
	 * Checks for lost focus and provides events in case of losing the focus.
	 * Called in delayed manner from {@link sap.ui.core.FocusHandler#onblurEvent}.
	 *
	 * @private
	 */
	sap.ui.core.FocusHandler.prototype.checkForLostFocus = function(){
		if(this.oCurrent == null && this.oLast != null){
			triggerFocusleave(this.oLast, null, this.oCore);
		}
		this.oLast = null;
	};


	//***********************************************************
	// Utility / convenience
	//***********************************************************

	/**
	 * Returns the id of the control/element to which the given DOM
	 * reference belongs to or <code>null</code> if no such
	 * control/element exists.
	 *
	 * @param {DOMObject} oDOM the DOM reference
	 * @private
	 */
	var getControlIdForDOM = function(oDOM){
		var sId = jQuery(oDOM).closest("[data-sap-ui]").attr("id");
		if(sId) {
			return sId;
		}
		return null;
	};

	/**
	 * Calls the onsapfocusleave function on the control with id sControlId
	 * with the information about the given related control.
	 *
	 * @param {string} sControlId
	 * @param {string} sRelatedControlId
	 * @private
	 */
	var triggerFocusleave = function(sControlId, sRelatedControlId, oCore){
		var oControl = sControlId ? sap.ui.getCore().byId(sControlId) : null;
		if(oControl){
			var oRelatedControl = sRelatedControlId ? sap.ui.getCore().byId(sRelatedControlId) : null;
			var oEvent = jQuery.Event("sapfocusleave");
			oEvent.target = oControl.getDomRef();
			oEvent.relatedControlId = oRelatedControl ? oRelatedControl.getId() : null;
			oEvent.relatedControlFocusInfo = oRelatedControl ? oRelatedControl.getFocusInfo() : null;
			//TODO: Cleanup the popup! The following is shit
			var oControlUIArea = oControl.getUIArea();
			var oUiArea = null;
			if(oControlUIArea){
				oUiArea = oCore.getUIArea(oControlUIArea.getId());
			}else{
				var oPopupUIAreaDomRef = sap.ui.getCore().getStaticAreaRef();
				if(jQuery.sap.containsOrEquals(oPopupUIAreaDomRef, oEvent.target)){
					oUiArea = oCore.getUIArea(oPopupUIAreaDomRef.id);
				}
			}
			if(oUiArea) {
				oUiArea._handleEvent(oEvent);
			}
		}
	};

	/**
	 * Checks if the passed DOM reference is nested in the active DOM of the document
	 * @param {DOMNode} oDomRef The new active element
	 * @private
	 * @type boolean
	 * @returns whether the passed DOM reference is nested in the active DOM of the document
	 */
	/*function isInActiveDom(oDomRef) {
		jQuery.sap.assert(oDomRef != null);
		var oCurrDomRef = oDomRef;
		while(oCurrDomRef) {
			if(oCurrDomRef === document) return true;
			oCurrDomRef = oCurrDomRef.parentNode;
		}
		return false;
	};*/

}());
}; // end of sap.ui.core.FocusHandler

if ( !jQuery.sap.isDeclared('sap.ui.core.ResizeHandler') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides class sap.ui.core.ResizeHandler
jQuery.sap.declare("sap.ui.core.ResizeHandler");




(function(){

	var oCoreRef = null;

	/**
	 * Constructs an instance of a sap.ui.core.ResizeHandler.
	 * Handles the resize event on registered DOM elements.
	 *
	 * Resize events on arbitrary DOM elements are not supported on Firefox and Safari.
	 * This class provides firing of resize events on Firefox by checking width
	 * and height of registered DOM elements and firing events accordingly.
	 *
	 * @class sap.ui.core.ResizeHandler
	 * @param oCore the core
	 */
	sap.ui.core.ResizeHandler = function(oCore) {
		sap.ui.base.Object.apply(this);

		oCoreRef = oCore;

		this.aResizeListeners = [];
		this.sInterval = null;

		this.iIdCounter = 0;

		this.fDestroyHandler = jQuery.proxy(this.destroy, this);

		jQuery(window).bind("unload", this.fDestroyHandler);
	};

	sap.ui.core.ResizeHandler.prototype = jQuery.sap.newObject(sap.ui.base.Object.prototype);
	sap.ui.base.Object.defineClass("sap.ui.core.ResizeHandler", {
		baseType : "sap.ui.base.Object"
	});

	/**
	 * The interval which is used for checking the width/height of all attached elements.
	 * One check takes less than 1 MICROsecond (maybe even *much* less - the only confirmed fact is that 20000 checks
	 * summed up are still not measurable), so a 200 ms interval is perfectly fine.
	 * @private
	 */
	sap.ui.core.ResizeHandler.prototype.I_INTERVAL = 200;

	/**
	 * Destroy method of the Resize Handler.
	 * It unregisters the event handlers.
	 *
	 * @param {jQuery.Event} oEvent the event that initiated the destruction of the ResizeHandler
	 * @private
	 */
	sap.ui.core.ResizeHandler.prototype.destroy = function(oEvent) {
		jQuery(window).unbind("unload", this.fDestroyHandler);
		if(jQuery.browser.msie && (jQuery.browser.version == "7.0" || jQuery.browser.version == "8.0")){
			jQuery.each(this.aResizeListeners, function(index, oResizeListener){
				jQuery(oResizeListener.oDomRef).unbind("resize", oResizeListener.fHandler);
			});
		}
		oCoreRef = null;
		this.aResizeListeners = [];
		this.sInterval = null;
	};

	/**
	 * Attaches listener to resize event.
	 *
	 * @param {element} oDomRef the DOM reference
	 * @param {function} fHandler the event handler function
	 * @return {string} Registration-ID for later detaching.
	 * @private
	 */
	sap.ui.core.ResizeHandler.prototype.attachListener = function(oDomRef, fHandler){
		var iWidth = oDomRef.offsetWidth,
		iHeight = oDomRef.offsetHeight,
		sId = "rs-" + new Date().valueOf() + "-" + this.iIdCounter++;

		this.aResizeListeners.push({sId: sId, oDomRef: oDomRef, fHandler: fHandler, iWidth: iWidth, iHeight: iHeight});

		if(jQuery.browser.msie && (jQuery.browser.version == "7.0" || jQuery.browser.version == "8.0")){
			jQuery(oDomRef).bind("resize", fHandler);
		}else{
			if(!this.sInterval){
				this.sInterval = jQuery.sap.delayedCall(this.I_INTERVAL, this, "checkSizes");
			}
		}
		return sId;
	};

	/**
	 * Detaches listener from resize event.
	 *
	 * @param {string} Registration-ID returned from attachListener
	 * @private
	 */
	sap.ui.core.ResizeHandler.prototype.detachListener = function(sId){
		var that = this;
		jQuery.each(this.aResizeListeners, function(index, oResizeListener){
			if(oResizeListener.sId == sId){
				that.aResizeListeners.splice(index,1);
				if(jQuery.browser.msie && (jQuery.browser.version == "7.0" || jQuery.browser.version == "8.0")){
					jQuery(oResizeListener.oDomRef).unbind("resize", oResizeListener.fHandler);
				}
				return false; //break the loop
			};
		});

		// if list is empty now, stop interval
		if(this.aResizeListeners.length == 0){
			jQuery.sap.clearDelayedCall(this.sInterval);
			this.sInterval = null;
		}
	};

	/**
	 * Check sizes of resize elements
	 * @private
	 */
	sap.ui.core.ResizeHandler.prototype.checkSizes = function() {
		jQuery.each(this.aResizeListeners, function(index, oResizeListener){
			if(oResizeListener){
				var oDomRef = oResizeListener.oDomRef;
				if (oDomRef.offsetWidth != oResizeListener.iWidth ||
						oDomRef.offsetHeight != oResizeListener.iHeight) {
					oResizeListener.iWidth = oDomRef.offsetWidth;
					oResizeListener.iHeight = oDomRef.offsetHeight;
					var oEvent = jQuery.Event("resize");
					oEvent.target = oResizeListener.oDomRef;
					oEvent.currentTarget = oResizeListener.oDomRef;
					oResizeListener.fHandler(oEvent);
				}
			}
		});
		this.sInterval = jQuery.sap.delayedCall(this.I_INTERVAL, this, "checkSizes");
	};

	/**
	 * Registers the given handler for resize events on the given
	 * DOM reference.
	 *
	 * @param {element} oDomRef the DOM reference for which the given handler should be registered (beside the window)
	 * @param {function} fHandler the handler which should be called on a resize event
	 * @return {string} Registration ID which can be used for deregistering
	 * @public
	 */
	sap.ui.core.ResizeHandler.register = function(oDomRef, fHandler) {
		if(!oCoreRef || !oCoreRef.oResizeHandler) {
			return null;
		}
		return oCoreRef.oResizeHandler.attachListener(oDomRef, fHandler);
	};

	/**
	 * Deregisters the registered handler for resize events with the given ID.
	 *
	 * @param {string} Registration ID
	 * @public
	 */
	sap.ui.core.ResizeHandler.deregister = function(sId) {
		if(!oCoreRef || !oCoreRef.oResizeHandler) {
			return;
		}
		oCoreRef.oResizeHandler.detachListener(sId);
	};

}());
}; // end of sap.ui.core.ResizeHandler

if ( !jQuery.sap.isDeclared('sap.ui.core.RenderManager') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides the render manager sap.ui.core.RenderManager
jQuery.sap.declare("sap.ui.core.RenderManager");

if ( !jQuery.sap.isDeclared('jquery.sap.encoder') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides encoding functions for JavaScript.
jQuery.sap.declare("jquery.sap.encoder", false);

(function(){

	/*
	 * Encoding according to the Secure Programming Guide
	 * https://wiki.wdf.sap.corp/wiki/display/NWCUIAMSIM/XSS+Secure+Programming+Guide
	 */

	/**
	 * Create hex and pad to length
	 * @private
	 */
	function hex(iChar, iLength) {
		var sHex = iChar.toString(16);
		if (iLength) {
			while (iLength > sHex.length) {
				sHex = "0" + sHex;
			}
		}
		return sHex;
	}

	/**
	 * RegExp and escape function for HTML escaping
	 */
	var rHtml = /[\x00-\x2b\x2f\x3a-\x40\x5b-\x5e\x60\x7b-\uffff]/g,
		rHtmlReplace = /[\x00-\x08\x0b\x0c\x0e-\x1f\x7f-\x9f]/,
		mHtmlLookup = {
			"<": "&lt;",
			">": "&gt;",
			"&": "&amp;",
			"\"": "&quot;"
		};

	var fHtml = function(sChar) {
		var sEncoded = mHtmlLookup[sChar];
		if (!sEncoded) {
			if (rHtmlReplace.test(sChar)) {
				sEncoded = "&#xfffd;";
			}
			else {
				sEncoded = "&#x" + hex(sChar.charCodeAt(0)) + ";";
			}
			mHtmlLookup[sChar] = sEncoded;
		}
		return sEncoded;
	};

	/**
	 * Encode the string for inclusion into HTML content/attribute
	 *
	 * @param {string} sString The string to be escaped
	 * @return The escaped string
	 * @type {string}
	 * @public
	 * @SecValidate {0|return|XSS} validates the given string for HTML contexts
	 */
	jQuery.sap.encodeHTML = function(sString) {
		return sString.replace(rHtml, fHtml);
	};

	/**
	 * Encode the string for inclusion into XML content/attribute
	 *
	 * @param {string} sString The string to be escaped
	 * @return The escaped string
	 * @type {string}
	 * @public
	 * @SecValidate {0|return|XSS} validates the given string for XML contexts
	 */
	jQuery.sap.encodeXML = function(sString) {
		return sString.replace(rHtml, fHtml);
	};

	/**
	 * Encode the string for inclusion into HTML content/attribute.
	 * Old name "escapeHTML" kept for backward compatibility
	 *
	 * @param {string} sString The string to be escaped
	 * @return The escaped string
	 * @type {string}
	 * @public
	 * @deprecated Has been renamed, use {@link jQuery.sap.encodeHTML} instead.
	 */
	jQuery.sap.escapeHTML = function(sString) {
		return sString.replace(rHtml, fHtml);
	};

	/**
	 * RegExp and escape function for JS escaping
	 */
	var rJS = /[\x00-\x2b\x2d\x2f\x3a-\x40\x5b-\x5e\x60\x7b-\uffff]/g,
		mJSLookup = {};

	var fJS = function(sChar) {
		var sEncoded = mJSLookup[sChar];
		if (!sEncoded) {
			var iChar = sChar.charCodeAt(0);
			if (iChar < 256) {
				sEncoded = "\\x" + hex(iChar, 2);
			}
			else {
				sEncoded = "\\u" + hex(iChar, 4);
			}
			mJSLookup[sChar] = sEncoded;
		}
		return sEncoded;
	};

	/**
	 * Encode the string for inclusion into a JS string literal
	 *
	 * @param {string} sString The string to be escaped
	 * @return The escaped string
	 * @type {string}
	 * @public
	 * @SecValidate {0|return|XSS} validates the given string for a JavaScript contexts
	 */
	jQuery.sap.encodeJS = function(sString) {
		return sString.replace(rJS, fJS);
	};

	/**
	 * Encode the string for inclusion into a JS string literal.
	 * Old name "escapeJS" kept for backward compatibility
	 *
	 * @param {string} sString The string to be escaped
	 * @return The escaped string
	 * @type {string}
	 * @public
	 * @deprecated Since 1.3.0. Has been renamed, use {@link jQuery.sap.encodeJS} instead.
	 */
	jQuery.sap.escapeJS = function(sString) {
		return sString.replace(rJS, fJS);
	};

	/**
	 * RegExp and escape function for URL escaping
	 */
	var rURL = /[\x00-\x29\x2b\x2c\x2f\x3a-\x40\x5b-\x5e\x60\x7b-\uffff]/g,
		mURLLookup = {};

	var fURL = function(sChar) {
		var sEncoded = mURLLookup[sChar];
		if (!sEncoded) {
			var iChar = sChar.charCodeAt(0);
			if (iChar < 128) {
				sEncoded = "%" + hex(iChar, 2);
			}
			else if (iChar < 2048) {
				sEncoded = "%" + hex((iChar >> 6) | 192, 2) +
						   "%" + hex((iChar & 63) | 128, 2);
			}
			else {
				sEncoded = "%" + hex((iChar >> 12) | 224, 2) +
						   "%" + hex(((iChar >> 6) & 63) | 128, 2) +
						   "%" + hex((iChar & 63) | 128, 2);
			}
			mURLLookup[sChar] = sEncoded;
		}
		return sEncoded;
	};

	/**
	 * Encode the string for inclusion into an URL parameter
	 *
	 * @param {string} sString The string to be escaped
	 * @return The escaped string
	 * @type {string}
	 * @public
	 * @SecValidate {0|return|XSS} validates the given string for a URL context
	 */
	jQuery.sap.encodeURL = function(sString) {
		return sString.replace(rURL, fURL);
	};

	/**
	 * RegExp and escape function for CSS escaping
	 */
	var rCSS = /[\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\uffff][0-9A-Fa-f]?/g;

	var fCSS = function(sChar) {
		var iChar = sChar.charCodeAt(0);
		if (sChar.length == 1) {
			return "\\" + hex(iChar);
		}
		else {
			return "\\" + hex(iChar) + " " + sChar.substr(1);
		}
	};

	/**
	 * Encode the string for inclusion into CSS string literals or identifiers
	 *
	 * @param {string} sString The string to be escaped
	 * @return The escaped string
	 * @type {string}
	 * @public
	 * @SecValidate {0|return|XSS} validates the given string for a CSS context
	 */
	jQuery.sap.encodeCSS = function(sString) {
		return sString.replace(rCSS, fCSS);
	};

	/**
	 * WhitelistEntry object
	 * @param {string} protocol The protocol of the URL
	 * @param {string} host The host of the URL
	 * @param {string} port The port of the URL
	 * @param {string} path the path of the URL
	 * @public
	 */
	function WhitelistEntry(protocol, host, port, path){
		if (protocol) {
			this.protocol = protocol.toUpperCase();
		}
		if (host) {
			this.host = host.toUpperCase();
		}
		this.port = port;
		this.path = path;
	}

	var aWhitelist = new Array();

	/**
	 * clears the whitelist for URL valiadtion
	 *
	 * @public
	 */
	jQuery.sap.clearUrlWhitelist = function() {

		aWhitelist.splice(0,aWhitelist.length);

	};

	/**
	 * Adds a whitelist entry for URL valiadtion
	 *
	 * @param {string} protocol The protocol of the URL
	 * @param {string} host The host of the URL
	 * @param {string} port The port of the URL
	 * @param {string} path the path of the URL
	 * @public
	 */
	jQuery.sap.addUrlWhitelist = function(protocol, host, port, path) {
		var oEntry = new WhitelistEntry(protocol, host, port, path);
		var iIndex = aWhitelist.length;
		aWhitelist[iIndex] = oEntry;
	};

	/**
	 * Removes a whitelist entry for URL valiadtion
	 *
	 * @param {int} iIndex index of entry
	 * @public
	 */
	jQuery.sap.removeUrlWhitelist = function(iIndex) {
		aWhitelist.splice(iIndex,1)
	};

	/**
	 * Gets the whitelist for URL valiadtion
	 *
	 * @return {string[]} whitelist
	 * @public
	 */
	jQuery.sap.getUrlWhitelist = function() {
		return aWhitelist.slice();
	};

	/**
	 * Validates an URL. Check if it's not a script or other security issue.
	 *
	 * @param {string} sUrl
	 * @return true if valid, false if not valid
	 * @public
	 */
	jQuery.sap.validateUrl = function(sUrl) {

		var result = /(?:([^:\/?#]+):)?(?:\/\/([^\/?#:]*)(?::([0-9]+))?)?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/.exec(sUrl);
		if (!result) {
			return result;
		}

		var sProtocol = result[1],
			sHost = result[2],
			sPort = result[3],
			sPath = result[4],
			sQuery = result[5],
			sHash = result[6];

		var rCheck = /[\x00-\x24\x26-\x29\x2b\x2c\x2f\x3a-\x40\x5b-\x5e\x60\x7b-\uffff]/;

		// protocol
		if (sProtocol) {
			sProtocol = sProtocol.toUpperCase();
			if (aWhitelist.length <= 0) {
				// no whitelist -> check for default protocols
				if (!/^(https?|ftp)/i.test(sProtocol)) {
					return false;
				}
			}
		}

		// Host -> whitelist + character check (TBD)
		if (sHost) {
			sHost = sHost.toUpperCase();
		}

		// Path -> split for "/" and check if forbidden characters exist
		if (sPath) {
			var aComponents = sPath.split("/");
			for ( var i = 0; i < aComponents.length; i++) {
				var bCheck = rCheck.test(aComponents[i]);
				if (bCheck) {
					// forbidden character found
					return false;
				}
			}
		}

		// query -> Split on & and = and check if forbidden characters exist
		if (sQuery) {
			var aComponents = sQuery.split("&");
			for ( var i = 0; i < aComponents.length; i++) {
				var iPos = aComponents[i].search("=");
				if (iPos != -1) {
					var sPart1 = aComponents[i].substring(0,iPos);
					var sPart2 = aComponents[i].substring(iPos+1);
					var bCheck1 = rCheck.test(sPart1);
					var bCheck2 = rCheck.test(sPart2);
					if (bCheck1 || bCheck2) {
						// forbidden character found
						return false;
					}
				}
			}
		}

		// hash
		if (sHash) {
			if (rCheck.test(sHash)) {
				// forbidden character found
				return false;
			}
		}

		//filter whitelist
		if (aWhitelist.length > 0) {
			var bFound = false;
			for(var i=0; i<aWhitelist.length; i++){
				jQuery.sap.assert(aWhitelist[i] instanceof WhitelistEntry, "whitelist entry type wrong");
				if (!sProtocol || !aWhitelist[i].protocol || sProtocol == aWhitelist[i].protocol) {
					// protocol OK
					var bOk = false;
					if (sHost && aWhitelist[i].host && /^\*/.test(aWhitelist[i].host)) {
						// check for wildcard search at begin
						var sHostEscaped = aWhitelist[i].host.slice(1).replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
						var rFilter = RegExp(sHostEscaped + "$");
						if (rFilter.test(sHost)) {
							bOk = true;
						}
					}else if (!sHost || !aWhitelist[i].host || sHost == aWhitelist[i].host){
						bOk = true;
					}
					if (bOk){
						// host OK
						if (!aWhitelist[i].port || sPort == aWhitelist[i].port) {
							// port OK
							if (aWhitelist[i].path && /\*$/.test(aWhitelist[i].path)) {
								// check for wildcard search at end
								var sPathEscaped = aWhitelist[i].path.slice(0,-1).replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
								var rFilter = RegExp("^"+sPathEscaped);
								if (rFilter.test(sPath)) {
									bFound = true;
								}
							} else if (!aWhitelist[i].path || sPath == aWhitelist[i].path) {
								// path OK
								bFound = true;
							}
						}
					}
				}
				if (bFound) {
					break;
				}
			}
			if (!bFound) {
				return bFound;
			}
		}

		return true;
	};

}());
}; // end of jquery.sap.encoder




/**
 * Creates an instance of the RenderManager.
 *
 * @class RenderManager that will take care for rendering Controls.
 *
 * The RenderManager will be available from the sap.ui.core.Core instance (available via <code>sap.ui.getCore()</code>).<br/>It
 * can be used to render Controls and Control-Trees.
 *
 * The convention for renderers belonging to some controls is the following:
 * <ul>
 * <li>for a Control e.g. <code>sap.ui.controls.InputField</code> there shall be </li>
 * <li>a renderer named <code>sap.ui.controls.InputFieldRenderer</code></li>
 * <ul>
 *
 * @see sap.ui.core.Core
 * @see sap.ui.getCore()
 *
 * @extends sap.ui.base.Object
 * @author Jens Pflueger
 * @version 1.5.0-SNAPSHOT
 * @constructor
 * @public
 */
sap.ui.core.RenderManager = function() {
	this.aBuffer = [];
	this.aRenderedControls = [];
	this.aStyleStack = [{}];
};
sap.ui.core.RenderManager.prototype = jQuery.sap.newObject(sap.ui.base.Object.prototype);

(function() {

	var aCommonMethods = ["renderControl", "write", "writeEscaped", "translate", "writeAcceleratorKey", "writeControlData",
						  "writeElementData", "writeAttribute", "writeAttributeEscaped", "addClass", "writeClasses",
						  "addStyle", "writeStyles", "writeAccessibilityState",
						  "getConfiguration", "getHTML"];
	var aNonRendererMethods = ["render", "flush", "destroy"];

	sap.ui.base.Object.defineClass("sap.ui.core.RenderManager", {
		baseType : "sap.ui.base.Object",
		publicMethods : aCommonMethods.concat(aNonRendererMethods)
	});

	/**
	 * Returns the public interface of the RenderManager which can be used by Renderers.
	 *
	 * @return {sap.ui.base.Interface} the interface
	 * @private
	 */
	sap.ui.core.RenderManager.prototype.getRendererInterface = function() {
		// see sap.ui.base.Object.getInterface for reference
		var oInterface = new sap.ui.base.Interface(this, aCommonMethods);
		this.getRendererInterface = jQuery.sap.getter(oInterface);
		return oInterface;
	};

}());


/**
 * Cleans up the resources associated with this instance.
 * After the instance has been destroyed, it must not be used anymore.
 * Applications should call this function if they don't need the instance any longer.
 *
 * @public
 */
sap.ui.core.RenderManager.prototype.destroy = function() {
	this.aBuffer = [];
	this.aRenderedControls = [];
	this.aStyleStack = [{}];
};

/**
 * Returns the configuration object
 * Shortcut for <code>sap.ui.getCore().getConfiguration()</code>
 * @return {sap.ui.core.Configuration} the configuration object
 * @public
 */
sap.ui.core.RenderManager.prototype.getConfiguration = function() {
	return sap.ui.getCore().getConfiguration();
};

/**
 * Returns the renderer class for a given control instance
 *
 * @param {sap.ui.core.Control} oControl the control that should be rendered
 * @return the renderer class for a given control instance
 * @public
 */
sap.ui.core.RenderManager.prototype.getRenderer = function(oControl) {
	jQuery.sap.assert(oControl && oControl instanceof sap.ui.core.Control, "oControl must be a sap.ui.core.Control");
	return sap.ui.core.RenderManager.getRenderer(oControl);
};

/**
 * Turns the given control into its HTML representation and appends it to the
 * rendering buffer.
 *
 * If the given control is undefined or null, then nothing is rendered.
 *
 * @param {sap.ui.core.Control} oControl the control that should be rendered
 * @public
 */
sap.ui.core.RenderManager.prototype.renderControl = function(oControl) {
	jQuery.sap.assert(!oControl || oControl instanceof sap.ui.core.Control, "oControl must be a sap.ui.core.Control or empty");
	// don't render a NOTHING
	if (!oControl) {
		return;
	}

	// create stack to determine rendered parent
	if (!this.aRenderStack) {
		this.aRenderStack = new Array();
	}
	// stop the measurement of parent
	if (this.aRenderStack && this.aRenderStack.length > 0) {
		jQuery.sap.perfMeasure.pause(this.aRenderStack[0]+"---renderControl");
	}
	this.aRenderStack.unshift(oControl.getId());
	// start performance measurement
	jQuery.sap.perfMeasure.start(oControl.getId()+"---renderControl","Rendering of "+oControl.getMetadata()._sClassName);

	//Remember the current buffer size to check later whether the control produced output
	var iBufferLength = this.aBuffer.length;

	var oControlStyles = {};
	if (oControl.aCustomStyleClasses && oControl.aCustomStyleClasses.length > 0) {
		oControlStyles.aCustomStyleClasses = oControl.aCustomStyleClasses; //cleared again in the writeClasses function
	}

	this.aStyleStack.push(oControlStyles);

	var oRenderer = this.getRenderer(oControl);

	// notify the behavior object that the controls will be detached from DOM
	if (oControl.bOutput) {
		var oEvent = jQuery.Event("BeforeRendering");
		// store the element on the event (aligned with jQuery syntax)
		oEvent.srcControl = oControl;
		oControl._handleEvent(oEvent);
	}

	// unbind any generically bound browser event handlers
	var aBindings = oControl.aBindParameters;
	if (aBindings && aBindings.length > 0) { // if we have stored bind calls...
		var jDomRef = jQuery(oControl.getDomRef());
		if (jDomRef && jDomRef[0]) { // ...and we have a DomRef
			for (var i = 0; i < aBindings.length; i++) {
				var oParams = aBindings[i];
				jDomRef.unbind(oParams.sEventType, oParams.fnProxy);
			}
		}
	}

	//Render the control using the RenderManager interface
	oRenderer.render(this.getRendererInterface(), oControl);

	this.aStyleStack.pop();

	//Remember the rendered control
	this.aRenderedControls.push(oControl);

	//Check whether the control has produced HTML
	oControl.bOutput = this.aBuffer.length != iBufferLength;

	// end performance measurement
	jQuery.sap.perfMeasure.end(oControl.getId()+"---renderControl");
	this.aRenderStack.shift();
	// resume the measurement of parent
	if (this.aRenderStack && this.aRenderStack.length > 0) {
		jQuery.sap.perfMeasure.resume(this.aRenderStack[0]+"---renderControl");
	}
};

/**
 * Renders the given {@link sap.ui.core.Control} and finally returns
 * the content of the rendering buffer.
 * Ensures the buffer is restored to the state before calling this method.
 *
 * @param {sap.ui.core.Control}
 *            oControl the Control whose HTML should be returned.
 * @return {string} the resulting HTML of the provided control
 * @deprecated Since version 0.15.0. Use <code>flush()</code> instead render content outside the rendering phase.
 * @public
 */
sap.ui.core.RenderManager.prototype.getHTML = function(oControl) {
	jQuery.sap.assert(oControl && oControl instanceof sap.ui.core.Control, "oControl must be a sap.ui.core.Control");

	var tmp = this.aBuffer;
	var aResult = this.aBuffer = [];
	this.renderControl(oControl);
	this.aBuffer = tmp;
	return aResult.join("");
};

(function() {

	//Returns the information of the current focus
	var storeCurrentFocus = function(){
		var oCore = sap.ui.getCore();

		// Store current focus
		var sFocusedControlId = oCore.getCurrentFocusedControlId(),
			oFocusInfo = null,
			oFocusedDomRef = null;

		if(sFocusedControlId){
			var oFocusedControl = oCore.getElementById(sFocusedControlId);
			if(oFocusedControl){
				oFocusInfo = oFocusedControl.getFocusInfo();
				oFocusedDomRef = oFocusedControl.getFocusDomRef();
			}
		}

		return {focusedControlId: sFocusedControlId, focusInfo: oFocusInfo, focusDomRef: oFocusedDomRef};
	};

	//Does everthing needed after the rendering (restore focus, calling "onAfterRendering", initialize event binding)
	var finalizeRendering = function(oRM, aRenderedControls, oStoredFocusInfo){
		// Notify the behavior object that the controls will be attached to DOM
		for (var i = 0, size = aRenderedControls.length; i < size; i++) {
			var oControl = aRenderedControls[i];
			if (oControl.bOutput) {
				var oEvent = jQuery.Event("AfterRendering");
				// store the element on the event (aligned with jQuery syntax)
				oEvent.srcControl = oControl;
				// start performance measurement
				jQuery.sap.perfMeasure.start(oControl.getId()+"---AfterRendering","AfterRendering of "+oControl.getMetadata()._sClassName);
				oControl._handleEvent(oEvent);
				// end performance measurement
				jQuery.sap.perfMeasure.end(oControl.getId()+"---AfterRendering");
			}
		}

		//finally restore focus
		try{
			if (oStoredFocusInfo && oStoredFocusInfo.focusedControlId) {
				var oFocusedControl = sap.ui.getCore().getElementById(oStoredFocusInfo.focusedControlId);
				if (oFocusedControl && oFocusedControl.getFocusDomRef() != oStoredFocusInfo.focusDomRef ) {
					oFocusedControl.applyFocusInfo(oStoredFocusInfo.focusInfo);
				}
			}
		}catch(e){
			jQuery.sap.log.warning("Problems while restore focus after rendering: " + e, null, oRM);
		}

		// Re-bind any generically bound browser event handlers (must happen after restoring focus to avoid focus event)
		for (var i = 0, size = aRenderedControls.length; i < size; i++) {
			var oControl = aRenderedControls[i],
				aBindings = oControl.aBindParameters;

			if (aBindings && aBindings.length > 0) { // if we have stored bind calls...
				var jDomRef = jQuery(oControl.getDomRef());
				if (jDomRef && jDomRef[0]) { // ...and we have a DomRef - TODO: this check should not be required right after rendering...
					for (var j = 0; j < aBindings.length; j++) {
						var oParams = aBindings[j];
						jDomRef.bind(oParams.sEventType, oParams.fnProxy);
					}
				}
			}
		}
	};


	/**
	 * Renders the content of the rendering buffer into the provided DOMNode.
	 *
	 * This function must not be called within control renderers.
	 *
	 * Usage:
	 * <pre>
	 * // Create a new instance of the RenderManager
	 * var rm = sap.ui.getCore().createRenderManager();
	 * // Use the writer API to fill the buffers
	 * rm.write(...);
	 * rm.renderControl(oControl);
	 * rm.write(...);
	 * ...
	 * //Finally flush the buffer into the provided DOM node (The current content is removed)
	 * rm.flush(oDomNode);
	 * // If the instance is not needed anymore, destroy it
	 * rm.destroy();
	 * </pre>
	 *
	 * @param {DOMNode} oTargetDomNode The node in the dom where the buffer should be flushed into.
	 * @param {boolean} bDoNotPreserve flag, whether to not preserve (true) the content or to preserve it (false).
	 * @param {boolean} bAppend flag, whether to append (true) or replace (false) the buffer of the target dom node.
	 * @public
	 */
	sap.ui.core.RenderManager.prototype.flush = function(oTargetDomNode, bDoNotPreserve, bAppend) {
		jQuery.sap.assert((typeof oTargetDomNode === "object") && (oTargetDomNode.ownerDocument == document), "oTargetDomNode must be a DOM element");
		if(this.bRendererMode){
			jQuery.sap.log.info("Flush must not be called from control renderers. Call ignored.", null, this);
			return;
		}

		// preserve HTML content before flushing HTML into target DOM node
		if (!bDoNotPreserve) {
			sap.ui.core.RenderManager.preserveContent(oTargetDomNode);
		}

		var oStoredFocusInfo = storeCurrentFocus();

		var vHTML = this._prepareHTML5(this.aBuffer.join("")); // Note: string might have been converted to a node list!

		if(this._fPutIntoDom){
			//Case when render function was called
			this._fPutIntoDom(oTargetDomNode, vHTML);
		}else{
			for(var i=0; i<this.aRenderedControls.length; i++){
				//TODO It would be enough to loop over the controls for which renderControl was initially called but for this
				//we have to manage an additional array. Rethink about later.
				var oldDomNode = this.aRenderedControls[i].getDomRef();
				if(oldDomNode && !sap.ui.core.RenderManager.isPreservedContent(oldDomNode)) {
					jQuery(oldDomNode).remove();
				}
			}
			if (!bAppend) {
				jQuery(oTargetDomNode).html(vHTML); // Put the HTML into the given DOM Node
			} else {
				jQuery(oTargetDomNode).append(vHTML); // Append the HTML into the given DOM Node
			}
		}

		if(jQuery.browser.safari && parseFloat(jQuery.browser.version) < 534.5){
			// in safari we must wait until the CSS are loaded and applied (fixed in Safari 5.1)
			var jDummy = jQuery("<div id=\"sap-ui-DummyCSSCheck\" class=\"sapUiCssCheck\" style=\"visibility:hidden;position:absolute;height:100px;width:100px;top:-150px;\"></div>");
			jQuery(document.body).append(jDummy);
			this._finalizeIfReady(this.aRenderedControls, oStoredFocusInfo);
		}else{
			finalizeRendering(this, this.aRenderedControls, oStoredFocusInfo);
		}

		this.aRenderedControls = [];
		this.aBuffer = [];
		this.aStyleStack = [{}];
	};

	/**
	 * Safari applies CSS files only after it finished rendering. So logic based on CSS property onAferRendering
	 * goes wrong. Therefore we have to wait until the CSS is applied before we call onAfterRendering.
	 * This is made using a dummy DIV and checking the border defined in Core global.CSS
	 * We repeat the check until it's OK and the call the onAfterRendering
	 * @private
	 */
	sap.ui.core.RenderManager.prototype._finalizeIfReady = function(aRenderedControls, oStoredFocusInfo){
		if((jQuery.sap.domById("sap-ui-DummyCSSCheck").offsetHeight - jQuery.sap.domById("sap-ui-DummyCSSCheck").clientHeight) == 20 ){
			//CSS loaded - fine
			jQuery.sap.byId("sap-ui-DummyCSSCheck").remove();
			finalizeRendering(this, aRenderedControls, oStoredFocusInfo);
		}else{
			//CSS still not loaded - try again
			jQuery.sap.delayedCall(1, this, "_finalizeIfReady", [aRenderedControls, oStoredFocusInfo]);
		}
	};

	/**
	 * Renders the given control to the provided DOMNode.
	 *
	 * If to control is already rendered in the provided DOMNode the DOM of the control is replaced. If the control
	 * is already rendered somewhere else the current DOM of the control is removed and the new DOM is appended
	 * to the provided DOMNode.
	 *
	 * This function must not be called within control renderers.
	 *
	 * @param {sap.ui.core.Control} oControl the Control that should be rendered.
	 * @param {DOMNode} oTargetDomNode The node in the dom where the result of the rendering should be inserted.
	 * @public
	 */
	sap.ui.core.RenderManager.prototype.render = function(oControl, oTargetDomNode) {
		jQuery.sap.assert(oControl && oControl instanceof sap.ui.core.Control, "oControl must be a control");
		jQuery.sap.assert(typeof oTargetDomNode === "object" && oTargetDomNode.ownerDocument == document, "oTargetDomNode must be a DOM element");
		if(this.bRendererMode){
			jQuery.sap.log.info("Render must not be called from control renderers. Call ignored.", null, this);
			return;
		}

		if(jQuery.browser.safari){
			// for Safari CSS bug append CSS class at the end
			if (!sap.ui.core.RenderManager.initialized) {
				jQuery.sap.includeStyleSheet(jQuery.sap.getModulePath("sap.ui.core.", "/") + "SafariCheck.css");
			}
			sap.ui.core.RenderManager.initialized = true;
		}

		// Reset the buffer before rendering
		this.aBuffer = [];

		// Retrieve the markup (the rendering phase)
		this.renderControl(oControl);

		// FIXME: MULTIPLE ROOTS
		// The implementation of this method doesn't support multiple roots for a control.
		// Affects all places where 'oldDomNode' is used
		this._fPutIntoDom = function(oTarget, vHTML){

			if(oControl && oTargetDomNode){

				var oldDomNode = oControl.getDomRef();
				if ( sap.ui.core.RenderManager.isPreservedContent(oldDomNode) ) {
					// use placeholder instead
					oldDomNode = jQuery.sap.byId("sap-ui-dummy-" + oControl.getId())[0] || oldDomNode;
				}
				var bNewTarget = oldDomNode && oldDomNode.parentNode != oTargetDomNode;

				var fAppend = function(){
					var jTarget = jQuery(oTargetDomNode);
					if(oTargetDomNode.innerHTML == ""){
						jTarget.html(vHTML);
					}else{
						jTarget.append(vHTML);
					}
				};

				if(bNewTarget){ //Control was rendered already and is now moved to different location

					if(!sap.ui.core.RenderManager.isPreservedContent(oldDomNode)) {
						jQuery(oldDomNode).remove();
					}

					if(vHTML) {
						fAppend();
					}

				}else{ //Control either rendered initially or rerendered at the same location

					if(vHTML){
						if(oldDomNode){
							jQuery(oldDomNode).replaceWith(vHTML);
						}else{
							fAppend();
						}
					}else{
						jQuery(oldDomNode).remove();
					}

				}

			}

		};

		this.flush(oTargetDomNode, true);

		this._fPutIntoDom = null;
	};

}());


//#################################################################################################
// Static Methods
//#################################################################################################

/**
 * Returns the renderer class for a given control instance
 *
 * @param {sap.ui.core.Control}
 *            oControl the control that should be rendered
 * @type function
 * @return the renderer class for a given control instance
 * @static
 * @public
 */
sap.ui.core.RenderManager.getRenderer = function(oControl) {
	jQuery.sap.assert(oControl && oControl instanceof sap.ui.core.Control, "oControl must be a sap.ui.core.Control");
	return oControl.getMetadata().getRenderer();
};

/**
 * Makes the HTML5 tags known to older IE browsers; to be called once before rendering happens.
 *
 * Applies two workarounds
 * <ol>
 * <li>1. "SHIV": create each HTML5 tag once in the window document to make IE8 aware of it
 * <li>2. "INNERSHIV": IE8 fails when using innerHTML in conjunction with HTML5 tags for a DOM element __not__ part of the document.
 *        _prepareHTML5 uses a dummy DOM element to convert the innerHTML to a set of DOM nodes first.
 * </ol>
 * @static
 * @private
 */
//Called once by the Core during initialization
sap.ui.core.RenderManager.initHTML5Support = function() {
	if(jQuery.browser.msie && (jQuery.browser.version === "8.0" || jQuery.browser.version === "7.0")){ // IE8 is recognized as "7.0"!!

		var aTags = [ "article", "aside", "audio", "canvas", "command", "datalist", "details",
				"figcaption", "figure", "footer", "header", "hgroup", "keygen", "mark", "meter", "nav",
				"output", "progress", "rp", "rt", "ruby", "section", "source", "summary", "time", "video", "wbr" ];

		// 1. SHIV, create each HTML5 element once to make IE8 recognize it
		// see http://paulirish.com/2011/the-history-of-the-html5-shiv/ for an explanation
		for (var i = 0; i < aTags.length; i++) {
			document.createElement(aTags[i]);
		}

		// 2. INNERSHIV, converts string with HTML5 tags to DOM nodes before using them with jQuery
		// see http://jdbartlett.com/innershiv/ for an explanation of the matter
		var rhtmltags = new RegExp("<(" + aTags.join("|") + ")(\\s|>)", "i");
		var d = null;
		sap.ui.core.RenderManager.prototype._prepareHTML5 = function(sHTML) {
			if ( sHTML && sHTML.match(rhtmltags) ) {
				if(!d){
					d = document.createElement('div');
					d.style.display = 'none';
				}

				var e = d.cloneNode(true);
				document.body.appendChild(e);
				e.innerHTML = sHTML.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
				document.body.removeChild(e);

				return e.childNodes;
			}
			return sHTML;
		};

		jQuery.sap.log.info("IE8 HTML5 support activated");

	}else{

		jQuery.sap.log.info("no IE8 HTML5 support required");

		sap.ui.core.RenderManager.prototype._prepareHTML5 = function(sHTML) {
			return sHTML;
		};
	}
};


//#################################################################################################
// Methods for preserving HTML content
//#################################################################################################

(function() {

	var ID_PRESERVE_AREA = "sap-ui-preserve";
	var ATTR_PRESERVE_MARKER = "data-sap-ui-preserve";

	function getPreserveArea() {
		var $preserve = jQuery("#"+ID_PRESERVE_AREA);
		if ($preserve.length === 0){
			$preserve = jQuery("<DIV/>",{role:"application",id:ID_PRESERVE_AREA}).
				addClass("sapUiHidden").
				appendTo(document.body);
		}
		return $preserve;
	}

	/**
	 * Collects descendants of the given root node that need to be preserved before the root node
	 * is wiped out. The "to-be-preserved" nodes are moved to a special, hidden 'preserve' area.
	 *
	 * A node is declared "to-be-preserved" when it has the <code>data-sap-ui-preserve</code>
	 * attribute set. When the optional parameter <code>bPreserveNodesWithId</code> is set to true,
	 * then nodes with an id are preserved as well and their <code>data-sap-ui-preserve</code> attribute
	 * is set automatically. This option is used by UIAreas when they render for the first time and
	 * simplifies the handling of predefined HTML content in a web page.
	 *
	 * The "to-be-preserved" nodes are searched with a depth first search and moved to the 'preserve'
	 * area in the order that they are found. So for direct siblings the order should be stable.
	 *
	 * @param {DOMNode} oRootNode to search for "to-be-preserved" nodes
	 * @param {boolean} [bPreserveRoot=false] whether to preserve the root itself
	 * @param {boolean} [bPreserveNodesWithId=false] whether to preserve nodes with an id as well
	 * @public
	 * @static
	 */
	sap.ui.core.RenderManager.preserveContent = function(oRootNode, bPreserveRoot, bPreserveNodesWithId) {
		jQuery.sap.assert(typeof oRootNode === "object" && oRootNode.ownerDocument == document, "oRootNode must be a DOM element");

		var $preserve = getPreserveArea();

		function check($candidates) {

			$candidates.each(function(i,candidate) {

				// don't process the preserve area
				if ( candidate.id === ID_PRESERVE_AREA ) {
					return;
				}

				var $candidate = jQuery(candidate);

				if ( $candidate.attr(ATTR_PRESERVE_MARKER) )  { // node is marked with the preserve marker
					// when the current node is the root node then we're doing a single control rerendering
					if ( candidate === oRootNode ) {
						var $placeholder = jQuery("<DIV/>", { id: "sap-ui-dummy-" + candidate.id}).addClass("sapUiHidden");
						$placeholder.insertBefore($candidate);
					}
					$preserve.append($candidate);
				} else if ( bPreserveNodesWithId && candidate.id ) {
					sap.ui.core.RenderManager.markPreservableContent($candidate, candidate.id);
					$preserve.append($candidate);
					return;
				}

				// don't dive into nested UIAreas. They are preserved together with any preserved parent (e.g. HTML control)
				if ( !$candidate.attr("data-sap-ui-area") ) {
					check($candidate.children());
				}
			});
		}

		var t0 = new Date().getTime();
		check(bPreserveRoot? jQuery(oRootNode) : jQuery(oRootNode).children());
		var t1 = new Date().getTime();
		jQuery.sap.log.debug("preserveContent took " + (t1-t0) + " ms");
	};

	/**
	 * Searches "to-be-preserved" nodes for the given control id.
	 *
	 * @param {string} sId control id to search content for.
	 * @return {jQuery} a jQuery collection representing the found content
	 * @public
	 * @static
	 */
	sap.ui.core.RenderManager.findPreservedContent = function(sId) {
		jQuery.sap.assert(typeof sId === "string", "sId must be a string");
		var $preserve = getPreserveArea(),
			$content = $preserve.children("[" + ATTR_PRESERVE_MARKER + "='" + sId.replace(/(:|\.)/g,'\\$1') + "']");
		return $content;
	};

	/**
	 * Marks the given content as "to-be-preserved" for a control with the given id.
	 * When later on the content has been preserved, it can be found by giving the same id.
	 *
	 * @param {jQuery} $content a jQuery collection of DOM objects to be marked
	 * @param {string} sId id of the control to associate the content with
	 * @static
	 */
	sap.ui.core.RenderManager.markPreservableContent = function($content, sId) {
		$content.attr(ATTR_PRESERVE_MARKER, sId);
	};

	/**
	 * Checks whether the given DOM node is part of the 'preserve' area.
	 *
	 * @param {DOMNode} oDomNode
	 * @return {boolean} whether node is part of 'preserve' area
	 * @private
	 * @static
	 */
	sap.ui.core.RenderManager.isPreservedContent = function(oDomNode) {
		return ( oDomNode && oDomNode.getAttribute(ATTR_PRESERVE_MARKER) && oDomNode.parentNode && oDomNode.parentNode.id == ID_PRESERVE_AREA );
	};

	/**
	 * Returns the hidden area reference belonging to this window instance.
	 *
	 * @return {DOMNode}the hidden area reference belonging to this core instance.
	 * @public
	 * @static
	 */
	sap.ui.core.RenderManager.getPreserveAreaRef = function() {
		return getPreserveArea()[0];
	};

}());


//#################################################################################################
// Methods for 'Buffered writer' functionality... (all public)
// i.e. used methods in render-method of Renderers
//#################################################################################################

/**
 * Write the given texts to the buffer
 * @param {string|number ...} sText (can be a number too)
 * @return {sap.ui.core.RenderManager} this render manager instance to allow chaining
 * @public
 * @SecSink {*|XSS}
 */
sap.ui.core.RenderManager.prototype.write = function(/** string|number */ sText /* ... */) {
	jQuery.sap.assert(( typeof sText === "string") || ( typeof sText === "number"), "sText must be a string or number");
	this.aBuffer.push.apply(this.aBuffer, arguments);
	return this;
};

/**
 * Escape text for HTML and write it to the buffer
 * @param {string} sText
 * @param {boolean} bLineBreaks Whether to convert linebreaks into <br> tags
 * @return {sap.ui.core.RenderManager} this render manager instance to allow chaining
 * @public
 */
sap.ui.core.RenderManager.prototype.writeEscaped = function(/** string */ sText, bLineBreaks) {
	jQuery.sap.assert( typeof sText === "string", "sText must be a string");
	if (bLineBreaks) {
		var aLines = sText.split("\n");
		for (var i = 0; i < aLines.length; i++) {
			aLines[i] = jQuery.sap.encodeHTML(aLines[i]);
		}
		sText = aLines.join("<br>");
	} else {
		sText = jQuery.sap.encodeHTML(sText);
	}
	this.aBuffer.push(sText);
	return this;
};


/**
 * @deprecated Not implemented - DO NOT USE
 * @public
 */
sap.ui.core.RenderManager.prototype.translate = function(/** string */ sKey) {
	// TODO
};

/**
 * @deprecated Not implemented - DO NOT USE
 * @return {sap.ui.core.RenderManager} this render manager instance to allow chaining
 * @public
 */
sap.ui.core.RenderManager.prototype.writeAcceleratorKey = function() {
	/*
	if (bAlt && !bCtrl && !bArrowKey) {
		// Keyboard helper provides means for visualizing access keys.
		// keydown modifies some CSS rule for showing underlines
		// <span><u class="sapUiAccessKey">H</u>elp me</span>
		UCF_KeyboardHelper.showAccessKeys();
	}
	*/
	return this;
};

/**
 * Adds a style property to the style collection if the value is not empty or null
 * The style collection is flushed if it is written to the buffer using {@link #writeStyle}
 *
 * @param {string} sName name of the CSS property to write
 * @param {string} sValue value to write
 * @return {sap.ui.core.RenderManager} this render manager instance to allow chaining
 * @public
 * @SecSink {0 1|XSS} Styles are written to HTML without validation
 */
sap.ui.core.RenderManager.prototype.addStyle = function(sName, sValue) {
	jQuery.sap.assert(typeof sName === "string", "sName must be a string");
	if (sValue) {
		jQuery.sap.assert(typeof sValue === "string", "sValue must be a string");
		var oStyle = this.aStyleStack[this.aStyleStack.length-1];
		if (!oStyle.aStyle) {
			oStyle.aStyle = [];
		}
		oStyle.aStyle.push(sName + ":" + sValue);
	}
	return this;
};

/**
 * Writes and flushes the style collection
 * @return {sap.ui.core.RenderManager} this render manager instance to allow chaining
 * @public
 */
sap.ui.core.RenderManager.prototype.writeStyles = function() {
	var oStyle = this.aStyleStack[this.aStyleStack.length-1];
	if (oStyle.aStyle) {
		this.write(" style=\"" +oStyle.aStyle.join(";") +"\" ");
	}
	oStyle.aStyle = null;
	return this;
};

/**
 * Adds a class to the class collection if the name is not empty or null.
 * The class collection is flushed if it is written to the buffer using {@link #writeClasses}
 *
 * @param {string} sName name of the class to be added; null values are ignored
 * @return {sap.ui.core.RenderManager} this render manager instance to allow chaining
 * @public
 * @SecSink {0|XSS} Classes are written to HTML without validation
 */
sap.ui.core.RenderManager.prototype.addClass = function(sName) {
	if (sName) {
		jQuery.sap.assert(typeof sName === "string", "sName must be a string");
		var oStyle = this.aStyleStack[this.aStyleStack.length-1];
		if (!oStyle.aClasses) {
			oStyle.aClasses = [];
		}
		oStyle.aClasses.push(sName);
	}
	return this;
};

/**
 * Writes and flushes the class collection (all CSS classes added by "addClass()" since the last flush).
 * Also writes the custom style classes added by the application with "addStyleClass(...)". Custom classes are
 * added by default from the currently rendered control. If an oElement is given, this Element's custom style
 * classes are added instead. If oElement === false, no custom style classes are added.
 *
 * @param {sap.ui.core.Element | boolean} [oElement] an Element from which to add custom style classes (instead of adding from the control itself)
 * @return {sap.ui.core.RenderManager} this render manager instance to allow chaining
 * @public
 */
sap.ui.core.RenderManager.prototype.writeClasses = function(oElement) {
	jQuery.sap.assert(!oElement || typeof oElement === "boolean" || oElement instanceof sap.ui.core.Element, "oElement must be empty, a boolean, or a sap.ui.core.Element");
	var oStyle = this.aStyleStack[this.aStyleStack.length-1];

	// Custom classes are added by default from the currently rendered control. If an oElement is given, this Element's custom style
	// classes are added instead. If oElement === false, no custom style classes are added.
	var aCustomClasses = oElement ? oElement.aCustomStyleClasses : ((oElement === false) ? [] : oStyle.aCustomStyleClasses);

	if (oStyle.aClasses || aCustomClasses) {
		var aClasses = [].concat(oStyle.aClasses || [], aCustomClasses || []);
		aClasses.sort();
		aClasses = jQuery.map(aClasses, function(n, i){
			return (i==0 || n != aClasses[i-1]) ? n : null;
		});
		this.write(" class=\"", aClasses.join(" "), "\" "); 
	}
	
	if (!oElement) {
		oStyle.aCustomStyleClasses = null;
	}
	oStyle.aClasses = null;
	return this;
};

/**
 * Writes the controls data into the HTML.
 * Control Data consists at least of the id of a control
 * @param {sap.ui.core.Control} oControl the control whose identifying information should be written to the buffer
 * @return {sap.ui.core.RenderManager} this render manager instance to allow chaining
 * @public
 */
sap.ui.core.RenderManager.prototype.writeControlData = function(oControl) {
	jQuery.sap.assert(oControl && oControl instanceof sap.ui.core.Control, "oControl must be a sap.ui.core.Control");
	this.writeElementData(oControl);
	return this;
};

/**
 * Writes the elements data into the HTML.
 * Element Data consists at least of the id of a element
 * @param {sap.ui.core.Element} oElement the element whose identifying information should be written to the buffer
 * @return {sap.ui.core.RenderManager} this render manager instance to allow chaining
 * @public
 */
sap.ui.core.RenderManager.prototype.writeElementData = function(oElement) {
	jQuery.sap.assert(oElement && oElement instanceof sap.ui.core.Element, "oElement must be a sap.ui.core.Element");
	var sId = oElement.getId();
	if(sId) {
		this.writeAttribute("id", sId).writeAttribute("data-sap-ui", sId);
	}
	return this;
};

/**
 * Writes the attribute and its value into the HTML
 * @param {string} sName the name of the attribute
 * @param {string | number | boolean} sValue the value of the attribute
 * @return {sap.ui.core.RenderManager} this render manager instance to allow chaining
 * @public
 * @SecSink {0 1|XSS} Attributes are written to HTML without validation
 */
sap.ui.core.RenderManager.prototype.writeAttribute = function(sName, value) {
	jQuery.sap.assert(typeof sName === "string", "sName must be a string");
	jQuery.sap.assert(typeof value === "string" || typeof value === "number" || typeof value === "boolean", "value must be a string, number or boolean");
	this.write(" ", sName, "=\"", value, "\"");
	return this;
};

/**
 * Writes the attribute and its value into the HTML
 * @param sName the name of the attribute
 * @param sValue the value of the attribute
 * @return {sap.ui.core.RenderManager} this render manager instance to allow chaining
 * @public
 * @SecSink {0|XSS}
 */
sap.ui.core.RenderManager.prototype.writeAttributeEscaped = function(sName, sValue) {
	// writeAttribute asserts
	this.writeAttribute(sName, jQuery.sap.escapeHTML(sValue));
	return this;
};

/**
 * Writes the accessibility state (see ARIA spec) of the provided control into the HTML.
 *
 * @param {sap.ui.core.Control}
 *            oControl the control whose accessibility state (see ARIA spec)
 *            should be rendered
 * @param {Object}
 *            [mProps] a map of properties that should be added additionally.
 *            'aria-' will be prepended to the provided property names (passed as
 *            keys).
 * @return {sap.ui.core.RenderManager} this render manager instance to allow chaining
 * @public
 * @deprecated Do not use yet, prototype implementation for testing purposes.
 *             Will be moved to utility / helper class.
 */
sap.ui.core.RenderManager.prototype.writeAccessibilityState = function(oControl, mProps) {
	if(arguments.length == 1 && !(oControl instanceof sap.ui.core.Control)) {
		mProps = oControl;
		oControl = null;
	}
	var aARIAStates = [""];
	if(oControl != null) {
		var mMetaProps = oControl.getMetadata().getAllProperties();
		for(var p in mMetaProps){
			switch(p){
			case "editable":
				if(oControl.getProperty(p) === false) {
					aARIAStates.push("aria-readonly=\"true\"");
				}
				break;
			case "enabled":
				if(oControl.getProperty(p) === false) {
					aARIAStates.push("aria-disabled=\"true\"");
				}
				break;
			case "visible":
				if(oControl.getProperty(p) === false) {
					aARIAStates.push("aria-hidden=\"true\"");
				}
				break;
			case "required":
				if(oControl.getProperty(p) === true) {
					aARIAStates.push("aria-required=\"true\"");
				}
				break;
			case "selected": // E.g. Tab
				if(oControl.getProperty(p) === true) {
					aARIAStates.push("aria-selected=\"true\"");
				}
				break;
			case "checked": // E.g. CheckBox
				if(oControl.getProperty(p) === true) {
					aARIAStates.push("aria-checked=\"true\"");
				}
				break;
//			case "ARIA_and_SAPUI5_do_not_perfectly_fit_to_eachother":
//				eval("Think about what now? Food for thought: RadioButton has selected but must provide checked :(
//					  We might think about introducing some special accessbility callback in the controls (like LS does)
//					  to get those things handled... but what about generic functionality like the one above?
//					  Some kind of mapping could also be interesting, couldn't it");
//				break;
			}
		}
	}
	var aTmp = [];
	for(var p in mProps) {
		aTmp.push("aria-");
		aTmp.push(p);
		aTmp.push("=\"");
		aTmp.push(mProps[p]);
		aTmp.push("\" ");
	}
	aARIAStates.push(aTmp.join(""));

	this.write(aARIAStates.join(" "));
	return this;
};
}; // end of sap.ui.core.RenderManager

if ( !jQuery.sap.isDeclared('sap.ui.core.UIArea') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// Provides class sap.ui.core.UIArea
jQuery.sap.declare("sap.ui.core.UIArea");
if ( !jQuery.sap.isDeclared('jquery.sap.ui') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2012 SAP AG. All rights reserved
 */

// A bridge between the jQuery.sap plugin and the SAPUI5 Core
jQuery.sap.declare("jquery.sap.ui", false);

//jQuery.sap.require("sap.ui.core.Core"); // cyclic

// !!!!!!!!!!!!!!!!!!!!!!!!!!
// !!     EXPERIMENTAL     !!
// !!!!!!!!!!!!!!!!!!!!!!!!!!
(function() {

	// FIXME Too tough or just right?
	if(!jQuery.sap) {
		throw "Initialisation of jQuery.sap.ui failed. jQuery.sap plugin required!";
	}
	if(!window.sap || !window.sap.ui) {
		jQuery.sap.fatal("Initialisation of jQuery.sap.ui failed. Global SAP UI namespace required!");
	}

	//ensure not to initialize twice
	if(jQuery.sap.ui) {
		return;
	}

//	/**
//	 * Root Namespace for the jQuery UI-Layer plugin provided by SAP AG.
//	 *
//	 * @version 1.5.0-SNAPSHOT
//	 * @namespace
//	 * @public
//	 */
//	jQuery.sap.ui = {};

	function fUIAreaFilter(idx){
		return sap.ui.getCore().getUIArea(this.id) != null;
	}
	function fgetUIArea(idx, odomref){
		return sap.ui.getCore().getUIArea(this.id);
	}
	function fgetUIAreaOfCtrl(oCtrl, idx){
		return oCtrl.getUIArea().getInterface();
	}

	/**
	 * @public
	 * @author SAP AG
	 */
	jQuery.fn.root = function(oRootControl) {
		var tmp;
		// handle 'setRoot'
		if(oRootControl) {
			sap.ui.getCore().setRoot(this.get(0), oRootControl);
			return this;
		}
		// and 'getRoot' behavior.
		var aControls = this.control();
		if (aControls.length > 0) {
			return jQuery.map(aControls, fgetUIAreaOfCtrl);
		}

		var aUIAreas = this.uiarea();

		if (aUIAreas.length > 0) {
			// we have UIAreas
			return aUIAreas;
		}

		// create UIAreas
		this.each(function(idx){
			sap.ui.getCore().createUIArea(this);
		});
		return this;
	};

	/**
	 * @public
	 */
	jQuery.fn.uiarea = function(iIdx) {
		// UIAreas need to have IDs... so reduce to those elements first
		var aUIAreas = this.slice("[id]").filter(fUIAreaFilter).map(fgetUIArea).get();
		return typeof(iIdx) === "number"?aUIAreas[iIdx]:aUIAreas;
	};

	/**
	 * Function identifying the closest SAPUI5 Control in the given jQuery context (provided via jQuery.map method).
	 * @private
	 */
	function fgetControl() {
		// as with jQuery 1.4.3 and 1.4.4 there is a big problem here, we increase checks here
		if(!this || !this.nodeType || this.nodeType === 9) {
			return null;
		} // in this case, we are on the HTML Document and cannot do anything
		// in IE8 'closest' might fail (e.g. when the element is not in the current document tree)
		// The following line would probably also work for the 'try-catch' below but induce performance penalty in EVERY call of this method.
		// if(jQuery(document.documentElement).has(this)) {
		try{
			var sId = jQuery(this).closest("[data-sap-ui]").attr("id");
			return sId ? sap.ui.getCore().byId(sId) : null;
		} catch(e){
			// probably IE8 case where element is not in current document tree... ==> there is no current control
			return null;
		}
	}

	/**
	 * Extension function to the jQuery.fn which identifies SAPUI5 controls in the given jQuery context.
	 *
	 * @param {integer} [idx] optional parameter to return the control instance at the given idx's position in the array.
	 * @methodOf jQuery.prototype
	 * @returns {sap.ui.core.Control[] | sap.ui.core.Control | null} depending on the given context and idx parameter an array of controls, an instance or null.
	 * @public
	 */
	jQuery.fn.control = function(idx) {
		var aControls = this.map(fgetControl);
		if(idx === undefined || isNaN(idx)) {
			return aControls.get();
		}
		else {
			return aControls.get(idx);
		}
	};


	/**
	 * EXPERIMENTAL!!
	 * Creates a new control of the given type and places it into the first DOM object of the jQuery collection.
	 * The type string is case sensitive.
	 *
	 * @param {string} sControlType the control type (fully qualified, like "sap.ui.dev.GoogleMap"; if no package is given, the package "sap.ui.commons" is assumed)
	 * @param {string} [sId] optional id for the new control; generated automatically if no non-empty id is given
	 * @param {object} [oConfiguration] optional map/JSON-object with initial values for the new control
	 * @returns {jQuery} the given jQuery object
	 * @private
	 */
	jQuery.fn.sapui = function(sControlType, sId, oConfiguration) {

		return this.each(function() { // TODO: hack for Steffen; (point is not clear, as this adds identical controls to many DOM elements...); remove soon

			var oControl = null;
			if (this) {
				// allow omitting the package prefix because this looks less Java-like...  sap.ui.commons is the default package
				if (sControlType.indexOf(".") == -1)  {
					sControlType = "sap.ui.commons." + sControlType;
				}

				// instantiate the control
				var fnClass = jQuery.sap.getObject(sControlType);
				if (fnClass) {

					// TODO: hack for Steffen; remove later
					if(typeof oConfiguration == 'object' && typeof oConfiguration.press == 'function') {
			  oConfiguration.press = jQuery.proxy(oConfiguration.press,this);
			}

					oControl = new (fnClass)(sId, oConfiguration); // sId might actually contain oConfiguration, the Element constructor will take care of this

					// placeAt first DomRef in collection
					oControl.placeAt(this);
					// TODO: avoid the direct call to applyChanges() in favor of a delayed version that potentially bundles several changes
					//sap.ui.getCore().applyChanges();
				}
			}

		});
	};

}());
}; // end of jquery.sap.ui




/**
 * @class An area in a page that hosts a tree of UI elements.
 *
 * Provides means for event-handling, rerendering, etc.
 *
 * @extends sap.ui.base.EventProvider
 * @author Daniel Brinkmann, Martin Schaus
 * @version 1.5.0-SNAPSHOT
 * @param {sap.ui.Core}
 *            oCore internal API of the <core>Core</code> that manages this UIArea
 * @param {object}
 *            [oRootNode] reference to the Dom Node that should be 'hosting' the UI Area.
 * @public
 */
sap.ui.core.UIArea = function(oCore, oRootNode) {
	if(arguments.length === 0) {
		return;
	}
	sap.ui.base.EventProvider.apply(this);

	//TODO we could get rid of oCore here, if we wanted to...
	this.oCore = oCore;
	this.bLocked = false;
	this.bInitial = true;
	this.aContentToRemove = [];
	this.oModels = {};
	this.iSuppressInvalidate = 0;

	this.mAggregations = {}; //Use the aggregation functionality of sap.ui.core.Element

	this.bNeedsRerendering = false;
	if (oRootNode != null) {
		this.setRootNode(oRootNode);
		// Figure out whether UI Area is pre-rendered (server-side JS rendering)!
		this.bNeedsRerendering = this.bNeedsRerendering && !jQuery.sap.domById(oRootNode.id + "-Init");
	}
	this.mInvalidatedControls = {};

	if(!this.bNeedsRerendering) {
		this.oRenderControl = null;
	} else {
		// Core needs to be notified about an invalid UIArea
		this.oCore.addInvalidatedUIArea(this);
	}

};
sap.ui.core.UIArea.prototype = jQuery.sap.newObject(sap.ui.base.EventProvider.prototype);
sap.ui.base.Object.defineClass("sap.ui.core.UIArea", {
		// ---- object ----
		baseType : "sap.ui.base.EventProvider",
		publicMethods : ["getId", "setRootNode", "getRootNode", "setRootControl", "getRootControl", "getContent", "insertContent", "addContent", "removeContent", "removeAllContent", "indexOfContent", "destroyContent", "lock", "unlock", "isLocked", "getSavedContent", "setModel", "getModel", "hasModel"]
	});

sap.ui.core.UIArea.M_EVENTS = {};

// UIArea has no metadata, so we have to implement the validation on our own
// TODO create common baseclass for UIArea and Element (and maybe Core)
sap.ui.core.UIArea.prototype.validateAggregation = function (sAggregationName, oElement, bMultiple) {
	if ( sAggregationName != "content" ) {
		throw new Error("Aggregation \"" + sAggregationName + "\" does not exist in " + this);
	}
	// TODO should this be part of the validation (raise an error) or not?
	jQuery.sap.assert(bMultiple, "Aggregation 'content' of " + this + " used with wrong cardinality (declared as \"0..n\")");
	if ( !(oElement instanceof sap.ui.core.Control) ) {
		throw new Error("\"" + oElement + "\" is not valid for aggregation \"content\" of " + this);
	}
	return oElement; 
};
//Use the remaining aggregation functionality of sap.ui.core.Element
sap.ui.core.UIArea.prototype.getAggregation = sap.ui.core.Element.prototype.getAggregation;
sap.ui.core.UIArea.prototype.insertAggregation = sap.ui.core.Element.prototype.insertAggregation;
sap.ui.core.UIArea.prototype.addAggregation = sap.ui.core.Element.prototype.addAggregation;
sap.ui.core.UIArea.prototype.removeAggregation = sap.ui.core.Element.prototype.removeAggregation;
sap.ui.core.UIArea.prototype.removeAllAggregation = sap.ui.core.Element.prototype.removeAllAggregation;
sap.ui.core.UIArea.prototype.indexOfAggregation = sap.ui.core.Element.prototype.indexOfAggregation;
sap.ui.core.UIArea.prototype.destroyAggregation = sap.ui.core.Element.prototype.destroyAggregation;

/**
 * Returns whether rerendering is currently suppressed on this UIArea
 * @return boolean
 * @protected
 */
sap.ui.core.UIArea.prototype.isInvalidateSuppressed = function() {
	return this.iSuppressInvalidate > 0;
};

/**
 * Returns this <code>UIArea</code>'s id (as determined from provided RootNode).
 * @return {string} id of this UIArea
 * @public
 *
 * TODO what is this needed for? ID can change and getRootNode() is also there...
 * Is this part of "UI area is like an Element" contract?
 */
sap.ui.core.UIArea.prototype.getId = function() {
	return this.oRootNode ? this.oRootNode.id : null;
};

/**
 * Returns this UI area. Needed to stop recursive calls from an element to its parent.
 *
 * @return {sap.ui.core.UIArea} this
 * @protected
 */
sap.ui.core.UIArea.prototype.getUIArea = function() {
	return this;
};

/**
 * Allows setting the Root Node hosting this instance of <code>UIArea</code>.<br/> The Dom Ref must have an Id that
 * will be used as Id for this instance of <code>UIArea</code>.
 *
 * @param {object}
 *            oRootNode the hosting Dom Ref for this instance of <code>UIArea</code>.
 * @public
 */
sap.ui.core.UIArea.prototype.setRootNode = function(oRootNode) {
	if(this.oRootNode === oRootNode) {
		return;
	}

	// oRootNode must either be empty or must be a DOMElement and must not be root node of some other UIArea
	jQuery.sap.assert(!oRootNode || (oRootNode.nodeType === 1 && !jQuery(oRootNode).attr("data-sap-ui-area")), "UIArea root node must be a DOMElement");

	//TODO IS there something missing
	if(this.oRootNode) {
		this._ondetach();
	}

	this.oRootNode = oRootNode;
	if ( this.getContent().length > 0 ) {
	  this.invalidate();
	}

	if(this.oRootNode) {
		// prepare eventing
		this._onattach();
	}
};

/**
 * Returns the Root Node hosting this instance of <code>UIArea</code>.
 *
 * @return {DOMNode} the Root Node hosting this instance of <code>UIArea</code>.
 * @public
 */
sap.ui.core.UIArea.prototype.getRootNode = function() {
	return this.oRootNode;
};

/**
 * Sets the root control to be displayed in this UIArea.
 *
 * First, all old content controls (if any) will be detached from this UIArea (e.g. their parent
 * relationship to this UIArea will be cut off). Then the parent relationship for the new
 * content control (if not empty) will be set to this UIArea and finally, the UIArea will
 * be marked for re-rendering.
 *
 * The real re-rendering happens whenever the re-rendering is called. Either implicitly
 * at the end of any control event or by calling sap.ui.getCore().applyChanges().
 *
 * @param {sap.ui.base.Interface | sap.ui.core.Control}
 *            oRootControl the Control that should be the Root for this <code>UIArea</code>.
 * @public
 * @deprecated use functions <code>removeAllContent</code> and <code>addContent</code> instead
 */
sap.ui.core.UIArea.prototype.setRootControl = function(oRootControl) {
	this.removeAllContent();
	this.addContent(oRootControl);
};

/**
 * Returns the content control of this <code>UIArea</code> at the specified index.
 * If no index is given the first content control is returned.
 *
 * @param {int} idx index of the control in the content of this <code>UIArea</code>
 * @return {sap.ui.core.Control} the content control of this <code>UIArea</code> at the specified index.
 * @public
 * @deprecated use function <code>getContent</code> instead
 */
sap.ui.core.UIArea.prototype.getRootControl = function(idx) {
	var aContent = this.getContent();
	if(aContent.length > 0){
		if(idx >=0 && idx < aContent.length) {
			return aContent[idx];
		}
		return aContent[0];
	}
	return null;
};

sap.ui.core.UIArea.prototype._addRemovedContent = function(oDomRef) {
	if(this.oRootNode && oDomRef) {
		this.aContentToRemove.push(oDomRef);
	}
};

/**
 * Getter for aggregation <code>content</code>.<br/>
 *
 * @return {sap.ui.core.Control[]}
 * @public
 */
sap.ui.core.UIArea.prototype.getContent = function() {
	return this.getAggregation("content", []);
};

/**
 * Inserts a content into the aggregation named <code>content</code>.
 *
 * @param {sap.ui.core.Control}
 *          oContent the content to insert; if empty, nothing is inserted
 * @param {int}
 *			iIndex the <code>0</code>-based index the content should be inserted at; for
 *             a negative value of <code>iIndex</code>, the content is inserted at position 0; for a value
 *             greater than the current size of the aggregation, the content is inserted at
 *             the last position
 * @return {sap.ui.core.UIArea} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.core.UIArea.prototype.insertContent = function(oContent, iIndex) {
	this.insertAggregation("content", oContent, iIndex);
	return this;
};

/**
 * Adds some content <code>oContent</code>
 * to the aggregation named <code>content</code>.
 *
 * @param {sap.ui.core.Control}
 *            oContent the content to add; if empty, nothing is inserted
 * @return {sap.ui.core.UIArea} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.core.UIArea.prototype.addContent = function(oContent, _bSuppressInvalidate) {
	this.addAggregation("content", oContent, _bSuppressInvalidate);
	// TODO this remains here just to make the UX3 Shell work which doesn't invalidate properly
	if ( _bSuppressInvalidate !== true ) {
		this.invalidate();
	}
	return this;
};

/**
 * Removes an content from the aggregation named <code>content</code>.
 *
 * @param {int | string | sap.ui.core.Control} vContent the content to remove or its index or id
 * @return {sap.ui.core.Control} the removed element or null
 * @public
 */
sap.ui.core.UIArea.prototype.removeContent = function(vContent, _bSuppressInvalidate) {
	var oContent = this.removeAggregation("content", vContent, _bSuppressInvalidate);
	if ( !_bSuppressInvalidate ) {
		var oDomRef;
		if(oContent && oContent.getDomRef) {
			oDomRef = oContent.getDomRef();
		}
		this._addRemovedContent(oDomRef);
		//this.invalidate();
	}
	return oContent;
};

/**
 * Removes all the controls in the aggregation named <code>content</code>.<br/>
 * Additionally unregisters them from the hosting UIArea.
 * @return {sap.ui.core.Control[]} an array of the removed elements (might be empty)
 * @public
 */
sap.ui.core.UIArea.prototype.removeAllContent = function() {
	var aContent = this.removeAllAggregation("content");
	for(var idx=0; idx<aContent.length; idx++){
		var oDomRef;
		var oContent = aContent[idx];
		if(oContent && oContent.getDomRef) {
			oDomRef = oContent.getDomRef();
		}
		this._addRemovedContent(oDomRef);
	}
	//this.invalidate();
	return aContent;
};

/**
 * Checks for the provided <code>sap.ui.core.Control</code> in the aggregation named <code>content</code>
 * and returns its index if found or -1 otherwise.
 *
 * @param {sap.ui.core.Control}
 *            oContent the content whose index is looked for.
 * @return {int} the index of the provided control in the aggregation if found, or -1 otherwise
 * @public
 */
sap.ui.core.UIArea.prototype.indexOfContent = function(oContent) {
	return this.indexOfAggregation("content", oContent);
};

/**
 * Destroys all the content in the aggregation
 * named <code>content</code>.
 * @return {sap.ui.core.UIArea} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.core.UIArea.prototype.destroyContent = function() {
	var aContent = this.getContent();
	for(var idx=0; idx<aContent.length; idx++){
		var oDomRef;
		var oContent = aContent[idx];
		if(oContent && oContent.getDomRef) {
			oDomRef = oContent.getDomRef();
		}
		this._addRemovedContent(oDomRef);
	}
	this.destroyAggregation("content");
	//this.invalidate();
	return this;
};

/**
 * Removes the given child from this UI area, where it must have been the root
 * control.
 * @see sap.ui.core.Element#_removeChild
 * @see sap.ui.core.Element#setParent
 *
 * @param {sap.ui.core.Control}
 *            oChild the child element to be removed
 * @protected
 */
sap.ui.core.UIArea.prototype._removeChild = function(oChild) {
	var idx = this.indexOfContent(oChild);
	if(idx >=0){
		this.removeContent(idx);
	}
};

/**
 * Locks this instance of UIArea.
 *
 * Rerendering and eventing will not be active as long as no
 * {@link #unlock} is called.
 *
 * @public
 */
sap.ui.core.UIArea.prototype.lock = function() {
	this.bLocked = true;
};

/**
 * Un-Locks this instance of UIArea.
 *
 * Rerendering and eventing will now be enabled again.
 *
 * @public
 */
sap.ui.core.UIArea.prototype.unlock = function() {
	if ( this.bLocked && this.bNeedsRerendering ) {
		// While being locked, we might have ignored a call to rerender()
		// Therefore notify the Core (again)
		this.oCore.addInvalidatedUIArea(this);
	}
	this.bLocked = false;
};

/**
 * Returns the locked state of the <code>sap.ui.core.UIArea</code>
 * @type boolean
 * @return locked state
 * @public
 */
sap.ui.core.UIArea.prototype.isLocked = function () {
	return this.bLocked;
};

/**
 * Set the model for databinding
 * @param {sap.ui.model.Model} oModel
 * @param {string} [sName]
 * @public
 */
sap.ui.core.UIArea.prototype.setModel = function(oModel, sName) {
	this.oModels[sName] = oModel;
	this.updateBindings(sName);
};

/**
 * Get the model for databinding
 * @param {string} [sName]
 * @return {sap.ui.model.Model} oModel
 * @public
 */
sap.ui.core.UIArea.prototype.getModel = function(sName) {
	return this.oModels[sName] || this.oCore.getModel(sName);
};

/**
 * Check if a Model is set to the UI Area or to the Core
 * @return {boolean} true or false
 * @public
 */
sap.ui.core.UIArea.prototype.hasModel = function() {
	if (!jQuery.isEmptyObject(this.oModels) || this.oCore.hasModel()) {
		return true;
	} else {
		return false;
	}
};

/**
 * Provide getBindingContext, as UIArea can be parent of an element.
 * Always returns null.
 *
 * @protected
 */
sap.ui.core.UIArea.prototype.getBindingContext = function(){
	return null;
};

/**
 * Method is called by the core if a model is set to the core to update/recreate all bindings
 * for the UI Areas and its contents.
 *
 * @private
 */
sap.ui.core.UIArea.prototype.updateBindings = function(sName){
	jQuery.each(this.getContent(), function (i, oElement){
		// update binding context, for primary model only
		if (!sName){oElement.updateBindingContext();}
		// if the model changes, all bindings have to be recreated (at least those to the previous model)
		oElement.updateBindings(false, sName, true);
	});
};



// ###########################################################################
// Convenience for methods
// e.g. Process Events for inner Controls
// or figure out whether control is part of this area.
// ###########################################################################

/**
 * Checks whether the control is still valid (is in the DOM)
 *
 * @return {boolean} True if the control is still in the active DOM
 * @protected
 */
sap.ui.core.UIArea.prototype.isActive = function() {
	return jQuery.sap.domById(this.getId()) != null;
};

/**
 * Will be used as end-point for invalidate-bubbling from controls up their hierarchy.<br/> Triggers re-rendering of
 * the UIAreas content.
 * @protected
 */
sap.ui.core.UIArea.prototype.invalidate = function() {
	this.addInvalidatedControl(this);
};

/**
 * Notifies the UIArea about an just invalidated control.
 *
 * The UIArea internally decides whether to re-render just the modified
 * controls or the complete content. It also informs the Core when it
 * becomes invalid the first time.
 *
 * TODO this.oRenderControl is either NULL or THIS. change to boolean?!
 * @protected
 */
sap.ui.core.UIArea.prototype.addInvalidatedControl = function(oControl){
	if (this.oRenderControl == this) {
		return;
	}

	// inform the Core, if we are getting invalid now
	if ( !this.bNeedsRerendering ) {
		this.oCore.addInvalidatedUIArea(this);
	}

	var sId = oControl.getId();
	//check whether the control is already invalidated
	if (/*jQuery.inArray(oControl, this.getContent()) || */oControl == this ) {
		this.oRenderControl = this; //everything in this UIArea
		this.bNeedsRerendering = true;
		return;
	}
	if (this.mInvalidatedControls[sId]) {
		return;
	}
	if (!this.oRenderControl) {
		//add it to the list of controls
		this.mInvalidatedControls[sId] = oControl;
		this.bNeedsRerendering = true;
	}
};

/**
 * TODO review and maybe refactor this complex algorithm
 * TODO documentation
 * TODO detach current "rerendering infos" before starting rerendering. Necessary to properly deal with concurrent modifications 
 * @param force {boolean} true, if the rerendering of the UI area should be forced
 * @return {boolean} whether a redraw was necessary or not
 * @private
 */
sap.ui.core.UIArea.prototype.rerender = function(force){
	if (force) {
		this.bNeedsRerendering = true;
	}
	if ( this.bLocked || !this.bNeedsRerendering ) {
		return false;
	}

	if (this.oRenderControl == this) {
		if (this.oRootNode) {
			jQuery.sap.log.info("Rerendering of UI area: " + this.getId());

			// save old content
			sap.ui.core.RenderManager.preserveContent(this.oRootNode, /* bPreserveRoot */ false, /* bPreserveNodesWithId */ this.bInitial);
			this.bInitial = false;

			//First remove the old Dom nodes and then render the controls again
			var len = this.aContentToRemove.length;
			var oDomRef;
			for(var i=0; i<len; i++) {
				oDomRef = this.aContentToRemove[i];
				if ( oDomRef && !sap.ui.core.RenderManager.isPreservedContent(oDomRef) ) {
					jQuery(oDomRef).remove();
				}
			}
			this.aContentToRemove = [];

			var aContent = this.getContent();
			var len = aContent.length;

			var oDomRef;
			for(var i=0; i<len; i++){
				oDomRef = aContent[i].getDomRef();
				if(oDomRef && !sap.ui.core.RenderManager.isPreservedContent(oDomRef)) {
					jQuery(oDomRef).remove();
				}
			}

			for(var i=0; i<len; i++){
				this.oCore.oRenderManager.render(aContent[i], this.oRootNode, true);
			}
		} else { // cannot re-render now; wait!
			return false;
		}
	} else {
		var that = this;
		function isAncestorInvalidated(oAncestor) {
			while ( oAncestor && oAncestor !== that ) {
				if ( that.mInvalidatedControls.hasOwnProperty(oAncestor.getId()) ) {
					return true;
				}
				oAncestor = oAncestor.getParent();
			}
			return false;
		}
		for (var n in this.mInvalidatedControls) { // TODO for in skips some names in IE8!
			var oControl = this.oCore.byId(n);
			// CSN 0000834961 2011: control may have been destroyed since invalidation happened
			if ( oControl && !isAncestorInvalidated(oControl.getParent()) ) {
				oControl.rerender();
			}
		}

	}

	this.oRenderControl = null;
	this.mInvalidatedControls = {};
	this.bNeedsRerendering = false;

	return true;

};

/**
 * Rerenders the given control
 * @see sap.ui.core.Control.rerender()
 * @param oControl
 * @private
 */
sap.ui.core.UIArea.rerenderControl = function(oControl){
	var oDomRef = oControl ? oControl.getDomRef() : null;
	var oParentDomRef = oDomRef && oDomRef.parentNode; // remember parent here as preserveContent() might move the node!
	if(oParentDomRef){
		var uiArea = oControl.getUIArea();
		var rm = uiArea ? uiArea.oCore.oRenderManager : sap.ui.getCore().createRenderManager();
		jQuery.sap.log.info("Rerendering of control (using Core-RenderManager: "+(!!uiArea)+"): " + oControl.getId());
		sap.ui.core.RenderManager.preserveContent(oDomRef, /* bPreserveRoot */ true, /* bPreserveNodesWithId */ false);
		rm.render(oControl, oParentDomRef);
	} else {
		jQuery.sap.log.warning("Couldn't rerender '" + oControl.getId() + "', as its DOM location couldn't be determined");
	}
};

/**
 * Handles all incoming DOM events centrally and dispatches the event to the
 * registered event handlers.
 * @param {jQuery.Event} oEvent the jQuery event object
 * @private
 */
sap.ui.core.UIArea.prototype._handleEvent = function(/**event*/oEvent) {

	// execute the registered event handlers
	var oElement = null;

	// TODO: this should be the 'lowest' SAPUI5 Control of this very
	// UIArea instance's scope -> nesting scenario
	oElement = jQuery(oEvent.target).control(0);
	if (oElement == null ||
		// in case of a Dialog the getUIArea function of the element returns
		// "null" and in case of nested UIAreas we need to ensure that the
		// UIArea is the same => BUT in case of nested UIAreas in dialogs
		// this pattern will not work!
		// TODO: May be in nested UIAreas in the UIArea is set properly and not
		//       null like for the root UI Area of the dialog!
		// TODO: In case of PopUp control it could be that the event is handled
		//       by the static area where the getUIArea check fails e.g.
		//       this happens in the MenuButton.qunit.html within the test
		//       "Menu is hidden after click on a menuitem" so in this case
		//       we have to ignore this check in case of static area where
		//       nevertheless the items are rendered invisible!
		// REMARK: IN GENERAL WE SHOULD RETHINK THE getUIArea FUNCTION
		//         BECAUSE IN CASE OF NESETED UI AREAS WE NEED TO MAKE SURE TO
		//         CHECK IF THE EVENT OCCURED WITHIN THE SPECIFIC UIAREA
		(this.getId() != "sap-ui-static" && oElement.getUIArea() != null && oElement.getUIArea() != this)) {
		return;
	}

	// store the element on the event (aligned with jQuery syntax)
	oEvent.srcControl = oElement;

	// forward the control event:
	// if the control propagation has been stopped or the default should be
	// prevented then do not forward the control event.
	this.oCore._handleControlEvent(oEvent, this.getId());

	// if the UIArea or the Core is locked then we do not dispatch
	// any event to the control => but they will still be dispatched
	// as control event afterwards!
	if (this.bLocked || this.oCore.isLocked()) {
		return;
	}

	// retrieve the pseudo event types
	var aEventTypes = [];
	if(oEvent.getPseudoTypes){
		aEventTypes = oEvent.getPseudoTypes();
	}
	aEventTypes.push(oEvent.type);

	// dispatch the event to the controls (callback methods: onXXX)
	while (oElement && oElement instanceof sap.ui.core.Element && oElement.isActive() && !oEvent.isPropagationStopped()) {

		// for each event type call the callback method
		// if the execution should be stopped immediately
		// then no further callback method will be executed
		for (var i = 0, is = aEventTypes.length; i < is; i++) {
			var sType = aEventTypes[i];
			oEvent.type = sType;
			// ensure currenTarget is the DomRef of the handling Control
			oEvent.currentTarget = oElement.getDomRef();
			oElement._handleEvent(oEvent);
			if(oEvent.isImmediatePropagationStopped()) {
				break;
			}
		}

		// if the propagation is stopped do not bubble up further
		if(oEvent.isPropagationStopped()) {
			break;
		}

		// This is the (not that common) situation that the element was deleted in its own event handler.
		// i.e. the Element became 'inactive' (see Element#isActive())
		var oDomRef = oElement.getDomRef();
		if(!oDomRef) {
			continue;
		}

		// bubble up to the parent
		oDomRef = oDomRef.parentNode;
		oElement = null;

		// ensure we do not bubble the control tree higher than our rootNode
		while (oDomRef && oDomRef !== this.getRootNode()) {
			if (oDomRef.id) {
				oElement = jQuery(oDomRef).control(0);
				if (oElement) {
					break;
				}
			}
			oDomRef = oDomRef.parentNode;
		}

	}

	// reset previously changed currentTarget
	oEvent.currentTarget = this.getRootNode();

	// TODO: rethink about logging levels!

	// logging: propagation stopped
	if (oEvent.isPropagationStopped()) {
		jQuery.sap.log.debug("'" + oEvent.type + "' propagation has been stopped");
	}

	// logging: prevent the logging of some events and for others do some
	//          info logging into the console
	var sName = oEvent.type;
	if (sName!="mousemove" && sName!="mouseover" && sName!="scroll" && sName!="mouseout") {
		var oElem = jQuery(oEvent.target).control(0);
		if(oElem) {
			jQuery.sap.log.debug("Event fired: '" + oEvent.type + "' on " + oElem, "", "sap.ui.core.UIArea");
		}
		else {
			jQuery.sap.log.debug("Event fired: '" + oEvent.type + "'", "", "sap.ui.core.UIArea");
		}
	}

};

/*
* The onattach function is called when the Element is attached to the DOM
* @private
*/
sap.ui.core.UIArea.prototype._onattach = function() {

// TODO optimizations for 'matching event list' could be done here.
//	// create the events string (space separated list of event names):
//	// the first time a control is attached - it will determine the required
//	// events and store this information in the controls metadata which is
//	// shared across the control instances.
//	if (!this.getMetadata().sEvents) {
//
//		// shorten the access to the array of events and pseudo events
//		var aEv = jQuery.sap.ControlEvents;
//		var oPsEv = jQuery.sap.PseudoEvents;
//
//		// create the data structures for the event handler registration
//		this.sEvents = "";
//		var aEvents = [];
//
//		// check for pseudo events and register them for their relevant types
//		for (var evt in oPsEv) {
//				for (j = 0, js = oPsEv[evt].aTypes.length; j < js; j++) {
//					var type = oPsEv[evt].aTypes[j];
//					if (jQuery.inArray(type, aEvents) == -1) {
//						aEvents.push(type);
//					}
//				}
//		}
//
//		// check for events and register them
//		for (var i = 0, is = aEv.length; i < is; i++) {
//			var type = aEv[i];
//				if (jQuery.inArray(type, aEvents) == -1) {
//					aEvents.push(type);
//				}
//		}
//
//		// keep the list of events for the jQuery bind/unbind method
//		this.sEvents = aEvents.join(" ");
//
//		// cache the event handlers registry map
//		this.getMetadata().sEvents = this.sEvents;
//
//	} else {
//		// use the cached map of event handlers
//		this.sEvents = this.getMetadata().sEvents;
//	}

	// check for existing root node
	var oDomRef = this.getRootNode();
	if (oDomRef == null) {
		return;
	}

	//	mark the DOM as UIArea and bind the required events
	jQuery(oDomRef).attr("data-sap-ui-area", oDomRef.id).bind(jQuery.sap.ControlEvents.join(" "), jQuery.proxy(this._handleEvent, this));

};

/**
* The ondetach function is called when the Element is detached out of the DOM
* @private
*/
sap.ui.core.UIArea.prototype._ondetach = function() {

	// check for existing root node
	var oDomRef = this.getRootNode();
	if (oDomRef == null) {
		return;
	}

	// remove UIArea marker and unregister all event handlers of the control
	jQuery(oDomRef).removeAttr("data-sap-ui-area").unbind();

	// TODO: when optimizing the events => take care to unbind only the
	//       required. additionally consider not to remove other event handlers.
//	var ojQRef = jQuery(oDomRef);
//	if (this.sEvents) {
//		ojQRef.unbind(this.sEvents, this._handleEvent);
//	}
//
//	var oFH = this.oCore.oFocusHandler;
//	ojQRef.unbind("focus",oFH.onfocusin);
//	ojQRef.unbind("blur", oFH.onfocusout);

};

}; // end of sap.ui.core.UIArea


/**
 * @class Core Class of the SAP UI Library.
 *
 * This class boots the Core framework and makes it available for the Application
 * via the method <code>sap.ui.getCore()</code>.
 *
 * Example:<br/>
 * <pre>   var oCore = sap.ui.getCore();</pre><br/>
 *
 * It provides events where the Application can attach to.<br/>
 * Example:<br/>
 * <pre>
 * oCore.attachInitEvent(function () {
 *   //do the needful, do it lean
 * });
 * </pre><br/>
 *
 * It registers the Browser Eventing.
 *
 * @extends sap.ui.base.EventProvider
 * @final
 * @author Martin Schaus, Daniel Brinkmann
 * @version 1.5.0-SNAPSHOT
 * @constructor
 * @public
 */
sap.ui.core.Core = function() {

	//make this class only available once
	if(sap.ui.getCore && sap.ui.getCore()) {
		return sap.ui.getCore();
	}

	var that=this,
		log = jQuery.sap.log,
		METHOD="sap.ui.core.Core";

	//inheritance to be able to fire internal events
	sap.ui.base.EventProvider.apply(this);

	/**
	 * Whether the core has been booted
	 * @private
	 */
	this.bBooted = false;

	/**
	 * Whether the core has been initialized
	 * @private
	 */
	this.bInitialized = false;

	/**
	 * Available plugins in the order of registration.
	 * @private
	 */
	this.aPlugins = [];

	/**
	 * Collection of loaded libraries, keyed by their name.
	 * @private
	 */
	this.mLibraries = {};

	/**
	 * Already loaded resource bundles keyed by library and locale.
	 * @private
	 * @see sap.ui.core.Core.getLibraryResourceBundle
	 */
	this.mResourceBundles = {};

	/**
	 * Currently created UIAreas keyed by their id.
	 * @private
	 * FIXME how can a UI area ever be removed?
	 */
	this.mUIAreas = {};

	/**
	 * Default model used for databinding
	 * @private
	 */
	this.oModels = {};

	/**
	 * Map of of created Elements keyed by their id.
	 *
	 * Each element registers itself in its constructor and deregisters itself in its
	 * destroy method.
	 *
	 * @private
	 * TODO get rid of this collection as it represents a candidate for memory leaks
	 */
	this.mElements = {};

	/**
	 * Ordered collection of initEvent listeners
	 * Moved here (before boot()) so that the libraries can be registered for lazy load!!
	 * @private
	 */
	this.aInitListeners = [];

	/**
	 * Whether the legacy library has to be loaded.
	 * @private
	 */
	this.bInitLegacyLib = false;

	log.info("Creating Core",null,METHOD);

	/**
	 * Object holding the interpreted configuration
	 * Initialized from the global "sap-ui-config" object and from Url parameters
	 * @private
	 */
	this.oConfiguration = new sap.ui.core.Configuration();

	// grant Element "friend" access to Core for (de-)registration
	sap.ui.core.Element.prototype.register = function() {
		that.registerElement(this);
	};
	sap.ui.core.Element.prototype.deregister = function() {
		that.deregisterElement(this);
	};

	// handle modules
	var aModules = this.oConfiguration.modules;
	if ( this.oConfiguration.getDebug() ) {
		// add debug module if configured
		aModules.unshift("sap-ui-debug");
	}
	// enforce the core library as the first loaded module
	aModules.unshift("sap.ui.core.library");
	log.info("Declared modules: " + aModules, METHOD);

	var oCfgData = window["sap-ui-config"];
	if (oCfgData) {
		// read themeRoots configuration
		if (oCfgData.themeroots) {
			for (var themeName in oCfgData.themeroots) {
				var themeRoot = oCfgData.themeroots[themeName];
				if (typeof themeRoot === "string") {
					this.setThemeRoot(themeName, themeRoot);
				} else {
					for (var lib in themeRoot) {
						if (lib.length > 0) {
							this.setThemeRoot(themeName, [lib], themeRoot[lib]);
						} else {
							this.setThemeRoot(themeName, themeRoot[lib]);
						}
					}
				}
			}
		}
	}

	// set CSS class for the theme name
	this.sTheme = this.oConfiguration.getTheme();
	jQuery(document.documentElement).addClass("sapUiTheme-" + this.sTheme);
	log.info("Declared theme " + this.sTheme,null,METHOD);

	if (this.oConfiguration.getRTL()) {
		jQuery(document.documentElement).attr("dir", "rtl"); // webkit does not allow setting document.dir before the body exists
		log.info("RTL mode activated",null,METHOD);
	}

	function calcBrowserId() {

		var b = jQuery.browser,
			ua = navigator.userAgent,
			browserVersion = parseFloat(b.version);

		// jQuery checks for user agent strings. We differentiate between browsers
		if ( b.mozilla ) {
			if ( ua.match(/Firefox\/(\d+\.\d+)/) ) {
				browserVersion = parseFloat(RegExp.$1);
				b.fVersion = browserVersion;
				return "ff" + Math.floor(browserVersion);
			}
		} else if ( b.webkit ) {
			if ( ua.match(/Chrome\/(\d+\.\d+).\d+/) ) {
				b.chrome = true;
				b.safari = false;
				browserVersion = parseFloat(RegExp.$1);
				b.fVersion = browserVersion;
				return "cr" + browserVersion;
			} else { // I do not know why but Safari might have an issue with ua.match(...); thus changing
				var oExp = /Version\/(\d+\.\d+).\d* *Safari/;
				if(oExp.test(ua)) {
					b.safari = true;
					browserVersion = parseFloat(oExp.exec(ua)[1]);
					b.fVersion = browserVersion;
					if ( browserVersion >= 5 ) {
						return "sf5";
					}
					if ( browserVersion >= 4 ) {
						return "sf4";
					}
				}
			}
		} else if ( b.msie ) {
			// recognize IE8 when running in compat mode (only then the documentMode property is there)
			if (document.documentMode) {
				if(document.documentMode === 7) {
					// OK, obviously we are IE and seem to be 7... but as documentMode is there this cannot be IE7!
					log.warning("Browser running in IE7 document mode.", null, METHOD);
					b.fVersion = 8.0;
					return "ie8"; // how do we solve this in higher versions? Where do we get this information from?
				}
				b.fVersion = parseFloat(document.documentMode);
				return "ie" + document.documentMode;
			} else {
				b.fVersion = browserVersion;
				return "ie" + browserVersion;
			}
		}

		// otherwise not recognized...
	}

	function getOS(userAgent){
		userAgent = userAgent || navigator.userAgent;
		var platform = /[\(]([a-zA-TV-Z]+);\s(?:[U]?[;]?)([\D]+)((?:[\d._]*))(?:.*[\)][^\d]*)([\d.]*)\s/;
		var result = userAgent.match(platform);
		if (result){
			var appleDevices = /iPhone|iPad|iPod/;
			var bbDevices = /PlayBook|BlackBerry/;
			if (result[0].match(appleDevices)){
				result[3] = result[3].replace(/_/g, ".");
				//result[1] contains info of devices
				return({"version": 'iOS'+result[3] , "css": "sap-ios"});
			} else if (result[2].match(/Android/)) {
				result[2] = result[2].replace(/\s/g, "");
				return({"version": result[2]+result[3] , "css": "sap-android"});
			} else if (result[0].match(bbDevices)) {
				return({"version": 'bb'+result[4] , "css": "sap-bb"});
			} else {
				// currently we only support iOS, Android, BlackBerry 6.0+ , everything else will be ignored, if more platforms should be supported, logic can be placed here
				return;
			}
		}
	}
	
	//set the browser for css attribute selectors. do not move this to the onload function because sf and ie do not
	//use the classes
	var id = calcBrowserId();
	if ( id ) {
		jQuery("html").attr("data-sap-ui-browser", id);
		log.debug("Browser-Id: " + id, null, METHOD);
	}

	var os = getOS();
	if ( os ){
		jQuery("html").attr("data-sap-ui-os", os.version).addClass(os.css);
	}
	
	//if weinre id is set, load weinre target script
	if (this.oConfiguration.getWeinreId()) {
		log.info("Starting WEINRE Remote Web Inspector");
		document.write("<script src=\"");
		document.write(this.oConfiguration.getWeinreServer() + "/target/target-script-min.js#" + this.oConfiguration.getWeinreId());
		document.write("\"></script>");
	}

	// create accessor to the Core API early so that initLibrary and others can use it
	/**
	 * Retrieve the {@link sap.ui.core.Core SAPUI5 Core} instance for the current window.
	 * @returns the API of the current SAPUI5 Core instance.
	 * @public
	 * @function
	 */
	sap.ui.getCore = jQuery.sap.getter(this.getInterface());

	if (!this.oConfiguration['xx-loadAllMode'] && !this.oConfiguration['xx-preload'] && (!window.document.body || window.document.readyState)) {
		//the instance will boot now
		this.boot();
	}

	//Init the HTML5 support if necessary before initialize the RenderManager
	sap.ui.core.RenderManager.initHTML5Support();
	// create the RenderManager so it can be used already
	this.oRenderManager = new sap.ui.core.RenderManager();

	//register to load event of the browser
	jQuery(document).ready(jQuery.proxy(this, "handleLoad")); // make sure SAPUI5 is first when jQuery.ready is fired

	if ( this.oConfiguration['xx-preload'] ) {
		jQuery.each(aModules, function(i,mod) {
			var m = mod.match(/^(.*)\.library$/);
			if ( m ) {
				var sPreloadModule = m[1].replace(/\./g, "-") + "-preload";
				jQuery.sap.log.debug("preload file " + sPreloadModule);
				jQuery.ajax({
					dataType : "text",
					async : that.oConfiguration['xx-preload'] !== "sync",
					url : jQuery.sap.getModulePath(sPreloadModule, ".js"),
					success : function(data) {
						jQuery.sap.globalEval(data);
					}
				});
			}
		});
	}

};

sap.ui.core.Core.prototype = jQuery.sap.newObject(sap.ui.base.EventProvider.prototype);
sap.ui.base.Object.defineClass("sap.ui.core.Core", {
		// ---- object ----
		baseType : "sap.ui.base.EventProvider",
		publicMethods : ["boot", "isInitialized","attachInitEvent","getRenderManager","createRenderManager",
						 "getConfiguration", "setRoot", "createUIArea", "getUIArea", "getUIDirty", "getElementById",
						 "getCurrentFocusedControlId", "getControl", "lock", "unlock","isLocked",
						 "attachEvent","detachEvent","applyChanges",
						 "applyTheme","setThemeRoot","attachThemeChanged","detachThemeChanged","getStaticAreaRef",
						 "registerPlugin","unregisterPlugin","getLibraryResourceBundle", "byId",
						 "getLoadedLibraries", "attachControlEvent", "detachControlEvent", "loadLibrary", "initLibrary",
						 "includeLibraryTheme", "setModel", "getModel", "hasModel", "isMobile", "attachParseError", "detachParseError",
						 "attachValidationError", "detachValidationError", "attachFormatError", "detachFormatError", "attachValidationSuccess",
						 "detachValidationSuccess", "fireFormatError", "fireParseError", "fireValidationError", "fireValidationSuccess"]
	});
/**
 * Map of event names and ids, that are provided by this class
 * @private
 */
sap.ui.core.Core.M_EVENTS = {ControlEvent: "ControlEvent", UIUpdated: "UIUpdated", ThemeChanged: "ThemeChanged",
		ValidationError : "validationError", ParseError : "parseError", FormatError : "formatError", ValidationSuccess : "validationSuccess"};

/**
 * Boots the core and injects the necessary css and js files for the library.
 * Applications shouldn't call this method. It is automatically called by the bootstrap scripts (e.g. sap-ui-core.js)
 *
 * @private
 */
sap.ui.core.Core.prototype.boot = function() {

	if (this.bBooted) {
		return;
	}

	this.bBooted = true;

	//do not allow any event processing until the Core is booting
	this.lock();

	// load all modules now
	var that = this;
	jQuery.each(this.oConfiguration.modules, function(i,mod) {
		var m = mod.match(/^(.*)\.library$/);
		if ( m ) {
			that.loadLibrary(m[1]);
		} else {
			jQuery.sap.require(mod);
		}
	});

	//allow events again
	this.unlock();
};


/**
 * Applies the theme with the given name (by loading the respective style sheets, which does not disrupt the application).
 *
 * By default, the theme files are expected to be located at path relative to the respective control library ([libraryLocation]/themes/[themeName]).
 * Different locations can be configured by using the method setThemePath() or by using the second parameter "sThemeBaseUrl" of applyTheme().
 * Usage of this second parameter is a shorthand for setThemePath and internally calls setThemePath, so the theme location is then known.
 *
 * sThemeBaseUrl is a single URL to specify the default location of all theme files. This URL is the base folder below which the control library folders
 * are located. E.g. if the CSS files are not located relative to the root location of UI5, but instead they are at locations like
 *    http://my.server/myapp/resources/sap/ui/core/themes/my_theme/library.css
 * then the URL that needs to be given is:
 *    http://my.server/myapp/resources
 * All theme resources are then loaded from below this folder - except if for a certain library a different location has been registered.
 *
 * If the theme resources are not all either below this base location or  with their respective libraries, then setThemePath must be
 * used to configure individual locations.
 *
 * @param {string} sThemeName the name of the theme to be loaded
 * @param {string} [sThemeBaseUrl] the (optional) base location of the theme
 * @public
 */
sap.ui.core.Core.prototype.applyTheme = function(sThemeName, sThemeBaseUrl) {
	jQuery.sap.assert(typeof sThemeName === "string", "sThemeName must be a string");
	jQuery.sap.assert(typeof sThemeBaseUrl === "string" || typeof sThemeBaseUrl === "undefined", "sThemeBaseUrl must be a string or undefined");

	if (sThemeBaseUrl) {
		this.setThemeRoot(sThemeName, sThemeBaseUrl);
	}

	// only apply the theme if it is different from the active one
	if (sThemeName && this.sTheme != sThemeName) {
		var sCurrentTheme = this.sTheme,
			that = this;
		// select "our" stylesheets
		jQuery("link[id^=sap-ui-theme-]").each(function() {
			// modify style sheet URL to point to the new theme
			// be aware of custom css included with the colon (see includeLibraryTheme) // TODO: what is this??
			var sLibName = this.id.substr(13); // length of "sap-ui-theme-"
			var pos;
			if ((pos = sLibName.indexOf("-[")) > 0) { // assumes that "-[" does not occur as part of a library name
				sLibName = sLibName.substr(0, pos);
			}
			var sBaseUrl = that._getThemePath(sLibName, sThemeName);
			var fileName = this.href.substr(this.href.lastIndexOf("/") + 1);
			this.href = sBaseUrl + fileName;
		});
		this.sTheme = sThemeName;
		this.getConfiguration().setTheme(sThemeName);

		// modify the <html> tag's CSS class with the theme name
		jQuery(document.documentElement).removeClass("sapUiTheme-" + sCurrentTheme).addClass("sapUiTheme-" + sThemeName);

		// notify the listeners
		jQuery.sap.delayedCall(500, this, "fireThemeChanged", [{theme: sThemeName}]); // TODO: only fire once we are sure the theme has been loaded. E.g. have a certain off-screen element with a width that can be derived from the theme name and is unique. And wait until the element has changed size.
	}
};


/**
 * Returns the URL of the folder in which the CSS file for the given theme and the given library is located .
 * The returned URL ends with a slash.
 *
 * @param sLibName
 * @param sThemeName
 * @private
 */
sap.ui.core.Core.prototype._getThemePath = function(sLibName, sThemeName) {
	if (this._mThemeRoots) {
		var path =  this._mThemeRoots[sThemeName + " " + sLibName] || this._mThemeRoots[sThemeName];
		// check whether for this combination (theme+lib) a URL is registered or for this theme a default location is registered
		if (path) {
			path = path + sLibName.replace(/\./g, "/") + "/themes/" + sThemeName + "/";
			jQuery.sap.registerModulePath(sLibName + ".themes." + sThemeName, path);
			return path;
		}
	}

	// use the library location as theme location
	return jQuery.sap.getModulePath(sLibName + ".themes." + sThemeName + "/", "/");
};


/**
 *
 *
 * @param sThemeName
 * @param aLibraryNames
 * @param sThemeBaseUrl
 */
sap.ui.core.Core.prototype.setThemeRoot = function(sThemeName, aLibraryNames, sThemeBaseUrl) {
	jQuery.sap.assert(typeof sThemeName === "string", "sThemeName must be a string");
	jQuery.sap.assert((jQuery.isArray(aLibraryNames) && typeof sThemeBaseUrl === "string") || (typeof aLibraryNames === "string" && sThemeBaseUrl === undefined), "either the second parameter must be a string (and the third is undefined), or it must be an array and the third parameter is a string");

	if (!this._mThemeRoots) {
		this._mThemeRoots = {};
	}

	// normalize parameters
	if (!sThemeBaseUrl) {
		sThemeBaseUrl = aLibraryNames;
		aLibraryNames = undefined;
	}
	sThemeBaseUrl = sThemeBaseUrl + (sThemeBaseUrl.slice(-1) == "/" ? "" : "/");

	if (aLibraryNames) {
		// registration of URL for several libraries
		for (var i = 0; i < aLibraryNames.length; i++) {
			var lib = aLibraryNames[i];
			this._mThemeRoots[sThemeName + " " + lib] = sThemeBaseUrl;
		}

	} else {
		// registration of theme default base URL
		this._mThemeRoots[sThemeName] = sThemeBaseUrl;
	}

};


/**
 * Initializes the Core after the initial page was loaded
 * @private
 */
sap.ui.core.Core.prototype.init = function() {

	if (this.bInitialized) {
		return;
	}

	var log = jQuery.sap.log,
		METHOD = "sap.ui.core.Core.init()";

	// ensure that the core is booted now (e.g. loadAllMode)
	this.boot();

	log.info("Initializing",null,METHOD);

	this.oFocusHandler = new sap.ui.core.FocusHandler(document.body, this);
	this.oResizeHandler = new sap.ui.core.ResizeHandler(this);

	log.info("Initialized",null,METHOD);

	this.bInitialized = true;

	// start the plugins
	log.info("Starting Plugins",null,METHOD);
	this.startPlugins();
	log.info("Plugins started",null,METHOD);

	var oConfig = this.oConfiguration;
	// create any pre-configured UIAreas
//	if ( oConfig.areas && oConfig.areas.length > 0 ) {
	if ( oConfig.areas ) {
		// log.warning("deprecated config option '(data-sap-ui-)areas' used.");
		for (var i=0, l = oConfig.areas.length; i < l; i++) {
			this.createUIArea(oConfig.areas[i]);
		}
		oConfig.areas = undefined;
	}

	// execute a configured init hook
	if ( oConfig.onInit ) {
		if ( typeof oConfig.onInit === "function" ) {
			oConfig.onInit();
		} else {
			// DO NOT USE jQuery.globalEval as it executes async in FF!
			jQuery.sap.globalEval(oConfig.onInit);
		}
		oConfig.onInit = undefined;
	}

	// execute registered init event handlers
	if (this.aInitListeners.length > 0) {
		log.info("Fire Loaded Event",null,METHOD);
		jQuery.each(this.aInitListeners, function(i,f) { f(); }); // TODO is jQuery.each safe wrt. concurrent modifications?
		this.aInitListeners = [];
	}

	this._rerenderAllUIAreas(); // directly render without setTimeout, so rendering is guaranteed to be finished when init() ends
};

/**
 * Handles the load event of the browser to initialize the Core
 * @private
 */
sap.ui.core.Core.prototype.handleLoad = function () {

	//do not allow any event processing until the Core is initialized
	var bWasLocked = this.isLocked();
	if ( !bWasLocked ) {
		this.lock();
	}
	this.init();
	//allow event processing again
	if ( !bWasLocked ) {
		this.unlock();
	}

};

/**
 * Returns true if the core has already been initialized. This means that instances of RenderManager,
 * etc. do already exist and the init event has already been fired (and will not
 * be fired again).
 *
 * @return whether the core has already been initialized
 * @public
 */
sap.ui.core.Core.prototype.isInitialized = function () {
	return this.bInitialized;
};

/**
 * Attaches a given function to the initialized event of the core.
 * This event will only be fired once; you can check if it already has been fired by calling isInitialized().
 *
 * @param func the function to be called on event firing.
 * @public
 */
sap.ui.core.Core.prototype.attachInitEvent = function (func) {
	jQuery.sap.assert(typeof func === "function", "func must be a function");
	this.aInitListeners.push(func);
};

/**
 * Locks the Core. No browser events are dispatched to the controls.
 * Lock should be called before and after the dom is modified for rendering, roundtrips...
 * Exceptions might be the case for asynchronous UI behavior
 * @public
 */
sap.ui.core.Core.prototype.lock = function () {
	this.bLocked = true;
};

/**
 * Unlocks the Core. Browser events are dispatched to the controls after
 * this method is called.
 * @public
 */
sap.ui.core.Core.prototype.unlock = function () {
	this.bLocked = false;
};

/**
 * Returns the locked state of the <code>sap.ui.core.Core</code>
 * @type boolean
 * @return locked state
 * @public
 */
sap.ui.core.Core.prototype.isLocked = function () {
	return this.bLocked;
};

/**
 * Returns the Configuration instance of the current Core instance.
 *
 * @return {sap.ui.core.Configuration} the Configuration instance of the current Core instance.
 * @public
 */
sap.ui.core.Core.prototype.getConfiguration = function () {
	return this.oConfiguration;
};

/**
 * @public
 * @deprecated Since version 0.15.0. Replaced by <code>createRenderManager()</code>
 */
sap.ui.core.Core.prototype.getRenderManager = function() {
	return this.createRenderManager(); //this.oRenderManager;
};

/**
 * Returns a new instance of the RenderManager interface.
 *
 * @return {sap.ui.core.RenderManager} the new instance of the RenderManager interface.
 * @public
 */
sap.ui.core.Core.prototype.createRenderManager = function() {
	return (new sap.ui.core.RenderManager()).getInterface();
};

/**
 * Returns the Id of the control/element currently in focus.
 * @return {string} the Id of the control/element currently in focus.
 * @public
 */
sap.ui.core.Core.prototype.getCurrentFocusedControlId = function() {
	return this.oFocusHandler.getCurrentFocusedControlId();
};

/**
 * Synchronously loads the given library and makes it available to the application.
 *
 * Loads the *.library module, which contains all preload modules (enums, types, content of a shared.js
 * if it exists). The library module will call initLibrary with additional metadata for the library.
 *
 * As a result, consuming applications can instantiate any control or element from that library
 * without having to write import statements for the controls or for the enums.
 *
 * When the optional parameter <code>sUrl</code> is given, then all request for resources of the
 * library will be redirected to the given Url. This is convenience for a call to
 * <pre>
 *   jQuery.sap.registerModulePath(sLibrary, sUrl);
 * </pre>
 *
 * When the given library has been loaded already, no further action will be taken.
 * Especially, a given Url will not be honored!
 *
 * @param {string} sLibrary name of the library to import
 * @param {string} [sUrl] URL to load the library from
 * @public
 */
sap.ui.core.Core.prototype.loadLibrary = function(sLibrary, sUrl) {
	jQuery.sap.assert(typeof sLibrary === "string", "sLibrary must be a string");
	jQuery.sap.assert(sUrl === undefined || typeof sUrl === "string", "sUrl must be a string or empty");

	// load libraries only once
	if ( !this.mLibraries[sLibrary] ) {

		var sModule = sLibrary + ".library",
			sAllInOneModule;

		// if a sUrl is given, redirect access to it
		if ( sUrl ) {
			jQuery.sap.registerModulePath(sLibrary, sUrl);
		}

		// optimization: in all-in-one mode we are loading all modules of the lib in a single file
		if ( this.oConfiguration['xx-loadAllMode'] && !jQuery.sap.isDeclared(sModule) ) {
			sAllInOneModule = sLibrary.replace(/\./g, "-") + "-all";
			jQuery.sap.log.debug("load all-in-one file " + sAllInOneModule);
			jQuery.sap.require(sAllInOneModule);
		}

		// require the library module (which in turn will call initLibrary())
		jQuery.sap.require(sModule);

		// check for legacy code
		if ( !this.mLibraries[sLibrary] ) {
			jQuery.sap.log.warning("library " + sLibrary + " didn't initialize itself");
			this.initLibrary(sLibrary); // TODO redundant to generated initLibrary call....
		}

	}

	return this.mLibraries[sLibrary];
};

/**
 * Initializes a library for an already loaded library module.
 *
 * This method is intended to be called only from a library.js (e.g. generated code).
 * It includes the library specific stylesheet into the current page, and creates
 * lazy import stubs for all controls and elements in the library.
 *
 * As a result, consuming applications don't have to write import statements for the controls or for the enums.
 *
 * Synchronously loads any libraries that the given library depends on.
 *
 * @param {string|object} vLibInfo name of or info object for the library to import
 * @public
 */
sap.ui.core.Core.prototype.initLibrary = function(vLibInfo) {
	jQuery.sap.assert(typeof vLibInfo === "string" || typeof vLibInfo === "object", "vLibInfo must be a string or object");

	var bLegacyMode = typeof vLibInfo === "string",
		oLibInfo = bLegacyMode ? { name : vLibInfo } : vLibInfo,
		sLibName = oLibInfo.name,
		log = jQuery.sap.log,
		METHOD =  "sap.ui.core.Core.initLibrary()";

	if ( bLegacyMode ) {
		log.warning("[Deprecated] library " + sLibName + " uses old fashioned initLibrary() call (rebuild with newest generator)");
	}

	if ( !sLibName || this.mLibraries[sLibName] ) {
		return;
	}

	log.debug("Analyzing Library " + sLibName, null, METHOD);

	// Create lib info object. Also used as a marker that the library is loading/has been loaded
	this.mLibraries[sLibName] = oLibInfo = jQuery.extend({
	  dependencies : [],
	  types : [],
	  interfaces : [],
	  controls: [],
	  elements : []
	}, oLibInfo);

	// this code could be moved to a separate "legacy support" module
	function readLibInfoFromProperties() {

		// read library properties
		var oProperties = jQuery.sap.properties({url : sap.ui.resource(sLibName, "library.properties")});

		// version info
		oLibInfo.version = oProperties.getProperty(sLibName + "[version]");

		// dependencies
		var sDepInfo = oProperties.getProperty(sLibName + "[dependencies]");
		log.debug("Required Libraries: " + sDepInfo, null, METHOD);
		oLibInfo.dependencies = (sDepInfo && sDepInfo.split(/[,;| ]/)) || [];

		// collect types, controls and elements
		var aKeys = oProperties.getKeys(),
		  rPattern = /(.+)\.(type|interface|control|element)$/,
		  aMatch;
		for(var i=0; i<aKeys.length; i++) {
			var sEntityPath = oProperties.getProperty(aKeys[i]);
			if ( aMatch = sEntityPath.match(rPattern) ) {
				oLibInfo[aMatch[2]+"s"].push(aKeys[i]);
			}
		}
	}

	// (legacy) if only a string was given, read the library.properties instead
	if ( bLegacyMode ) {
		readLibInfoFromProperties();
	}

	// resolve dependencies
	for(var i=0; i<oLibInfo.dependencies.length; i++) {
		var sDepLib = oLibInfo.dependencies[i];
		log.debug("resolve Dependencies to " + sDepLib, null, METHOD);
		if ( !this.mLibraries[sDepLib] ) {
			log.warning("Dependency from " + sLibName + " to " + sDepLib + " has not been resolved by library itself", null, METHOD);
			this.loadLibrary(sDepLib);
		}
	}

	// create lazy imports for all controls and elements
	var aElements = oLibInfo.controls.concat(oLibInfo.elements);
	for(var i=0; i<aElements.length; i++) {
		sap.ui.lazyRequire(aElements[i], "new extend"); // TODO don't create an 'extend' stub for final classes
	}

	// include the library theme
	this.includeLibraryTheme(sLibName);

	// expose some legacy names
	oLibInfo.sName = oLibInfo.name;
	oLibInfo.aControls = oLibInfo.controls;

	// load and execute the library.js script
	if ( !jQuery.sap.isDeclared(sLibName + ".library") ) {
		// TODO redundant to generated require calls
		log.warning("Library Module " + sLibName + ".library" + " not loaded automatically", null, METHOD);
		jQuery.sap.require(sLibName + ".library");
	}

};

/**
 * Includes a library theme into the current page (if a variant is specified it
 * will include the variant library theme)
 * @param {string} sLibName the name of the UI library
 * @param {string} [sVariant] the variant to include (optional)
 * @public
 */
sap.ui.core.Core.prototype.includeLibraryTheme = function(sLibName, sVariant) {
	jQuery.sap.assert(typeof sLibName === "string", "sLibName must be a string");
	jQuery.sap.assert(sVariant === undefined || typeof sVariant === "string", "sVariant must be a string or undefined");

	/*
	 * by specifiying a library name containing a colon (":") you can specify
	 * the file name of the CSS file to include (ignoring RTL)
	 */

	// include the stylesheet for the library (except for "classic" and "legacy" lib)
	if ((sLibName != "sap.ui.legacy") && (sLibName != "sap.ui.classic")) {

		// no variant?
		if (!sVariant) {
			sVariant = "";
		}

		// determine RTL
		var sRtl = (this.oConfiguration.getRTL() ? "-RTL" : "");

		// create the library file name
		var sLibFileName,
			sLibId = sLibName + (sVariant.length > 0 ? "-[" + sVariant + "]" : sVariant);
		if (sLibName && sLibName.indexOf(":") == -1) {
			sLibFileName = "library" + sVariant + sRtl;
		} else {
			sLibFileName = sLibName.substring(sLibName.indexOf(":") + 1) + sVariant;
			sLibName = sLibName.substring(0, sLibName.indexOf(":"));
		}

		// log and include
		var cssPathAndName = this._getThemePath(sLibName, this.sTheme) + sLibFileName + ".css";
		jQuery.sap.log.info("Including " + cssPathAndName + " -  sap.ui.core.Core.includeLibraryTheme()");
		jQuery.sap.includeStyleSheet(cssPathAndName, "sap-ui-theme-" + sLibId);

	}

};

/**
 * Returns a map which contains the names of the loaded libraries as keys
 * and some additional information about each library as values.
 *
 * Note that the details of the 'values' in the returned map are not yet specified!
 * Their structure might change in future versions without notice. So applications
 * can only rely on the set of keys as well as the pure existance of a value.
 *
 * @return {map} map of library names / controls
 * @public
 */
sap.ui.core.Core.prototype.getLoadedLibraries = function() {
	return jQuery.extend({}, this.mLibraries); // TODO deep copy or real Library object?
};

/**
 * Implicitly creates a new <code>UIArea</code> (or reuses an exiting one) for the given DOM reference and
 * adds the given control reference to the UIAreas content (existing content will be removed).
 *
 * @param {String,DomRef} oDomRef a Dom Reference or Id String of the UIArea
 * @param {sap.ui.base.Interface | sap.ui.core.Control}
 *            oControl the Control that should be the added to the <code>UIArea</code>.
 * @public
 * @deprecated Use function <code>oControl.placeAt(oDomRef, "only")</code> of <code>sap.ui.core.Control</code> instead.
 */
sap.ui.core.Core.prototype.setRoot = function(oDomRef, oControl) {
	jQuery.sap.assert(typeof oDomRef === "string" || typeof oDomRef === "object", "oDomRef must be a string or object");
	jQuery.sap.assert(oControl instanceof sap.ui.base.Interface || oControl instanceof sap.ui.core.Control, "oControl must be a Control or Interface");

	if(oControl) {
		oControl.placeAt(oDomRef, "only");
	}
};

/**
 * Creates a new sap.ui.core.UIArea
 *
 * @param {String,DomRef} oDomRef a DOM reference or ID string of the UIArea
 * @return a new UIArea
 * @type sap.ui.core.UIArea
 *
 * @public
 * @deprecated Use <code>setRoot()</code> instead!
 */
sap.ui.core.Core.prototype.createUIArea = function(oDomRef) {
	jQuery.sap.assert(typeof oDomRef === "string" || typeof oDomRef === "object", "oDomRef must be a string or object");

	if (!oDomRef) {
		throw new Error("oDomRef must not be null");
	}

	// oDomRef might be (and actually IS in most cases!) a string (the ID of a DOM element)
	if (typeof(oDomRef) === "string") {
		var id = oDomRef;
		oDomRef = jQuery.sap.domById(oDomRef);
		if (!oDomRef) {
			throw new Error("DOM element with ID '" + id + "' not found in page, but application tries to insert content.");
		}
	}

	// if the domref does not have an ID or empty ID => generate one
	if (!oDomRef.id || oDomRef.id.length == 0) {
		oDomRef.id = jQuery.sap.uid();
	}

	// create a new or fetch an existing UIArea
	var sId = oDomRef.id;
	if (!this.mUIAreas[sId]) {
		this.mUIAreas[sId] = new sap.ui.core.UIArea(this, oDomRef);
	} else {
		// this should solve the issue of 'recreation' of a UIArea
		// e.g. via setRoot with a new domRef
		this.mUIAreas[sId].setRootNode(oDomRef);
	}
	return this.mUIAreas[sId];

};

/**
 * Returns a UIArea if the given ID/Element belongs to one
 *
 * @public
 * @param {String,DomRef} o a DOM Reference or ID String of the UIArea
 * @return a UIArea with a given id or dom ref.
 * @type sap.ui.core.UIArea
 */
sap.ui.core.Core.prototype.getUIArea = function(o) {
	jQuery.sap.assert(typeof o === "string" || typeof o === "object", "o must be a string or object");

	var sId = "";
	if (typeof(o)=="string") {
		sId = o;
	}
	else {
		sId = o.id;
	}

	if (sId) {
		return this.mUIAreas[sId];
	}

	return null;
};

/**
 * Informs the core about an UIArea that just became invalid.
 *
 * The core might use this information to minimize the set of
 * re-rendered UIAreas. But for the time being it just registers
 * a timer to trigger a re-rendering after the current event
 * has been processed.
 *
 * @param oUIArea {sap.ui.core.UIArea} UIArea that just became invalid
 * @private
 */
sap.ui.core.Core.prototype.addInvalidatedUIArea = function(oUIArea) {
	this.rerenderAllUIAreas(); // TODO: document why immediately rerender all??
};

/**
 * Retrieves a resource bundle for the given library and locale.
 *
 * If only one argument is given, it is assumed to be the libraryName. The locale
 * then falls back to the current {@link sap.ui.core.Configuration.prototype.getLanguage session locale}.
 * If no argument is given, the library also falls back to a default: "sap.ui.core".
 *
 * @param {string} [sLibraryName=sap.ui.core] name of the library to retrieve the bundle for
 * @param {string} [sLocale] locale to retrieve the resource bundle for
 * @return {jQuery.sap.util.ResourceBundle} the best matching resource bundle for the given parameters or undefined
 * @public
 */
sap.ui.core.Core.prototype.getLibraryResourceBundle = function(sLibraryName, sLocale) {
	jQuery.sap.assert((sLibraryName === undefined && sLocale === undefined) || typeof sLibraryName === "string", "sLibraryName must be a string or there is no argument given at all");
	jQuery.sap.assert(sLocale === undefined || typeof sLocale === "string", "sLocale must be a string or omitted");

	// TODO move implementation together with similar stuff to a new class "UILibrary"?
	sLibraryName = sLibraryName || "sap.ui.core";
	//sLocale = sLocale || this.getConfiguration().getLanguage();
	sLocale = sLocale;
	var sKey = sLibraryName + "/" + sLocale;
	if (!this.mResourceBundles[sKey]) {
		var sURL = sap.ui.resource(sLibraryName, 'messagebundle.properties');
		this.mResourceBundles[sKey] = jQuery.sap.resources({url : sURL, locale : sLocale});
	}
	return this.mResourceBundles[sKey];
};

sap.ui.core.Core.prototype.rerenderAllUIAreas = function() {
	if ( !this._sRerenderTimer ) {
		jQuery.sap.log.info("registering timer for delayed re-rendering");
		this._sRerenderTimer = jQuery.sap.delayedCall(0,this,"_rerenderAllUIAreas"); // decoupled for collecting several invalidations into one redraw
	}
};

sap.ui.core.Core.prototype._rerenderAllUIAreas = function() {
	// clear the timer so that the next call to re-render will create a new timer
	if (this._sRerenderTimer) {
		jQuery.sap.clearDelayedCall(this._sRerenderTimer); // explicitly stop the timer, as this call might be synchronous while still a timer is running
		this._sRerenderTimer = undefined;
	}

	var bUIUpdated = false;
	// avoid 'concurrent modifications' as IE8 can't handle them
	var mUIAreas = this.mUIAreas;
	for (var sId in mUIAreas) {
		bUIUpdated = mUIAreas[sId].rerender() || bUIUpdated;
	}

	// TODO this only covers parts of the relevant changes, 
	// A full solution requires changes in UIArea.rerender, see TODO about rendering infos there
	jQuery.sap.assert(!this._sRerenderTimer, "invalidate() while rendering");
	
	// TODO: Provide information on what actually was re-rendered...
	if(bUIUpdated) {
		this.fireUIUpdated();
	}
};


/**
 * Returns "true" if the UI is marked as dirty and will be cleaned/re-rendered after a certain small timeout.
 *
 * @return {boolean} true if some UI part is marked as dirty and will be cleaned up/re-rendered
 * @public
 */
sap.ui.core.Core.prototype.getUIDirty = function() {
	return !!this._sRerenderTimer;
};

/**
 * @name sap.ui.core.Core.prototype.UIUpdated
 * @event
 * @param {string} a
 * @param {object} source
 * @private
 */

sap.ui.core.Core.prototype.attachUIUpdated = function(fFunction, oListener) {
	this.attachEvent(sap.ui.core.Core.M_EVENTS.UIUpdated, fFunction, oListener);
};

sap.ui.core.Core.prototype.detachUIUpdated = function(fFunction, oListener) {
	this.detachEvent(sap.ui.core.Core.M_EVENTS.UIUpdated, fFunction, oListener);
};

sap.ui.core.Core.prototype.fireUIUpdated = function(mParameters) {
	this.fireEvent(sap.ui.core.Core.M_EVENTS.UIUpdated, mParameters);
};

/**
 * @name sap.ui.core.Core.prototype.ThemeChanged
 * @event
 * @param {string} a
 * @param {object} source
 */

sap.ui.core.Core.prototype.attachThemeChanged = function(fFunction, oListener) {
	this.attachEvent(sap.ui.core.Core.M_EVENTS.ThemeChanged, fFunction, oListener);
};

sap.ui.core.Core.prototype.detachThemeChanged = function(fFunction, oListener) {
	this.detachEvent(sap.ui.core.Core.M_EVENTS.ThemeChanged, fFunction, oListener);
};

sap.ui.core.Core.prototype.fireThemeChanged = function(mParameters) {
	jQuery.sap.scrollbarSize(true);
	
	// special hook for resetting theming parameters before the controls get 
	// notified (lightweight coupling to static Parameters module)
	if (sap.ui.core.theming && sap.ui.core.theming.Parameters) {
		sap.ui.core.theming.Parameters.reset();
	}
	
	// notify all elements/controls via a pseudo browser event
	var sEventId = sap.ui.core.Core.M_EVENTS.ThemeChanged;
	var oEvent = jQuery.Event(sEventId);
	jQuery.each(this.mElements, function(sId, oElement) {
		oElement._handleEvent(oEvent);
	});
	
	// notify the listeners via a control event
	this.fireEvent(sEventId, mParameters);
};

/**
 * Enforces an immediate update of the visible UI (aka "rendering").
 *
 * In general, applications should avoid calling this method and
 * instead let the framework manage any necessary rendering.
 * @public
 */
sap.ui.core.Core.prototype.applyChanges = function() {
	this._rerenderAllUIAreas();
};

/**
 * Registers the given element. Must be called once during construction.
 * @param {sap.ui.core.Element} oElement
 * @private
 */
sap.ui.core.Core.prototype.registerElement = function(oElement) {
	var oldElement = this.byId(oElement.getId());
	if ( oldElement && oldElement !== oElement ) {
		// duplicate ID detected => fail or at least log a warning
		if (this.oConfiguration.getNoDuplicateIds()) {
			jQuery.sap.log.error("adding element with duplicate id '" + oElement.getId() + "'");
			throw new Error("Error: adding element with duplicate id '" + oElement.getId() + "'");
		} else {
			jQuery.sap.log.warning("adding element with duplicate id '" + oElement.getId() + "'");
		}
	}

	this.mElements[oElement.getId()] = oElement;
};

/**
 * Deregisters the given element. Must be called once during destruction.
 * @param {sap.ui.core.Element} oElement
 * @private
 */
sap.ui.core.Core.prototype.deregisterElement = function(oElement) {
	delete this.mElements[oElement.getId()];
};

/**
 * Returns the registered element for the given id, if any.
 * @param {string} sId
 * @return {sap.ui.core.Element} the element for the given id
 * @public
 */
sap.ui.core.Core.prototype.byId = function(sId) {
	jQuery.sap.assert(sId == null || typeof sId === "string", "sId must be a string when defined");
	// allow null, as this occurs frequently and it is easier to check whether there is a control in the end than
	// first checking whether there is an ID and then checking for a control

	/*
	// test alternative implementation
	function findById(sId, mUIAreas) {
		function _find(oControl) {
			if ( !oControl )
				return undefined;
			if ( oControl.getId() === sId ) {
				return oControl;
			}
			for (var n in oControl.mAggregations) {
				var a = oControl.mAggregations[n];
				if ( jQuery.isArray(a) ) {
					for (var i=0; i<a.length; i++) {
						var r = _find(a[i]);
						if ( r ) return r;
					}
				} else if ( a instanceof sap.ui.core.Element ) {
					var r = _find(a[i]);
					if ( r ) return r;
				}
			}
			return undefined;
		}

		//var t0=new Date().getTime();
		var r=undefined;
		for (var n in mUIAreas) {
			r=_find(mUIAreas[n].getRootControl()); //TODO: Adapt to mUIAreas[n].getContent
			if ( r ) break;
		}
		//var t1=new Date().getTime();
		//t=t+(t1-t0);
		return r;
	}

	if ( findById(sId, this.mUIAreas) !== this.mElements[sId] ) {
		jQuery.sap.log.error("failed to resolve " + sId + " (" + this.mElements[sId] + ")");
	}
	*/
	return sId == null ? undefined : this.mElements[sId];
};

/**
 * Returns the registered element for the given ID, if any.
 * @param {string} sId
 * @return {sap.ui.core.Element} the element for the given id
 * @deprecated use <code>sap.ui.core.Core.byId</code> instead!
 * @function
 * @public
 */
sap.ui.core.Core.prototype.getControl = sap.ui.core.Core.prototype.byId;

/**
 * Returns the registered element for the given ID, if any.
 * @param {string} sId
 * @return {sap.ui.core.Element} the element for the given id
 * @deprecated use <code>sap.ui.core.Core.byId</code> instead!
 * @function
 * @public
 */
sap.ui.core.Core.prototype.getElementById = sap.ui.core.Core.prototype.byId;

/**
 * Returns the static, hidden area reference belonging to this core instance.<br/> It can be used e.g. for hiding
 * elements like Popups, Shadow, Blocklayer etc.<br/> If it is not yet available, creates one HTML element and attaches
 * it to the body.
 *
 * @return {DOMNode} the static, hidden area reference belonging to this core instance.
 * @public
 */
sap.ui.core.Core.prototype.getStaticAreaRef = function() {
	var sStaticId = "sap-ui-static";
	var oStatic = jQuery.sap.domById(sStaticId);
	if(!oStatic){
		var leftRight = this.getConfiguration().getRTL() ? "right" : "left";
		oStatic = jQuery("<DIV/>",{id:sStaticId})
					.css("visibility", "hidden")
					.css("height", "0")
					.css("width", "0")
					.css("overflow", "hidden")
					.css("float", leftRight)
					.prependTo(document.body)[0];

		// TODO Check whether this is sufficient
		this.createUIArea(oStatic).bInitial = false;
	}
	return oStatic;
};

/**
 * Registers a listener for control events
 * @param {function} sFunction
 * @param {object} [oListener]
 * @public
 */
sap.ui.core.Core.prototype.attachControlEvent = function(fFunction, oListener) {
	this.attachEvent(sap.ui.core.UIArea.M_EVENTS.ControlEvent, fFunction, oListener);
};

/**
 * Unregisters a listener for control events
 * @param {function} sFunction
 * @param {object} [oListener]
 * @public
 */
sap.ui.core.Core.prototype.detachControlEvent = function(fFunction, oListener) {
	this.detachEvent(sap.ui.core.UIArea.M_EVENTS.ControlEvent, fFunction, oListener);
};

/**
 * Notifies the listeners that a event on a control occures
 * @param {map} mParameters { browserEvent: jQuery.EventObject }
 * @private
 */
sap.ui.core.Core.prototype.fireControlEvent = function(mParameters) {
	this.fireEvent(sap.ui.core.UIArea.M_EVENTS.ControlEvent, mParameters);
};

/**
 * Handles a control event and forwards it to the registered control event
 * listeners
 * @param {jQuery.EventObject} control event
 * @private
 */
sap.ui.core.Core.prototype._handleControlEvent = function(/**event*/oEvent, sUiAreaId) {
	// Create a copy of the event
	var oEventClone = jQuery.Event(oEvent.type);
	jQuery.extend(oEventClone, oEvent);
	oEventClone.originalEvent = undefined;

	this.fireControlEvent({"browserEvent": oEventClone, "uiArea": sUiAreaId});
};


/**
 * Registers a Plugin to the <code>sap.ui.core.Core</code>, which lifecycle
 * will be managed (start and stop).
 * <br/>
 * Plugin object need to implement two methods:
 * <ul>
 *   <li><code>startPlugin(oCore)</code>: will be invoked, when the Plugin
 *       should start (as parameter the reference to the Core will be provided</li>
 *   <li><code>stopPlugin()</code>: will be invoked, when the Plugin should stop</li>
 * </ul>
 *
 * @param {object} oPlugin reference to a Plugin object
 * @public
 */
sap.ui.core.Core.prototype.registerPlugin = function(oPlugin) {
	jQuery.sap.assert(typeof oPlugin === "object", "oPlugin must be an object");

	// check for a valid plugin
	if (!oPlugin) {
		return;
	}

	// check if the plugin is already registered
	// if yes, the exit this function
	for (var i = 0, l = this.aPlugins.length; i < l; i++) {
		if (this.aPlugins[i] === oPlugin) {
			return;
		}
	}

	// register the plugin (keep the plugin in the plugin array)
	this.aPlugins.push(oPlugin);

	// if the Core is initialized also start the plugin
	if (this.bInitialized && oPlugin && oPlugin.startPlugin) {
		oPlugin.startPlugin(this);
	}

};

/**
 * Unregisters a Plugin out of the <code>sap.ui.core.Core</code>
 *
 * @param {object} oPlugin reference to a Plugin object
 * @public
 */
sap.ui.core.Core.prototype.unregisterPlugin = function(oPlugin) {
	jQuery.sap.assert(typeof oPlugin === "object", "oPlugin must be an object");

	// check for a valid plugin
	if (!oPlugin) {
		return;
	}

	// check if the plugin is already registered
	var iPluginIndex = -1;
	for (var i = this.aPlugins.length; i--; i >= 0) {
		if (this.aPlugins[i] === oPlugin) {
			iPluginIndex = i;
			break;
		}
	}

	// plugin was not registered!
	if (iPluginIndex == -1) {
		return;
	}

	// stop the plugin
	if (this.bInitialized && oPlugin && oPlugin.stopPlugin) {
		oPlugin.stopPlugin(this);
	}

	// remove the plugin
	this.aPlugins.splice(iPluginIndex, 1);

};

/**
 * Internal method to start all registered plugins
 * @private
 */
sap.ui.core.Core.prototype.startPlugins = function() {
	for (var i = 0, l = this.aPlugins.length; i < l; i++) {
		var oPlugin = this.aPlugins[i];
		if (oPlugin && oPlugin.startPlugin) {
			oPlugin.startPlugin(this, /* onInit*/ true);
		}
	}
};

/**
 * Internal method to stop all registered plugins
 * @private
 */
sap.ui.core.Core.prototype.stopPlugins = function() {
	for (var i = 0, l = this.aPlugins.length; i < l; i++) {
		var oPlugin = this.aPlugins[i];
		if (oPlugin && oPlugin.stopPlugin) {
			oPlugin.stopPlugin(this);
		}
	}
};

/**
 * Set the model for databinding
 * @param {sap.ui.model.Model} oModel
 * @param {string} [sName]
 * @public
 */
sap.ui.core.Core.prototype.setModel = function(oModel, sName) {
	jQuery.sap.assert(typeof oModel === "object", "oModel must be an object");
	jQuery.sap.assert(sName === undefined || typeof sName === "string", "sName must be a string or omitted");

	this.oModels[sName] = oModel;

	// notify all UI areas to update their bindings
	jQuery.each(this.mUIAreas, function (i, oUIArea){
		oUIArea.updateBindings(sName);
	});

};

/**
 * Get the model for databinding
 * @param {string} [sName]
 * @return {sap.ui.model.Model} oModel
 * @public
 */
sap.ui.core.Core.prototype.getModel = function(sName) {
	jQuery.sap.assert(sName === undefined || typeof sName === "string", "sName must be a string or omitted");
	return this.oModels[sName];
};

/**
 * Check if a Model is set to the core
 * @return {boolean} true or false
 * @public
 */
sap.ui.core.Core.prototype.hasModel = function() {
	if (!jQuery.isEmptyObject(this.oModels)) {
		return true;
	} else {
		return false;
	}
};

/**
 * Attach event-handler <code>fnFunction</code> to the 'validationError' event of <code>sap.ui.core.Core</code>.<br/>
 *
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs. This function will be called on the
 *            oListener-instance (if present) or in a 'static way'.
 * @param {object}
 *            [oListener] Object on which to call the given function. If empty, this Model is used.
 *
 * @return {sap.ui.core.Core} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.core.Core.prototype.attachValidationError = function(fnFunction, oListener) {
	this.attachEvent(sap.ui.core.Core.M_EVENTS.ValidationError, fnFunction, oListener);
	return this;
};

/**
 * Detach event-handler <code>fnFunction</code> from the 'validationError' event of <code>sap.ui.core.Core</code>.<br/>
 *
 * The passed function and listener object must match the ones previously used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Object on which the given function had to be called.
 * @return {sap.ui.core.Core} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.core.Core.prototype.detachValidationError = function(fnFunction, oListener) {
	this.detachEvent(sap.ui.core.Core.M_EVENTS.ValidationError, fnFunction, oListener);
	return this;
};

/**
 * Attach event-handler <code>fnFunction</code> to the 'parseError' event of <code>sap.ui.core.Core</code>.<br/>
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs. This function will be called on the
 *            oListener-instance (if present) or in a 'static way'.
 * @param {object}
 *            [oListener] Object on which to call the given function. If empty, this Model is used.
 *
 * @return {sap.ui.core.Core} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.core.Core.prototype.attachParseError = function(fnFunction, oListener) {
	this.attachEvent(sap.ui.core.Core.M_EVENTS.ParseError, fnFunction, oListener);
	return this;
};

/**
 * Detach event-handler <code>fnFunction</code> from the 'parseError' event of <code>sap.ui.core.Core</code>.<br/>
 *
 * The passed function and listener object must match the ones previously used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Object on which the given function had to be called.
 * @return {sap.ui.core.Core} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.core.Core.prototype.detachParseError = function(fnFunction, oListener) {
	this.detachEvent(sap.ui.core.Core.M_EVENTS.ParseError, fnFunction, oListener);
	return this;
};

/**
 * Attach event-handler <code>fnFunction</code> to the 'formatError' event of <code>sap.ui.core.Core</code>.<br/>
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs. This function will be called on the
 *            oListener-instance (if present) or in a 'static way'.
 * @param {object}
 *            [oListener] Object on which to call the given function. If empty, this Model is used.
 *
 * @return {sap.ui.core.Core} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.core.Core.prototype.attachFormatError = function(fnFunction, oListener) {
	this.attachEvent(sap.ui.core.Core.M_EVENTS.FormatError, fnFunction, oListener);
	return this;
};

/**
 * Detach event-handler <code>fnFunction</code> from the 'formatError' event of <code>sap.ui.core.Core</code>.<br/>
 *
 * The passed function and listener object must match the ones previously used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Object on which the given function had to be called.
 * @return {sap.ui.core.Core} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.core.Core.prototype.detachFormatError = function(fnFunction, oListener) {
	this.detachEvent(sap.ui.core.Core.M_EVENTS.FormatError, fnFunction, oListener);
	return this;
};

/**
 * Attach event-handler <code>fnFunction</code> to the 'validationSuccess' event of <code>sap.ui.core.Core</code>.<br/>
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs. This function will be called on the
 *            oListener-instance (if present) or in a 'static way'.
 * @param {object}
 *            [oListener] Object on which to call the given function. If empty, this Model is used.
 *
 * @return {sap.ui.core.Core} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.core.Core.prototype.attachValidationSuccess = function(fnFunction, oListener) {
	this.attachEvent(sap.ui.core.Core.M_EVENTS.ValidationSuccess, fnFunction, oListener);
	return this;
};

/**
 * Detach event-handler <code>fnFunction</code> from the 'validationSuccess' event of <code>sap.ui.core.Core</code>.<br/>
 *
 * The passed function and listener object must match the ones previously used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Object on which the given function had to be called.
 * @return {sap.ui.core.Core} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.core.Core.prototype.detachValidationSuccess = function(fnFunction, oListener) {
	this.detachEvent(sap.ui.core.Core.M_EVENTS.ValidationSuccess, fnFunction, oListener);
	return this;
};


/**
 * Fire event parseError to attached listeners.
 *
 * Expects following event parameters:
 * <ul>
 * <li>'element' of type <code>sap.ui.core.Element</code> </li>
 * <li>'property' of type <code>string</code> </li>
 * <li>'type' of type <code>string</code> </li>
 * <li>'newValue' of type <code>object</code> </li>
 * <li>'oldValue' of type <code>object</code> </li>
 * <li>'exception' of type <code>object</code> </li>
 * </ul>
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.core.Core} <code>this</code> to allow method chaining
 * @protected
 */
sap.ui.core.Core.prototype.fireParseError = function(mArguments) {
	this.fireEvent(sap.ui.core.Core.M_EVENTS.ParseError, mArguments);
	return this;
};

/**
 * The 'parseError' event is fired when input parsing fails.
 *
 * @name sap.ui.core.Core#parseError
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters

 * @param {sap.ui.core.Element} oControlEvent.getParameters.element The Element where the parse error occurred
 * @param {string} oControlEvent.getParameters.property The property name of the element where the parse error occurred
 * @param {type} oControlEvent.getParameters.type The type of the property
 * @param {object} oControlEvent.getParameters.newValue The value of the property which was entered when the parse error occurred
 * @param {object} oControlEvent.getParameters.oldValue The value of the property which was present before a new value was entered (before the parse error)
 * @param {object} oControlEvent.getParameters.exception The exception object which occurred and has more information about the parse error
 * @public
 */

/**
 * Fire event validationError to attached listeners.
 *
 * Expects following event parameters:
 * <ul>
 * <li>'element' of type <code>sap.ui.core.Element</code> </li>
 * <li>'property' of type <code>string</code> </li>
 * <li>'type' of type <code>string</code> </li>
 * <li>'newValue' of type <code>object</code> </li>
 * <li>'oldValue' of type <code>object</code> </li>
 * <li>'exception' of type <code>object</code> </li>
 * </ul>
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.core.Core} <code>this</code> to allow method chaining
 * @protected
 */
sap.ui.core.Core.prototype.fireValidationError = function(mArguments) {
	this.fireEvent(sap.ui.core.Core.M_EVENTS.ValidationError, mArguments);
	return this;
};

/**
 * The 'validationError' event is fired when validation of the input fails.
 *
 * @name sap.ui.core.Core#validationError
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters

 * @param {sap.ui.core.Element} oControlEvent.getParameters.element The Element where the validation error occurred
 * @param {string} oControlEvent.getParameters.property The property name of the element where the validation error occurred
 * @param {type} oControlEvent.getParameters.type The type of the property
 * @param {object} oControlEvent.getParameters.newValue The value of the property which was entered when the validation error occurred
 * @param {object} oControlEvent.getParameters.oldValue The value of the property which was present before a new value was entered (before the validation error)
 * @param {object} oControlEvent.getParameters.exception The exception object which occurred and has more information about the validation error
 * @public
 */

/**
 * Fire event formatError to attached listeners.
 *
 * Expects following event parameters:
 * <ul>
 * <li>'element' of type <code>sap.ui.core.Element</code> </li>
 * <li>'property' of type <code>string</code> </li>
 * <li>'type' of type <code>string</code> </li>
 * <li>'newValue' of type <code>object</code> </li>
 * <li>'oldValue' of type <code>object</code> </li>
 * <li>'exception' of type <code>object</code> </li>
 * </ul>
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.core.Core} <code>this</code> to allow method chaining
 * @protected
 */
sap.ui.core.Core.prototype.fireFormatError = function(mArguments) {
	this.fireEvent(sap.ui.core.Core.M_EVENTS.FormatError, mArguments);
	return this;
};

/**
 * The 'formatError' event is fired when a value formatting fails. This can happen when a value stored in the model cannot be formatted to be displayed in an element property.
 *
 * @name sap.ui.core.Core#formatError
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters

 * @param {sap.ui.core.Element} oControlEvent.getParameters.element The Element where the format error occurred
 * @param {string} oControlEvent.getParameters.property The property name of the element where the format error occurred
 * @param {type} oControlEvent.getParameters.type The type of the property
 * @param {object} oControlEvent.getParameters.newValue The value of the property which was entered when the format error occurred
 * @param {object} oControlEvent.getParameters.oldValue The value of the property which was present before a new value was entered (before the format error)
 * @param {object} oControlEvent.getParameters.exception The exception object which occurred and has more information about the format error
 * @public
 */

/**
 * Fire event validationSuccess to attached listeners.
 *
 * Expects following event parameters:
 * <ul>
 * <li>'element' of type <code>sap.ui.core.Element</code> </li>
 * <li>'property' of type <code>string</code> </li>
 * <li>'type' of type <code>string</code> </li>
 * <li>'newValue' of type <code>object</code> </li>
 * <li>'oldValue' of type <code>object</code> </li>
 * </ul>
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.core.Core} <code>this</code> to allow method chaining
 * @protected
 */
sap.ui.core.Core.prototype.fireValidationSuccess = function(mArguments) {
	this.fireEvent(sap.ui.core.Core.M_EVENTS.ValidationSuccess, mArguments);
	return this;
};

/**
 * The 'validationSuccess' event is fired when a value validation was successfully completed.
 *
 * @name sap.ui.core.Core#validationSuccess
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters

 * @param {sap.ui.core.Element} oControlEvent.getParameters.element The Element where the successful validation occurred
 * @param {string} oControlEvent.getParameters.property The property name of the element where the successfull validation occurred
 * @param {type} oControlEvent.getParameters.type The type of the property
 * @param {object} oControlEvent.getParameters.newValue The value of the property which was entered when the validation occurred
 * @param {object} oControlEvent.getParameters.oldValue The value of the property which was present before a new value was entered (before the validation)
 * @public
 */

/**
 * Check if the script is running on mobile
 * @return {boolean} true or false
 * @public
 */
sap.ui.core.Core.prototype.isMobile = function() {
	return !!window.orientation;
};

/**
 * @name sap.ui.core.CorePlugin
 * @interface Contract for plugins that want to extend the core runtime
 */

/**
 * Called by the Core after it has been initialized.
 * If a plugin is added to the core after its initialization, then
 * this method is called during registration of the plugin.
 *
 * Implementing this method is optional for a plugin.
 *
 * @name sap.ui.core.CorePlugin.prototype.startPlugin
 * @param {sap.ui.core.Core} oCore reference to the core
 * @param {boolean} bOnInit whether the hook is called during Core.init() or later
 * @function
 */

/**
 * Called by the Core when it is shutdown or when a plugin is
 * deregistered from the core.
 *
 * Implementing this method is optional for a plugin.
 *
 * @name sap.ui.core.CorePlugin.prototype.stopPlugin
 * @param {sap.ui.core.Core} oCore reference to the core
 * @function
 */


// TODO come up with more sophisticated solution.
// e.g. check for script tag, check for config... if not (yet) there, delay creation by e.g. 500ms or so.
if(!window.sap.ui.getCore){
	/**
	 * Create Core instance and make it available.
	 */
	(function(){
		new sap.ui.core.Core();
	}());
}

/**
 * Displays the control tree with the given root inside the area of the given
 * DOM reference (or inside the DOM node with the given ID) or in the given Control.
 *
 * Example:
 * <pre>
 *   &lt;div id="SAPUI5UiArea">&lt;/div>
 *   &lt;script type="text/javascript">
 *     var oRoot = new sap.ui.commons.Label();
 *     oRoot.setText("Hello world!");
 *     sap.ui.setRoot("SAPUI5UiArea", oRoot);
 *   &lt;/script>
 * </pre>
 * <p>
 *
 * This is a shortcut for <code>sap.ui.getCore().setRoot()</code>.
 *
 * Internally, if a string is given that does not identify an UIArea or a control
 * then implicitly a new <code>UIArea</code> is created for the given DOM reference
 * and the given control is added.
 *
 * @param {string|DOMRef|sap.ui.core.Control} oDomRef a Dom Reference or Id String of the UIArea
 * @param {sap.ui.base.Interface | sap.ui.core.Control}
 *            oControl the Control that should be added to the <code>UIArea</code>.
 * @public
 * @deprecated Use function <code>placeAt</code> of <code>sap.ui.core.Control</code> instead.
 */
sap.ui.setRoot = function(oDomRef, oControl) {
	jQuery.sap.assert(typeof oDomRef === "string" || typeof oDomRef === "object", "oDomRef must be a string or object");
	jQuery.sap.assert(oControl instanceof sap.ui.base.Interface || oControl instanceof sap.ui.core.Control, "oControl must be a Control or Interface");

	sap.ui.getCore().setRoot(oDomRef, oControl);
};

}; // end of sap.ui.core.Core

// as this module contains the Core, we ensure that the Core has been booted
sap.ui.getCore().boot && sap.ui.getCore().boot();

